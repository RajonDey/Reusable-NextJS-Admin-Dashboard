"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-table/build/lib/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnSizing),\n/* harmony export */   Expanding: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Expanding),\n/* harmony export */   Filters: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Filters),\n/* harmony export */   Grouping: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Grouping),\n/* harmony export */   Headers: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Headers),\n/* harmony export */   Ordering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Ordering),\n/* harmony export */   Pagination: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Pagination),\n/* harmony export */   Pinning: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Pinning),\n/* harmony export */   RowSelection: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowSelection),\n/* harmony export */   Sorting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Sorting),\n/* harmony export */   Visibility: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Visibility),\n/* harmony export */   _getVisibleLeafColumns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__._getVisibleLeafColumns),\n/* harmony export */   aggregationFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.buildHeaderGroups),\n/* harmony export */   createCell: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createCell),\n/* harmony export */   createColumn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumn),\n/* harmony export */   createColumnHelper: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumnHelper),\n/* harmony export */   createRow: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createRow),\n/* harmony export */   createTable: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable),\n/* harmony export */   defaultColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.expandRows),\n/* harmony export */   filterFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.filterFns),\n/* harmony export */   flattenBy: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.flattenBy),\n/* harmony export */   flexRender: () => (/* binding */ flexRender),\n/* harmony export */   functionalUpdate: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getGroupedRowModel),\n/* harmony export */   getMemoOptions: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getMemoOptions),\n/* harmony export */   getPaginationRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getSortedRowModel),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isFunction),\n/* harmony export */   isNumberArray: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isNumberArray),\n/* harmony export */   isRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.makeStateUpdater),\n/* harmony export */   memo: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.memo),\n/* harmony export */   noop: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.noop),\n/* harmony export */   orderColumns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.sortingFns),\n/* harmony export */   useReactTable: () => (/* binding */ useReactTable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tanstack/table-core */ \"(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\");\n/**\n   * react-table\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */ \n\n\n//\n/**\n * If rendering headers, cells, or footers with custom markup, use flexRender instead of `cell.getValue()` or `cell.renderValue()`.\n */ function flexRender(Comp, props) {\n    return !Comp ? null : isReactComponent(Comp) ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Comp, props) : Comp;\n}\nfunction isReactComponent(component) {\n    return isClassComponent(component) || typeof component === \"function\" || isExoticComponent(component);\n}\nfunction isClassComponent(component) {\n    return typeof component === \"function\" && (()=>{\n        const proto = Object.getPrototypeOf(component);\n        return proto.prototype && proto.prototype.isReactComponent;\n    })();\n}\nfunction isExoticComponent(component) {\n    return typeof component === \"object\" && typeof component.$$typeof === \"symbol\" && [\n        \"react.memo\",\n        \"react.forward_ref\"\n    ].includes(component.$$typeof.description);\n}\nfunction useReactTable(options) {\n    // Compose in the generic options to the user options\n    const resolvedOptions = {\n        state: {},\n        // Dummy state\n        onStateChange: ()=>{},\n        // noop\n        renderFallbackValue: null,\n        ...options\n    };\n    // Create a new table and store it in state\n    const [tableRef] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>({\n            current: (0,_tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable)(resolvedOptions)\n        }));\n    // By default, manage table state here using the table's initial state\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>tableRef.current.initialState);\n    // Compose the default state above with any user state. This will allow the user\n    // to only control a subset of the state if desired.\n    tableRef.current.setOptions((prev)=>({\n            ...prev,\n            ...options,\n            state: {\n                ...state,\n                ...options.state\n            },\n            // Similarly, we'll maintain both our internal state and any user-provided\n            // state.\n            onStateChange: (updater)=>{\n                setState(updater);\n                options.onStateChange == null || options.onStateChange(updater);\n            }\n        }));\n    return tableRef.current;\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXRhYmxlL2J1aWxkL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztHQVNHLEdBQzRCO0FBQ29CO0FBQ2Q7QUFFckMsRUFBRTtBQUVGOztDQUVDLEdBQ0QsU0FBU0UsV0FBV0MsSUFBSSxFQUFFQyxLQUFLO0lBQzdCLE9BQU8sQ0FBQ0QsT0FBTyxPQUFPRSxpQkFBaUJGLFFBQVEsV0FBVyxHQUFFSCxnREFBbUIsQ0FBQ0csTUFBTUMsU0FBU0Q7QUFDakc7QUFDQSxTQUFTRSxpQkFBaUJFLFNBQVM7SUFDakMsT0FBT0MsaUJBQWlCRCxjQUFjLE9BQU9BLGNBQWMsY0FBY0Usa0JBQWtCRjtBQUM3RjtBQUNBLFNBQVNDLGlCQUFpQkQsU0FBUztJQUNqQyxPQUFPLE9BQU9BLGNBQWMsY0FBYyxDQUFDO1FBQ3pDLE1BQU1HLFFBQVFDLE9BQU9DLGNBQWMsQ0FBQ0w7UUFDcEMsT0FBT0csTUFBTUcsU0FBUyxJQUFJSCxNQUFNRyxTQUFTLENBQUNSLGdCQUFnQjtJQUM1RDtBQUNGO0FBQ0EsU0FBU0ksa0JBQWtCRixTQUFTO0lBQ2xDLE9BQU8sT0FBT0EsY0FBYyxZQUFZLE9BQU9BLFVBQVVPLFFBQVEsS0FBSyxZQUFZO1FBQUM7UUFBYztLQUFvQixDQUFDQyxRQUFRLENBQUNSLFVBQVVPLFFBQVEsQ0FBQ0UsV0FBVztBQUMvSjtBQUNBLFNBQVNDLGNBQWNDLE9BQU87SUFDNUIscURBQXFEO0lBQ3JELE1BQU1DLGtCQUFrQjtRQUN0QkMsT0FBTyxDQUFDO1FBQ1IsY0FBYztRQUNkQyxlQUFlLEtBQU87UUFDdEIsT0FBTztRQUNQQyxxQkFBcUI7UUFDckIsR0FBR0osT0FBTztJQUNaO0lBRUEsMkNBQTJDO0lBQzNDLE1BQU0sQ0FBQ0ssU0FBUyxHQUFHdkIsMkNBQWMsQ0FBQyxJQUFPO1lBQ3ZDeUIsU0FBU3hCLGlFQUFXQSxDQUFDa0I7UUFDdkI7SUFFQSxzRUFBc0U7SUFDdEUsTUFBTSxDQUFDQyxPQUFPTSxTQUFTLEdBQUcxQiwyQ0FBYyxDQUFDLElBQU11QixTQUFTRSxPQUFPLENBQUNFLFlBQVk7SUFFNUUsZ0ZBQWdGO0lBQ2hGLG9EQUFvRDtJQUNwREosU0FBU0UsT0FBTyxDQUFDRyxVQUFVLENBQUNDLENBQUFBLE9BQVM7WUFDbkMsR0FBR0EsSUFBSTtZQUNQLEdBQUdYLE9BQU87WUFDVkUsT0FBTztnQkFDTCxHQUFHQSxLQUFLO2dCQUNSLEdBQUdGLFFBQVFFLEtBQUs7WUFDbEI7WUFDQSwwRUFBMEU7WUFDMUUsU0FBUztZQUNUQyxlQUFlUyxDQUFBQTtnQkFDYkosU0FBU0k7Z0JBQ1RaLFFBQVFHLGFBQWEsSUFBSSxRQUFRSCxRQUFRRyxhQUFhLENBQUNTO1lBQ3pEO1FBQ0Y7SUFDQSxPQUFPUCxTQUFTRSxPQUFPO0FBQ3pCO0FBRXFDLENBQ3JDLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JhY2tzdWItZmUtbmV4dC8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtdGFibGUvYnVpbGQvbGliL2luZGV4Lm1qcz9hMTZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICAgKiByZWFjdC10YWJsZVxuICAgKlxuICAgKiBDb3B5cmlnaHQgKGMpIFRhblN0YWNrXG4gICAqXG4gICAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICAgKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gICAqXG4gICAqIEBsaWNlbnNlIE1JVFxuICAgKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVRhYmxlIH0gZnJvbSAnQHRhbnN0YWNrL3RhYmxlLWNvcmUnO1xuZXhwb3J0ICogZnJvbSAnQHRhbnN0YWNrL3RhYmxlLWNvcmUnO1xuXG4vL1xuXG4vKipcbiAqIElmIHJlbmRlcmluZyBoZWFkZXJzLCBjZWxscywgb3IgZm9vdGVycyB3aXRoIGN1c3RvbSBtYXJrdXAsIHVzZSBmbGV4UmVuZGVyIGluc3RlYWQgb2YgYGNlbGwuZ2V0VmFsdWUoKWAgb3IgYGNlbGwucmVuZGVyVmFsdWUoKWAuXG4gKi9cbmZ1bmN0aW9uIGZsZXhSZW5kZXIoQ29tcCwgcHJvcHMpIHtcbiAgcmV0dXJuICFDb21wID8gbnVsbCA6IGlzUmVhY3RDb21wb25lbnQoQ29tcCkgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wLCBwcm9wcykgOiBDb21wO1xufVxuZnVuY3Rpb24gaXNSZWFjdENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSB8fCB0eXBlb2YgY29tcG9uZW50ID09PSAnZnVuY3Rpb24nIHx8IGlzRXhvdGljQ29tcG9uZW50KGNvbXBvbmVudCk7XG59XG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gdHlwZW9mIGNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiAoKCkgPT4ge1xuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbXBvbmVudCk7XG4gICAgcmV0dXJuIHByb3RvLnByb3RvdHlwZSAmJiBwcm90by5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudDtcbiAgfSkoKTtcbn1cbmZ1bmN0aW9uIGlzRXhvdGljQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gdHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbXBvbmVudC4kJHR5cGVvZiA9PT0gJ3N5bWJvbCcgJiYgWydyZWFjdC5tZW1vJywgJ3JlYWN0LmZvcndhcmRfcmVmJ10uaW5jbHVkZXMoY29tcG9uZW50LiQkdHlwZW9mLmRlc2NyaXB0aW9uKTtcbn1cbmZ1bmN0aW9uIHVzZVJlYWN0VGFibGUob3B0aW9ucykge1xuICAvLyBDb21wb3NlIGluIHRoZSBnZW5lcmljIG9wdGlvbnMgdG8gdGhlIHVzZXIgb3B0aW9uc1xuICBjb25zdCByZXNvbHZlZE9wdGlvbnMgPSB7XG4gICAgc3RhdGU6IHt9LFxuICAgIC8vIER1bW15IHN0YXRlXG4gICAgb25TdGF0ZUNoYW5nZTogKCkgPT4ge30sXG4gICAgLy8gbm9vcFxuICAgIHJlbmRlckZhbGxiYWNrVmFsdWU6IG51bGwsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIG5ldyB0YWJsZSBhbmQgc3RvcmUgaXQgaW4gc3RhdGVcbiAgY29uc3QgW3RhYmxlUmVmXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+ICh7XG4gICAgY3VycmVudDogY3JlYXRlVGFibGUocmVzb2x2ZWRPcHRpb25zKVxuICB9KSk7XG5cbiAgLy8gQnkgZGVmYXVsdCwgbWFuYWdlIHRhYmxlIHN0YXRlIGhlcmUgdXNpbmcgdGhlIHRhYmxlJ3MgaW5pdGlhbCBzdGF0ZVxuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHRhYmxlUmVmLmN1cnJlbnQuaW5pdGlhbFN0YXRlKTtcblxuICAvLyBDb21wb3NlIHRoZSBkZWZhdWx0IHN0YXRlIGFib3ZlIHdpdGggYW55IHVzZXIgc3RhdGUuIFRoaXMgd2lsbCBhbGxvdyB0aGUgdXNlclxuICAvLyB0byBvbmx5IGNvbnRyb2wgYSBzdWJzZXQgb2YgdGhlIHN0YXRlIGlmIGRlc2lyZWQuXG4gIHRhYmxlUmVmLmN1cnJlbnQuc2V0T3B0aW9ucyhwcmV2ID0+ICh7XG4gICAgLi4ucHJldixcbiAgICAuLi5vcHRpb25zLFxuICAgIHN0YXRlOiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIC4uLm9wdGlvbnMuc3RhdGVcbiAgICB9LFxuICAgIC8vIFNpbWlsYXJseSwgd2UnbGwgbWFpbnRhaW4gYm90aCBvdXIgaW50ZXJuYWwgc3RhdGUgYW5kIGFueSB1c2VyLXByb3ZpZGVkXG4gICAgLy8gc3RhdGUuXG4gICAgb25TdGF0ZUNoYW5nZTogdXBkYXRlciA9PiB7XG4gICAgICBzZXRTdGF0ZSh1cGRhdGVyKTtcbiAgICAgIG9wdGlvbnMub25TdGF0ZUNoYW5nZSA9PSBudWxsIHx8IG9wdGlvbnMub25TdGF0ZUNoYW5nZSh1cGRhdGVyKTtcbiAgICB9XG4gIH0pKTtcbiAgcmV0dXJuIHRhYmxlUmVmLmN1cnJlbnQ7XG59XG5cbmV4cG9ydCB7IGZsZXhSZW5kZXIsIHVzZVJlYWN0VGFibGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZVRhYmxlIiwiZmxleFJlbmRlciIsIkNvbXAiLCJwcm9wcyIsImlzUmVhY3RDb21wb25lbnQiLCJjcmVhdGVFbGVtZW50IiwiY29tcG9uZW50IiwiaXNDbGFzc0NvbXBvbmVudCIsImlzRXhvdGljQ29tcG9uZW50IiwicHJvdG8iLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSIsIiQkdHlwZW9mIiwiaW5jbHVkZXMiLCJkZXNjcmlwdGlvbiIsInVzZVJlYWN0VGFibGUiLCJvcHRpb25zIiwicmVzb2x2ZWRPcHRpb25zIiwic3RhdGUiLCJvblN0YXRlQ2hhbmdlIiwicmVuZGVyRmFsbGJhY2tWYWx1ZSIsInRhYmxlUmVmIiwidXNlU3RhdGUiLCJjdXJyZW50Iiwic2V0U3RhdGUiLCJpbml0aWFsU3RhdGUiLCJzZXRPcHRpb25zIiwicHJldiIsInVwZGF0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/table-core/build/lib/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnSizing: () => (/* binding */ ColumnSizing),\n/* harmony export */   Expanding: () => (/* binding */ Expanding),\n/* harmony export */   Filters: () => (/* binding */ Filters),\n/* harmony export */   Grouping: () => (/* binding */ Grouping),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   Ordering: () => (/* binding */ Ordering),\n/* harmony export */   Pagination: () => (/* binding */ Pagination),\n/* harmony export */   Pinning: () => (/* binding */ Pinning),\n/* harmony export */   RowSelection: () => (/* binding */ RowSelection),\n/* harmony export */   Sorting: () => (/* binding */ Sorting),\n/* harmony export */   Visibility: () => (/* binding */ Visibility),\n/* harmony export */   _getVisibleLeafColumns: () => (/* binding */ _getVisibleLeafColumns),\n/* harmony export */   aggregationFns: () => (/* binding */ aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* binding */ buildHeaderGroups),\n/* harmony export */   createCell: () => (/* binding */ createCell),\n/* harmony export */   createColumn: () => (/* binding */ createColumn),\n/* harmony export */   createColumnHelper: () => (/* binding */ createColumnHelper),\n/* harmony export */   createRow: () => (/* binding */ createRow),\n/* harmony export */   createTable: () => (/* binding */ createTable),\n/* harmony export */   defaultColumnSizing: () => (/* binding */ defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* binding */ expandRows),\n/* harmony export */   filterFns: () => (/* binding */ filterFns),\n/* harmony export */   flattenBy: () => (/* binding */ flattenBy),\n/* harmony export */   functionalUpdate: () => (/* binding */ functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* binding */ getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* binding */ getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* binding */ getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* binding */ getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* binding */ getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* binding */ getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* binding */ getGroupedRowModel),\n/* harmony export */   getMemoOptions: () => (/* binding */ getMemoOptions),\n/* harmony export */   getPaginationRowModel: () => (/* binding */ getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* binding */ getSortedRowModel),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isNumberArray: () => (/* binding */ isNumberArray),\n/* harmony export */   isRowSelected: () => (/* binding */ isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* binding */ isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* binding */ makeStateUpdater),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   orderColumns: () => (/* binding */ orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* binding */ passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* binding */ reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* binding */ selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* binding */ shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* binding */ sortingFns)\n/* harmony export */ });\n/**\n   * table-core\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */ // Is this type a tuple?\n// If this type is a tuple, what indices are allowed?\n///\nfunction functionalUpdate(updater, input) {\n    return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction noop() {\n//\n}\nfunction makeStateUpdater(key, instance) {\n    return (updater)=>{\n        instance.setState((old)=>{\n            return {\n                ...old,\n                [key]: functionalUpdate(updater, old[key])\n            };\n        });\n    };\n}\nfunction isFunction(d) {\n    return d instanceof Function;\n}\nfunction isNumberArray(d) {\n    return Array.isArray(d) && d.every((val)=>typeof val === \"number\");\n}\nfunction flattenBy(arr, getChildren) {\n    const flat = [];\n    const recurse = (subArr)=>{\n        subArr.forEach((item)=>{\n            flat.push(item);\n            const children = getChildren(item);\n            if (children != null && children.length) {\n                recurse(children);\n            }\n        });\n    };\n    recurse(arr);\n    return flat;\n}\nfunction memo(getDeps, fn, opts) {\n    let deps = [];\n    let result;\n    return (depArgs)=>{\n        let depTime;\n        if (opts.key && opts.debug) depTime = Date.now();\n        const newDeps = getDeps(depArgs);\n        const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index)=>deps[index] !== dep);\n        if (!depsChanged) {\n            return result;\n        }\n        deps = newDeps;\n        let resultTime;\n        if (opts.key && opts.debug) resultTime = Date.now();\n        result = fn(...newDeps);\n        opts == null || opts.onChange == null || opts.onChange(result);\n        if (opts.key && opts.debug) {\n            if (opts != null && opts.debug()) {\n                const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n                const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n                const resultFpsPercentage = resultEndTime / 16;\n                const pad = (str, num)=>{\n                    str = String(str);\n                    while(str.length < num){\n                        str = \" \" + str;\n                    }\n                    return str;\n                };\n                console.info(`%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n            }\n        }\n        return result;\n    };\n}\nfunction getMemoOptions(tableOptions, debugLevel, key, onChange) {\n    return {\n        debug: ()=>{\n            var _tableOptions$debugAl;\n            return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];\n        },\n        key:  true && key,\n        onChange\n    };\n}\nfunction createColumn(table, columnDef, depth, parent) {\n    var _ref, _resolvedColumnDef$id;\n    const defaultColumn = table._getDefaultColumnDef();\n    const resolvedColumnDef = {\n        ...defaultColumn,\n        ...columnDef\n    };\n    const accessorKey = resolvedColumnDef.accessorKey;\n    let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? accessorKey.replace(\".\", \"_\") : undefined) != null ? _ref : typeof resolvedColumnDef.header === \"string\" ? resolvedColumnDef.header : undefined;\n    let accessorFn;\n    if (resolvedColumnDef.accessorFn) {\n        accessorFn = resolvedColumnDef.accessorFn;\n    } else if (accessorKey) {\n        // Support deep accessor keys\n        if (accessorKey.includes(\".\")) {\n            accessorFn = (originalRow)=>{\n                let result = originalRow;\n                for (const key of accessorKey.split(\".\")){\n                    var _result;\n                    result = (_result = result) == null ? void 0 : _result[key];\n                    if ( true && result === undefined) {\n                        console.warn(`\"${key}\" in deeply nested key \"${accessorKey}\" returned undefined.`);\n                    }\n                }\n                return result;\n            };\n        } else {\n            accessorFn = (originalRow)=>originalRow[resolvedColumnDef.accessorKey];\n        }\n    }\n    if (!id) {\n        if (true) {\n            throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);\n        }\n        throw new Error();\n    }\n    let column = {\n        id: `${String(id)}`,\n        accessorFn,\n        parent: parent,\n        depth,\n        columnDef: resolvedColumnDef,\n        columns: [],\n        getFlatColumns: memo(()=>[\n                true\n            ], ()=>{\n            var _column$columns;\n            return [\n                column,\n                ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d)=>d.getFlatColumns())\n            ];\n        }, getMemoOptions(table.options, \"debugColumns\", \"column.getFlatColumns\")),\n        getLeafColumns: memo(()=>[\n                table._getOrderColumnsFn()\n            ], (orderColumns)=>{\n            var _column$columns2;\n            if ((_column$columns2 = column.columns) != null && _column$columns2.length) {\n                let leafColumns = column.columns.flatMap((column)=>column.getLeafColumns());\n                return orderColumns(leafColumns);\n            }\n            return [\n                column\n            ];\n        }, getMemoOptions(table.options, \"debugColumns\", \"column.getLeafColumns\"))\n    };\n    for (const feature of table._features){\n        feature.createColumn == null || feature.createColumn(column, table);\n    }\n    // Yes, we have to convert table to uknown, because we know more than the compiler here.\n    return column;\n}\nconst debug = \"debugHeaders\";\n//\nfunction createHeader(table, column, options) {\n    var _options$id;\n    const id = (_options$id = options.id) != null ? _options$id : column.id;\n    let header = {\n        id,\n        column,\n        index: options.index,\n        isPlaceholder: !!options.isPlaceholder,\n        placeholderId: options.placeholderId,\n        depth: options.depth,\n        subHeaders: [],\n        colSpan: 0,\n        rowSpan: 0,\n        headerGroup: null,\n        getLeafHeaders: ()=>{\n            const leafHeaders = [];\n            const recurseHeader = (h)=>{\n                if (h.subHeaders && h.subHeaders.length) {\n                    h.subHeaders.map(recurseHeader);\n                }\n                leafHeaders.push(h);\n            };\n            recurseHeader(header);\n            return leafHeaders;\n        },\n        getContext: ()=>({\n                table,\n                header: header,\n                column\n            })\n    };\n    table._features.forEach((feature)=>{\n        feature.createHeader == null || feature.createHeader(header, table);\n    });\n    return header;\n}\nconst Headers = {\n    createTable: (table)=>{\n        // Header Groups\n        table.getHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            var _left$map$filter, _right$map$filter;\n            const leftColumns = (_left$map$filter = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];\n            const rightColumns = (_right$map$filter = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];\n            const centerColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            const headerGroups = buildHeaderGroups(allColumns, [\n                ...leftColumns,\n                ...centerColumns,\n                ...rightColumns\n            ], table);\n            return headerGroups;\n        }, getMemoOptions(table.options, debug, \"getHeaderGroups\"));\n        table.getCenterHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            leafColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            return buildHeaderGroups(allColumns, leafColumns, table, \"center\");\n        }, getMemoOptions(table.options, debug, \"getCenterHeaderGroups\"));\n        table.getLeftHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, leafColumns, left)=>{\n            var _left$map$filter2;\n            const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"left\");\n        }, getMemoOptions(table.options, debug, \"getLeftHeaderGroups\"));\n        table.getRightHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, right)=>{\n            var _right$map$filter2;\n            const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"right\");\n        }, getMemoOptions(table.options, debug, \"getRightHeaderGroups\"));\n        // Footer Groups\n        table.getFooterGroups = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getFooterGroups\"));\n        table.getLeftFooterGroups = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getLeftFooterGroups\"));\n        table.getCenterFooterGroups = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getCenterFooterGroups\"));\n        table.getRightFooterGroups = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getRightFooterGroups\"));\n        // Flat Headers\n        table.getFlatHeaders = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return headerGroups.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getFlatHeaders\"));\n        table.getLeftFlatHeaders = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getLeftFlatHeaders\"));\n        table.getCenterFlatHeaders = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getCenterFlatHeaders\"));\n        table.getRightFlatHeaders = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getRightFlatHeaders\"));\n        // Leaf Headers\n        table.getCenterLeafHeaders = memo(()=>[\n                table.getCenterFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders;\n                return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);\n            });\n        }, getMemoOptions(table.options, debug, \"getCenterLeafHeaders\"));\n        table.getLeftLeafHeaders = memo(()=>[\n                table.getLeftFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders2;\n                return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);\n            });\n        }, getMemoOptions(table.options, debug, \"getLeftLeafHeaders\"));\n        table.getRightLeafHeaders = memo(()=>[\n                table.getRightFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders3;\n                return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);\n            });\n        }, getMemoOptions(table.options, debug, \"getRightLeafHeaders\"));\n        table.getLeafHeaders = memo(()=>[\n                table.getLeftHeaderGroups(),\n                table.getCenterHeaderGroups(),\n                table.getRightHeaderGroups()\n            ], (left, center, right)=>{\n            var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;\n            return [\n                ...(_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [],\n                ...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [],\n                ...(_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []\n            ].map((header)=>{\n                return header.getLeafHeaders();\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getLeafHeaders\"));\n    }\n};\nfunction buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {\n    var _headerGroups$0$heade, _headerGroups$;\n    // Find the max depth of the columns:\n    // build the leaf column row\n    // build each buffer row going up\n    //    placeholder for non-existent level\n    //    real column for existing level\n    let maxDepth = 0;\n    const findMaxDepth = function(columns, depth) {\n        if (depth === void 0) {\n            depth = 1;\n        }\n        maxDepth = Math.max(maxDepth, depth);\n        columns.filter((column)=>column.getIsVisible()).forEach((column)=>{\n            var _column$columns;\n            if ((_column$columns = column.columns) != null && _column$columns.length) {\n                findMaxDepth(column.columns, depth + 1);\n            }\n        }, 0);\n    };\n    findMaxDepth(allColumns);\n    let headerGroups = [];\n    const createHeaderGroup = (headersToGroup, depth)=>{\n        // The header group we are creating\n        const headerGroup = {\n            depth,\n            id: [\n                headerFamily,\n                `${depth}`\n            ].filter(Boolean).join(\"_\"),\n            headers: []\n        };\n        // The parent columns we're going to scan next\n        const pendingParentHeaders = [];\n        // Scan each column for parents\n        headersToGroup.forEach((headerToGroup)=>{\n            // What is the latest (last) parent column?\n            const latestPendingParentHeader = [\n                ...pendingParentHeaders\n            ].reverse()[0];\n            const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;\n            let column;\n            let isPlaceholder = false;\n            if (isLeafHeader && headerToGroup.column.parent) {\n                // The parent header is new\n                column = headerToGroup.column.parent;\n            } else {\n                // The parent header is repeated\n                column = headerToGroup.column;\n                isPlaceholder = true;\n            }\n            if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {\n                // This column is repeated. Add it as a sub header to the next batch\n                latestPendingParentHeader.subHeaders.push(headerToGroup);\n            } else {\n                // This is a new header. Let's create it\n                const header = createHeader(table, column, {\n                    id: [\n                        headerFamily,\n                        depth,\n                        column.id,\n                        headerToGroup == null ? void 0 : headerToGroup.id\n                    ].filter(Boolean).join(\"_\"),\n                    isPlaceholder,\n                    placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d)=>d.column === column).length}` : undefined,\n                    depth,\n                    index: pendingParentHeaders.length\n                });\n                // Add the headerToGroup as a subHeader of the new header\n                header.subHeaders.push(headerToGroup);\n                // Add the new header to the pendingParentHeaders to get grouped\n                // in the next batch\n                pendingParentHeaders.push(header);\n            }\n            headerGroup.headers.push(headerToGroup);\n            headerToGroup.headerGroup = headerGroup;\n        });\n        headerGroups.push(headerGroup);\n        if (depth > 0) {\n            createHeaderGroup(pendingParentHeaders, depth - 1);\n        }\n    };\n    const bottomHeaders = columnsToGroup.map((column, index)=>createHeader(table, column, {\n            depth: maxDepth,\n            index\n        }));\n    createHeaderGroup(bottomHeaders, maxDepth - 1);\n    headerGroups.reverse();\n    // headerGroups = headerGroups.filter(headerGroup => {\n    //   return !headerGroup.headers.every(header => header.isPlaceholder)\n    // })\n    const recurseHeadersForSpans = (headers)=>{\n        const filteredHeaders = headers.filter((header)=>header.column.getIsVisible());\n        return filteredHeaders.map((header)=>{\n            let colSpan = 0;\n            let rowSpan = 0;\n            let childRowSpans = [\n                0\n            ];\n            if (header.subHeaders && header.subHeaders.length) {\n                childRowSpans = [];\n                recurseHeadersForSpans(header.subHeaders).forEach((_ref)=>{\n                    let { colSpan: childColSpan, rowSpan: childRowSpan } = _ref;\n                    colSpan += childColSpan;\n                    childRowSpans.push(childRowSpan);\n                });\n            } else {\n                colSpan = 1;\n            }\n            const minChildRowSpan = Math.min(...childRowSpans);\n            rowSpan = rowSpan + minChildRowSpan;\n            header.colSpan = colSpan;\n            header.rowSpan = rowSpan;\n            return {\n                colSpan,\n                rowSpan\n            };\n        });\n    };\n    recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);\n    return headerGroups;\n}\n//\n//\nconst defaultColumnSizing = {\n    size: 150,\n    minSize: 20,\n    maxSize: Number.MAX_SAFE_INTEGER\n};\nconst getDefaultColumnSizingInfoState = ()=>({\n        startOffset: null,\n        startSize: null,\n        deltaOffset: null,\n        deltaPercentage: null,\n        isResizingColumn: false,\n        columnSizingStart: []\n    });\nconst ColumnSizing = {\n    getDefaultColumnDef: ()=>{\n        return defaultColumnSizing;\n    },\n    getInitialState: (state)=>{\n        return {\n            columnSizing: {},\n            columnSizingInfo: getDefaultColumnSizingInfoState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            columnResizeMode: \"onEnd\",\n            columnResizeDirection: \"ltr\",\n            onColumnSizingChange: makeStateUpdater(\"columnSizing\", table),\n            onColumnSizingInfoChange: makeStateUpdater(\"columnSizingInfo\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getSize = ()=>{\n            var _column$columnDef$min, _ref, _column$columnDef$max;\n            const columnSize = table.getState().columnSizing[column.id];\n            return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);\n        };\n        column.getStart = memo((position)=>[\n                position,\n                _getVisibleLeafColumns(table, position),\n                table.getState().columnSizing\n            ], (position, columns)=>columns.slice(0, column.getIndex(position)).reduce((sum, column)=>sum + column.getSize(), 0), getMemoOptions(table.options, \"debugColumns\", \"getStart\"));\n        column.getAfter = memo((position)=>[\n                position,\n                _getVisibleLeafColumns(table, position),\n                table.getState().columnSizing\n            ], (position, columns)=>columns.slice(column.getIndex(position) + 1).reduce((sum, column)=>sum + column.getSize(), 0), getMemoOptions(table.options, \"debugColumns\", \"getAfter\"));\n        column.resetSize = ()=>{\n            table.setColumnSizing((_ref2)=>{\n                let { [column.id]: _, ...rest } = _ref2;\n                return rest;\n            });\n        };\n        column.getCanResize = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);\n        };\n        column.getIsResizing = ()=>{\n            return table.getState().columnSizingInfo.isResizingColumn === column.id;\n        };\n    },\n    createHeader: (header, table)=>{\n        header.getSize = ()=>{\n            let sum = 0;\n            const recurse = (header)=>{\n                if (header.subHeaders.length) {\n                    header.subHeaders.forEach(recurse);\n                } else {\n                    var _header$column$getSiz;\n                    sum += (_header$column$getSiz = header.column.getSize()) != null ? _header$column$getSiz : 0;\n                }\n            };\n            recurse(header);\n            return sum;\n        };\n        header.getStart = ()=>{\n            if (header.index > 0) {\n                const prevSiblingHeader = header.headerGroup.headers[header.index - 1];\n                return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();\n            }\n            return 0;\n        };\n        header.getResizeHandler = (_contextDocument)=>{\n            const column = table.getColumn(header.column.id);\n            const canResize = column == null ? void 0 : column.getCanResize();\n            return (e)=>{\n                if (!column || !canResize) {\n                    return;\n                }\n                e.persist == null || e.persist();\n                if (isTouchStartEvent(e)) {\n                    // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n                    if (e.touches && e.touches.length > 1) {\n                        return;\n                    }\n                }\n                const startSize = header.getSize();\n                const columnSizingStart = header ? header.getLeafHeaders().map((d)=>[\n                        d.column.id,\n                        d.column.getSize()\n                    ]) : [\n                    [\n                        column.id,\n                        column.getSize()\n                    ]\n                ];\n                const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;\n                const newColumnSizing = {};\n                const updateOffset = (eventType, clientXPos)=>{\n                    if (typeof clientXPos !== \"number\") {\n                        return;\n                    }\n                    table.setColumnSizingInfo((old)=>{\n                        var _old$startOffset, _old$startSize;\n                        const deltaDirection = table.options.columnResizeDirection === \"rtl\" ? -1 : 1;\n                        const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;\n                        const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);\n                        old.columnSizingStart.forEach((_ref3)=>{\n                            let [columnId, headerSize] = _ref3;\n                            newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;\n                        });\n                        return {\n                            ...old,\n                            deltaOffset,\n                            deltaPercentage\n                        };\n                    });\n                    if (table.options.columnResizeMode === \"onChange\" || eventType === \"end\") {\n                        table.setColumnSizing((old)=>({\n                                ...old,\n                                ...newColumnSizing\n                            }));\n                    }\n                };\n                const onMove = (clientXPos)=>updateOffset(\"move\", clientXPos);\n                const onEnd = (clientXPos)=>{\n                    updateOffset(\"end\", clientXPos);\n                    table.setColumnSizingInfo((old)=>({\n                            ...old,\n                            isResizingColumn: false,\n                            startOffset: null,\n                            startSize: null,\n                            deltaOffset: null,\n                            deltaPercentage: null,\n                            columnSizingStart: []\n                        }));\n                };\n                const contextDocument = _contextDocument || typeof document !== \"undefined\" ? document : null;\n                const mouseEvents = {\n                    moveHandler: (e)=>onMove(e.clientX),\n                    upHandler: (e)=>{\n                        contextDocument == null || contextDocument.removeEventListener(\"mousemove\", mouseEvents.moveHandler);\n                        contextDocument == null || contextDocument.removeEventListener(\"mouseup\", mouseEvents.upHandler);\n                        onEnd(e.clientX);\n                    }\n                };\n                const touchEvents = {\n                    moveHandler: (e)=>{\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onMove(e.touches[0].clientX);\n                        return false;\n                    },\n                    upHandler: (e)=>{\n                        var _e$touches$;\n                        contextDocument == null || contextDocument.removeEventListener(\"touchmove\", touchEvents.moveHandler);\n                        contextDocument == null || contextDocument.removeEventListener(\"touchend\", touchEvents.upHandler);\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onEnd((_e$touches$ = e.touches[0]) == null ? void 0 : _e$touches$.clientX);\n                    }\n                };\n                const passiveIfSupported = passiveEventSupported() ? {\n                    passive: false\n                } : false;\n                if (isTouchStartEvent(e)) {\n                    contextDocument == null || contextDocument.addEventListener(\"touchmove\", touchEvents.moveHandler, passiveIfSupported);\n                    contextDocument == null || contextDocument.addEventListener(\"touchend\", touchEvents.upHandler, passiveIfSupported);\n                } else {\n                    contextDocument == null || contextDocument.addEventListener(\"mousemove\", mouseEvents.moveHandler, passiveIfSupported);\n                    contextDocument == null || contextDocument.addEventListener(\"mouseup\", mouseEvents.upHandler, passiveIfSupported);\n                }\n                table.setColumnSizingInfo((old)=>({\n                        ...old,\n                        startOffset: clientX,\n                        startSize,\n                        deltaOffset: 0,\n                        deltaPercentage: 0,\n                        columnSizingStart,\n                        isResizingColumn: column.id\n                    }));\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnSizing = (updater)=>table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);\n        table.setColumnSizingInfo = (updater)=>table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);\n        table.resetColumnSizing = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});\n        };\n        table.resetHeaderSizeInfo = (defaultState)=>{\n            var _table$initialState$c2;\n            table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());\n        };\n        table.getTotalSize = ()=>{\n            var _table$getHeaderGroup, _table$getHeaderGroup2;\n            return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getHeaderGroup : 0;\n        };\n        table.getLeftTotalSize = ()=>{\n            var _table$getLeftHeaderG, _table$getLeftHeaderG2;\n            return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getLeftHeaderG : 0;\n        };\n        table.getCenterTotalSize = ()=>{\n            var _table$getCenterHeade, _table$getCenterHeade2;\n            return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getCenterHeade : 0;\n        };\n        table.getRightTotalSize = ()=>{\n            var _table$getRightHeader, _table$getRightHeader2;\n            return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getRightHeader : 0;\n        };\n    }\n};\nlet passiveSupported = null;\nfunction passiveEventSupported() {\n    if (typeof passiveSupported === \"boolean\") return passiveSupported;\n    let supported = false;\n    try {\n        const options = {\n            get passive () {\n                supported = true;\n                return false;\n            }\n        };\n        const noop = ()=>{};\n        window.addEventListener(\"test\", noop, options);\n        window.removeEventListener(\"test\", noop);\n    } catch (err) {\n        supported = false;\n    }\n    passiveSupported = supported;\n    return passiveSupported;\n}\nfunction isTouchStartEvent(e) {\n    return e.type === \"touchstart\";\n}\n//\nconst Expanding = {\n    getInitialState: (state)=>{\n        return {\n            expanded: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onExpandedChange: makeStateUpdater(\"expanded\", table),\n            paginateExpandedRows: true\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetExpanded = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetExpanded();\n                    queued = false;\n                });\n            }\n        };\n        table.setExpanded = (updater)=>table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);\n        table.toggleAllRowsExpanded = (expanded)=>{\n            if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {\n                table.setExpanded(true);\n            } else {\n                table.setExpanded({});\n            }\n        };\n        table.resetExpanded = (defaultState)=>{\n            var _table$initialState$e, _table$initialState;\n            table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});\n        };\n        table.getCanSomeRowsExpand = ()=>{\n            return table.getPrePaginationRowModel().flatRows.some((row)=>row.getCanExpand());\n        };\n        table.getToggleAllRowsExpandedHandler = ()=>{\n            return (e)=>{\n                e.persist == null || e.persist();\n                table.toggleAllRowsExpanded();\n            };\n        };\n        table.getIsSomeRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            return expanded === true || Object.values(expanded).some(Boolean);\n        };\n        table.getIsAllRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            // If expanded is true, save some cycles and return true\n            if (typeof expanded === \"boolean\") {\n                return expanded === true;\n            }\n            if (!Object.keys(expanded).length) {\n                return false;\n            }\n            // If any row is not expanded, return false\n            if (table.getRowModel().flatRows.some((row)=>!row.getIsExpanded())) {\n                return false;\n            }\n            // They must all be expanded :shrug:\n            return true;\n        };\n        table.getExpandedDepth = ()=>{\n            let maxDepth = 0;\n            const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);\n            rowIds.forEach((id)=>{\n                const splitId = id.split(\".\");\n                maxDepth = Math.max(maxDepth, splitId.length);\n            });\n            return maxDepth;\n        };\n        table.getPreExpandedRowModel = ()=>table.getSortedRowModel();\n        table.getExpandedRowModel = ()=>{\n            if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {\n                table._getExpandedRowModel = table.options.getExpandedRowModel(table);\n            }\n            if (table.options.manualExpanding || !table._getExpandedRowModel) {\n                return table.getPreExpandedRowModel();\n            }\n            return table._getExpandedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleExpanded = (expanded)=>{\n            table.setExpanded((old)=>{\n                var _expanded;\n                const exists = old === true ? true : !!(old != null && old[row.id]);\n                let oldExpanded = {};\n                if (old === true) {\n                    Object.keys(table.getRowModel().rowsById).forEach((rowId)=>{\n                        oldExpanded[rowId] = true;\n                    });\n                } else {\n                    oldExpanded = old;\n                }\n                expanded = (_expanded = expanded) != null ? _expanded : !exists;\n                if (!exists && expanded) {\n                    return {\n                        ...oldExpanded,\n                        [row.id]: true\n                    };\n                }\n                if (exists && !expanded) {\n                    const { [row.id]: _, ...rest } = oldExpanded;\n                    return rest;\n                }\n                return old;\n            });\n        };\n        row.getIsExpanded = ()=>{\n            var _table$options$getIsR;\n            const expanded = table.getState().expanded;\n            return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));\n        };\n        row.getCanExpand = ()=>{\n            var _table$options$getRow, _table$options$enable, _row$subRows;\n            return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n        row.getIsAllParentsExpanded = ()=>{\n            let isFullyExpanded = true;\n            let currentRow = row;\n            while(isFullyExpanded && currentRow.parentId){\n                currentRow = table.getRow(currentRow.parentId, true);\n                isFullyExpanded = currentRow.getIsExpanded();\n            }\n            return isFullyExpanded;\n        };\n        row.getToggleExpandedHandler = ()=>{\n            const canExpand = row.getCanExpand();\n            return ()=>{\n                if (!canExpand) return;\n                row.toggleExpanded();\n            };\n        };\n    }\n};\nconst includesString = (row, columnId, filterValue)=>{\n    var _row$getValue;\n    const search = filterValue.toLowerCase();\n    return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));\n};\nincludesString.autoRemove = (val)=>testFalsey(val);\nconst includesStringSensitive = (row, columnId, filterValue)=>{\n    var _row$getValue2;\n    return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));\n};\nincludesStringSensitive.autoRemove = (val)=>testFalsey(val);\nconst equalsString = (row, columnId, filterValue)=>{\n    var _row$getValue3;\n    return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());\n};\nequalsString.autoRemove = (val)=>testFalsey(val);\nconst arrIncludes = (row, columnId, filterValue)=>{\n    var _row$getValue4;\n    return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);\n};\narrIncludes.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst arrIncludesAll = (row, columnId, filterValue)=>{\n    return !filterValue.some((val)=>{\n        var _row$getValue5;\n        return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));\n    });\n};\narrIncludesAll.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst arrIncludesSome = (row, columnId, filterValue)=>{\n    return filterValue.some((val)=>{\n        var _row$getValue6;\n        return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);\n    });\n};\narrIncludesSome.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst equals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) === filterValue;\n};\nequals.autoRemove = (val)=>testFalsey(val);\nconst weakEquals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) == filterValue;\n};\nweakEquals.autoRemove = (val)=>testFalsey(val);\nconst inNumberRange = (row, columnId, filterValue)=>{\n    let [min, max] = filterValue;\n    const rowValue = row.getValue(columnId);\n    return rowValue >= min && rowValue <= max;\n};\ninNumberRange.resolveFilterValue = (val)=>{\n    let [unsafeMin, unsafeMax] = val;\n    let parsedMin = typeof unsafeMin !== \"number\" ? parseFloat(unsafeMin) : unsafeMin;\n    let parsedMax = typeof unsafeMax !== \"number\" ? parseFloat(unsafeMax) : unsafeMax;\n    let min = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;\n    let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;\n    if (min > max) {\n        const temp = min;\n        min = max;\n        max = temp;\n    }\n    return [\n        min,\n        max\n    ];\n};\ninNumberRange.autoRemove = (val)=>testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);\n// Export\nconst filterFns = {\n    includesString,\n    includesStringSensitive,\n    equalsString,\n    arrIncludes,\n    arrIncludesAll,\n    arrIncludesSome,\n    equals,\n    weakEquals,\n    inNumberRange\n};\n// Utils\nfunction testFalsey(val) {\n    return val === undefined || val === null || val === \"\";\n}\n//\nconst Filters = {\n    getDefaultColumnDef: ()=>{\n        return {\n            filterFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            columnFilters: [],\n            globalFilter: undefined,\n            // filtersProgress: 1,\n            // facetProgress: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnFiltersChange: makeStateUpdater(\"columnFilters\", table),\n            onGlobalFilterChange: makeStateUpdater(\"globalFilter\", table),\n            filterFromLeafRows: false,\n            maxLeafRowFilterDepth: 100,\n            globalFilterFn: \"auto\",\n            getColumnCanGlobalFilter: (column)=>{\n                var _table$getCoreRowMode;\n                const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();\n                return typeof value === \"string\" || typeof value === \"number\";\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoFilterFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return filterFns.includesString;\n            }\n            if (typeof value === \"number\") {\n                return filterFns.inNumberRange;\n            }\n            if (typeof value === \"boolean\") {\n                return filterFns.equals;\n            }\n            if (value !== null && typeof value === \"object\") {\n                return filterFns.equals;\n            }\n            if (Array.isArray(value)) {\n                return filterFns.arrIncludes;\n            }\n            return filterFns.weakEquals;\n        };\n        column.getFilterFn = ()=>{\n            var _table$options$filter, _table$options$filter2;\n            return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === \"auto\" ? column.getAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn];\n        };\n        column.getCanFilter = ()=>{\n            var _column$columnDef$ena, _table$options$enable, _table$options$enable2;\n            return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;\n        };\n        column.getCanGlobalFilter = ()=>{\n            var _column$columnDef$ena2, _table$options$enable3, _table$options$enable4, _table$options$getCol;\n            return ((_column$columnDef$ena2 = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena2 : true) && ((_table$options$enable3 = table.options.enableGlobalFilter) != null ? _table$options$enable3 : true) && ((_table$options$enable4 = table.options.enableFilters) != null ? _table$options$enable4 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;\n        };\n        column.getIsFiltered = ()=>column.getFilterIndex() > -1;\n        column.getFilterValue = ()=>{\n            var _table$getState$colum;\n            return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d)=>d.id === column.id)) == null ? void 0 : _table$getState$colum.value;\n        };\n        column.getFilterIndex = ()=>{\n            var _table$getState$colum2, _table$getState$colum3;\n            return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$colum2 : -1;\n        };\n        column.setFilterValue = (value)=>{\n            table.setColumnFilters((old)=>{\n                const filterFn = column.getFilterFn();\n                const previousfilter = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const newFilter = functionalUpdate(value, previousfilter ? previousfilter.value : undefined);\n                //\n                if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {\n                    var _old$filter;\n                    return (_old$filter = old == null ? void 0 : old.filter((d)=>d.id !== column.id)) != null ? _old$filter : [];\n                }\n                const newFilterObj = {\n                    id: column.id,\n                    value: newFilter\n                };\n                if (previousfilter) {\n                    var _old$map;\n                    return (_old$map = old == null ? void 0 : old.map((d)=>{\n                        if (d.id === column.id) {\n                            return newFilterObj;\n                        }\n                        return d;\n                    })) != null ? _old$map : [];\n                }\n                if (old != null && old.length) {\n                    return [\n                        ...old,\n                        newFilterObj\n                    ];\n                }\n                return [\n                    newFilterObj\n                ];\n            });\n        };\n        column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);\n        column.getFacetedRowModel = ()=>{\n            if (!column._getFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return column._getFacetedRowModel();\n        };\n        column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);\n        column.getFacetedUniqueValues = ()=>{\n            if (!column._getFacetedUniqueValues) {\n                return new Map();\n            }\n            return column._getFacetedUniqueValues();\n        };\n        column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);\n        column.getFacetedMinMaxValues = ()=>{\n            if (!column._getFacetedMinMaxValues) {\n                return undefined;\n            }\n            return column._getFacetedMinMaxValues();\n        };\n    // () => [column.getFacetedRowModel()],\n    // facetedRowModel => getRowModelMinMaxValues(facetedRowModel, column.id),\n    },\n    createRow: (row, table)=>{\n        row.columnFilters = {};\n        row.columnFiltersMeta = {};\n    },\n    createTable: (table)=>{\n        table.getGlobalAutoFilterFn = ()=>{\n            return filterFns.includesString;\n        };\n        table.getGlobalFilterFn = ()=>{\n            var _table$options$filter3, _table$options$filter4;\n            const { globalFilterFn: globalFilterFn } = table.options;\n            return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === \"auto\" ? table.getGlobalAutoFilterFn() : (_table$options$filter3 = (_table$options$filter4 = table.options.filterFns) == null ? void 0 : _table$options$filter4[globalFilterFn]) != null ? _table$options$filter3 : filterFns[globalFilterFn];\n        };\n        table.setColumnFilters = (updater)=>{\n            const leafColumns = table.getAllLeafColumns();\n            const updateFn = (old)=>{\n                var _functionalUpdate;\n                return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter)=>{\n                    const column = leafColumns.find((d)=>d.id === filter.id);\n                    if (column) {\n                        const filterFn = column.getFilterFn();\n                        if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n            };\n            table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);\n        };\n        table.setGlobalFilter = (updater)=>{\n            table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);\n        };\n        table.resetGlobalFilter = (defaultState)=>{\n            table.setGlobalFilter(defaultState ? undefined : table.initialState.globalFilter);\n        };\n        table.resetColumnFilters = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);\n        };\n        table.getPreFilteredRowModel = ()=>table.getCoreRowModel();\n        table.getFilteredRowModel = ()=>{\n            if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {\n                table._getFilteredRowModel = table.options.getFilteredRowModel(table);\n            }\n            if (table.options.manualFiltering || !table._getFilteredRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getFilteredRowModel();\n        };\n        table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, \"__global__\");\n        table.getGlobalFacetedRowModel = ()=>{\n            if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getGlobalFacetedRowModel();\n        };\n        table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, \"__global__\");\n        table.getGlobalFacetedUniqueValues = ()=>{\n            if (!table._getGlobalFacetedUniqueValues) {\n                return new Map();\n            }\n            return table._getGlobalFacetedUniqueValues();\n        };\n        table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, \"__global__\");\n        table.getGlobalFacetedMinMaxValues = ()=>{\n            if (!table._getGlobalFacetedMinMaxValues) {\n                return;\n            }\n            return table._getGlobalFacetedMinMaxValues();\n        };\n    }\n};\nfunction shouldAutoRemoveFilter(filterFn, value, column) {\n    return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === \"undefined\" || typeof value === \"string\" && !value;\n}\nconst sum = (columnId, _leafRows, childRows)=>{\n    // It's faster to just add the aggregations together instead of\n    // process leaf nodes individually\n    return childRows.reduce((sum, next)=>{\n        const nextValue = next.getValue(columnId);\n        return sum + (typeof nextValue === \"number\" ? nextValue : 0);\n    }, 0);\n};\nconst min = (columnId, _leafRows, childRows)=>{\n    let min;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (min > value || min === undefined && value >= value)) {\n            min = value;\n        }\n    });\n    return min;\n};\nconst max = (columnId, _leafRows, childRows)=>{\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (max < value || max === undefined && value >= value)) {\n            max = value;\n        }\n    });\n    return max;\n};\nconst extent = (columnId, _leafRows, childRows)=>{\n    let min;\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null) {\n            if (min === undefined) {\n                if (value >= value) min = max = value;\n            } else {\n                if (min > value) min = value;\n                if (max < value) max = value;\n            }\n        }\n    });\n    return [\n        min,\n        max\n    ];\n};\nconst mean = (columnId, leafRows)=>{\n    let count = 0;\n    let sum = 0;\n    leafRows.forEach((row)=>{\n        let value = row.getValue(columnId);\n        if (value != null && (value = +value) >= value) {\n            ++count, sum += value;\n        }\n    });\n    if (count) return sum / count;\n    return;\n};\nconst median = (columnId, leafRows)=>{\n    if (!leafRows.length) {\n        return;\n    }\n    const values = leafRows.map((row)=>row.getValue(columnId));\n    if (!isNumberArray(values)) {\n        return;\n    }\n    if (values.length === 1) {\n        return values[0];\n    }\n    const mid = Math.floor(values.length / 2);\n    const nums = values.sort((a, b)=>a - b);\n    return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n};\nconst unique = (columnId, leafRows)=>{\n    return Array.from(new Set(leafRows.map((d)=>d.getValue(columnId))).values());\n};\nconst uniqueCount = (columnId, leafRows)=>{\n    return new Set(leafRows.map((d)=>d.getValue(columnId))).size;\n};\nconst count = (_columnId, leafRows)=>{\n    return leafRows.length;\n};\nconst aggregationFns = {\n    sum,\n    min,\n    max,\n    extent,\n    mean,\n    median,\n    unique,\n    uniqueCount,\n    count\n};\n//\nconst Grouping = {\n    getDefaultColumnDef: ()=>{\n        return {\n            aggregatedCell: (props)=>{\n                var _toString, _props$getValue;\n                return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;\n            },\n            aggregationFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            grouping: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onGroupingChange: makeStateUpdater(\"grouping\", table),\n            groupedColumnMode: \"reorder\"\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleGrouping = ()=>{\n            table.setGrouping((old)=>{\n                // Find any existing grouping for this column\n                if (old != null && old.includes(column.id)) {\n                    return old.filter((d)=>d !== column.id);\n                }\n                return [\n                    ...old != null ? old : [],\n                    column.id\n                ];\n            });\n        };\n        column.getCanGroup = ()=>{\n            var _ref, _ref2, _ref3, _column$columnDef$ena;\n            return (_ref = (_ref2 = (_ref3 = (_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) != null ? _ref3 : table.options.enableGrouping) != null ? _ref2 : true) != null ? _ref : !!column.accessorFn;\n        };\n        column.getIsGrouped = ()=>{\n            var _table$getState$group;\n            return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);\n        };\n        column.getGroupedIndex = ()=>{\n            var _table$getState$group2;\n            return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);\n        };\n        column.getToggleGroupingHandler = ()=>{\n            const canGroup = column.getCanGroup();\n            return ()=>{\n                if (!canGroup) return;\n                column.toggleGrouping();\n            };\n        };\n        column.getAutoAggregationFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"number\") {\n                return aggregationFns.sum;\n            }\n            if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                return aggregationFns.extent;\n            }\n        };\n        column.getAggregationFn = ()=>{\n            var _table$options$aggreg, _table$options$aggreg2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === \"auto\" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];\n        };\n    },\n    createTable: (table)=>{\n        table.setGrouping = (updater)=>table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);\n        table.resetGrouping = (defaultState)=>{\n            var _table$initialState$g, _table$initialState;\n            table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);\n        };\n        table.getPreGroupedRowModel = ()=>table.getFilteredRowModel();\n        table.getGroupedRowModel = ()=>{\n            if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {\n                table._getGroupedRowModel = table.options.getGroupedRowModel(table);\n            }\n            if (table.options.manualGrouping || !table._getGroupedRowModel) {\n                return table.getPreGroupedRowModel();\n            }\n            return table._getGroupedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.getIsGrouped = ()=>!!row.groupingColumnId;\n        row.getGroupingValue = (columnId)=>{\n            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                return row._groupingValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.columnDef.getGroupingValue)) {\n                return row.getValue(columnId);\n            }\n            row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);\n            return row._groupingValuesCache[columnId];\n        };\n        row._groupingValuesCache = {};\n    },\n    createCell: (cell, column, row, table)=>{\n        cell.getIsGrouped = ()=>column.getIsGrouped() && column.id === row.groupingColumnId;\n        cell.getIsPlaceholder = ()=>!cell.getIsGrouped() && column.getIsGrouped();\n        cell.getIsAggregated = ()=>{\n            var _row$subRows;\n            return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n    }\n};\nfunction orderColumns(leafColumns, grouping, groupedColumnMode) {\n    if (!(grouping != null && grouping.length) || !groupedColumnMode) {\n        return leafColumns;\n    }\n    const nonGroupingColumns = leafColumns.filter((col)=>!grouping.includes(col.id));\n    if (groupedColumnMode === \"remove\") {\n        return nonGroupingColumns;\n    }\n    const groupingColumns = grouping.map((g)=>leafColumns.find((col)=>col.id === g)).filter(Boolean);\n    return [\n        ...groupingColumns,\n        ...nonGroupingColumns\n    ];\n}\n//\nconst Ordering = {\n    getInitialState: (state)=>{\n        return {\n            columnOrder: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnOrderChange: makeStateUpdater(\"columnOrder\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getIndex = memo((position)=>[\n                _getVisibleLeafColumns(table, position)\n            ], (columns)=>columns.findIndex((d)=>d.id === column.id), getMemoOptions(table.options, \"debugColumns\", \"getIndex\"));\n        column.getIsFirstColumn = (position)=>{\n            var _columns$;\n            const columns = _getVisibleLeafColumns(table, position);\n            return ((_columns$ = columns[0]) == null ? void 0 : _columns$.id) === column.id;\n        };\n        column.getIsLastColumn = (position)=>{\n            var _columns;\n            const columns = _getVisibleLeafColumns(table, position);\n            return ((_columns = columns[columns.length - 1]) == null ? void 0 : _columns.id) === column.id;\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnOrder = (updater)=>table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);\n        table.resetColumnOrder = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);\n        };\n        table._getOrderColumnsFn = memo(()=>[\n                table.getState().columnOrder,\n                table.getState().grouping,\n                table.options.groupedColumnMode\n            ], (columnOrder, grouping, groupedColumnMode)=>(columns)=>{\n                // Sort grouped columns to the start of the column list\n                // before the headers are built\n                let orderedColumns = [];\n                // If there is no order, return the normal columns\n                if (!(columnOrder != null && columnOrder.length)) {\n                    orderedColumns = columns;\n                } else {\n                    const columnOrderCopy = [\n                        ...columnOrder\n                    ];\n                    // If there is an order, make a copy of the columns\n                    const columnsCopy = [\n                        ...columns\n                    ];\n                    // And make a new ordered array of the columns\n                    // Loop over the columns and place them in order into the new array\n                    while(columnsCopy.length && columnOrderCopy.length){\n                        const targetColumnId = columnOrderCopy.shift();\n                        const foundIndex = columnsCopy.findIndex((d)=>d.id === targetColumnId);\n                        if (foundIndex > -1) {\n                            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);\n                        }\n                    }\n                    // If there are any columns left, add them to the end\n                    orderedColumns = [\n                        ...orderedColumns,\n                        ...columnsCopy\n                    ];\n                }\n                return orderColumns(orderedColumns, grouping, groupedColumnMode);\n            }, getMemoOptions(table.options, \"debugTable\", \"_getOrderColumnsFn\"));\n    }\n};\n//\nconst defaultPageIndex = 0;\nconst defaultPageSize = 10;\nconst getDefaultPaginationState = ()=>({\n        pageIndex: defaultPageIndex,\n        pageSize: defaultPageSize\n    });\nconst Pagination = {\n    getInitialState: (state)=>{\n        return {\n            ...state,\n            pagination: {\n                ...getDefaultPaginationState(),\n                ...state == null ? void 0 : state.pagination\n            }\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onPaginationChange: makeStateUpdater(\"pagination\", table)\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetPageIndex = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetPageIndex();\n                    queued = false;\n                });\n            }\n        };\n        table.setPagination = (updater)=>{\n            const safeUpdater = (old)=>{\n                let newState = functionalUpdate(updater, old);\n                return newState;\n            };\n            return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);\n        };\n        table.resetPagination = (defaultState)=>{\n            var _table$initialState$p;\n            table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());\n        };\n        table.setPageIndex = (updater)=>{\n            table.setPagination((old)=>{\n                let pageIndex = functionalUpdate(updater, old.pageIndex);\n                const maxPageIndex = typeof table.options.pageCount === \"undefined\" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;\n                pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));\n                return {\n                    ...old,\n                    pageIndex\n                };\n            });\n        };\n        table.resetPageIndex = (defaultState)=>{\n            var _table$initialState$p2, _table$initialState;\n            table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);\n        };\n        table.resetPageSize = (defaultState)=>{\n            var _table$initialState$p3, _table$initialState2;\n            table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);\n        };\n        table.setPageSize = (updater)=>{\n            table.setPagination((old)=>{\n                const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));\n                const topRowIndex = old.pageSize * old.pageIndex;\n                const pageIndex = Math.floor(topRowIndex / pageSize);\n                return {\n                    ...old,\n                    pageIndex,\n                    pageSize\n                };\n            });\n        };\n        //deprecated\n        table.setPageCount = (updater)=>table.setPagination((old)=>{\n                var _table$options$pageCo;\n                let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);\n                if (typeof newPageCount === \"number\") {\n                    newPageCount = Math.max(-1, newPageCount);\n                }\n                return {\n                    ...old,\n                    pageCount: newPageCount\n                };\n            });\n        table.getPageOptions = memo(()=>[\n                table.getPageCount()\n            ], (pageCount)=>{\n            let pageOptions = [];\n            if (pageCount && pageCount > 0) {\n                pageOptions = [\n                    ...new Array(pageCount)\n                ].fill(null).map((_, i)=>i);\n            }\n            return pageOptions;\n        }, getMemoOptions(table.options, \"debugTable\", \"getPageOptions\"));\n        table.getCanPreviousPage = ()=>table.getState().pagination.pageIndex > 0;\n        table.getCanNextPage = ()=>{\n            const { pageIndex } = table.getState().pagination;\n            const pageCount = table.getPageCount();\n            if (pageCount === -1) {\n                return true;\n            }\n            if (pageCount === 0) {\n                return false;\n            }\n            return pageIndex < pageCount - 1;\n        };\n        table.previousPage = ()=>{\n            return table.setPageIndex((old)=>old - 1);\n        };\n        table.nextPage = ()=>{\n            return table.setPageIndex((old)=>{\n                return old + 1;\n            });\n        };\n        table.firstPage = ()=>{\n            return table.setPageIndex(0);\n        };\n        table.lastPage = ()=>{\n            return table.setPageIndex(table.getPageCount() - 1);\n        };\n        table.getPrePaginationRowModel = ()=>table.getExpandedRowModel();\n        table.getPaginationRowModel = ()=>{\n            if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {\n                table._getPaginationRowModel = table.options.getPaginationRowModel(table);\n            }\n            if (table.options.manualPagination || !table._getPaginationRowModel) {\n                return table.getPrePaginationRowModel();\n            }\n            return table._getPaginationRowModel();\n        };\n        table.getPageCount = ()=>{\n            var _table$options$pageCo2;\n            return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);\n        };\n        table.getRowCount = ()=>{\n            var _table$options$rowCou;\n            return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;\n        };\n    }\n};\n//\nconst getDefaultColumnPinningState = ()=>({\n        left: [],\n        right: []\n    });\nconst getDefaultRowPinningState = ()=>({\n        top: [],\n        bottom: []\n    });\nconst Pinning = {\n    getInitialState: (state)=>{\n        return {\n            columnPinning: getDefaultColumnPinningState(),\n            rowPinning: getDefaultRowPinningState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnPinningChange: makeStateUpdater(\"columnPinning\", table),\n            onRowPinningChange: makeStateUpdater(\"rowPinning\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.pin = (position)=>{\n            const columnIds = column.getLeafColumns().map((d)=>d.id).filter(Boolean);\n            table.setColumnPinning((old)=>{\n                var _old$left3, _old$right3;\n                if (position === \"right\") {\n                    var _old$left, _old$right;\n                    return {\n                        left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                        right: [\n                            ...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ]\n                    };\n                }\n                if (position === \"left\") {\n                    var _old$left2, _old$right2;\n                    return {\n                        left: [\n                            ...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ],\n                        right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                    };\n                }\n                return {\n                    left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                    right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                };\n            });\n        };\n        column.getCanPin = ()=>{\n            const leafColumns = column.getLeafColumns();\n            return leafColumns.some((d)=>{\n                var _d$columnDef$enablePi, _ref, _table$options$enable;\n                return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);\n            });\n        };\n        column.getIsPinned = ()=>{\n            const leafColumnIds = column.getLeafColumns().map((d)=>d.id);\n            const { left, right } = table.getState().columnPinning;\n            const isLeft = leafColumnIds.some((d)=>left == null ? void 0 : left.includes(d));\n            const isRight = leafColumnIds.some((d)=>right == null ? void 0 : right.includes(d));\n            return isLeft ? \"left\" : isRight ? \"right\" : false;\n        };\n        column.getPinnedIndex = ()=>{\n            var _table$getState$colum, _table$getState$colum2;\n            const position = column.getIsPinned();\n            return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;\n        };\n    },\n    createRow: (row, table)=>{\n        row.pin = (position, includeLeafRows, includeParentRows)=>{\n            const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref2)=>{\n                let { id } = _ref2;\n                return id;\n            }) : [];\n            const parentRowIds = includeParentRows ? row.getParentRows().map((_ref3)=>{\n                let { id } = _ref3;\n                return id;\n            }) : [];\n            const rowIds = new Set([\n                ...parentRowIds,\n                row.id,\n                ...leafRowIds\n            ]);\n            table.setRowPinning((old)=>{\n                var _old$top3, _old$bottom3;\n                if (position === \"bottom\") {\n                    var _old$top, _old$bottom;\n                    return {\n                        top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                        bottom: [\n                            ...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ]\n                    };\n                }\n                if (position === \"top\") {\n                    var _old$top2, _old$bottom2;\n                    return {\n                        top: [\n                            ...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ],\n                        bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                    };\n                }\n                return {\n                    top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                    bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                };\n            });\n        };\n        row.getCanPin = ()=>{\n            var _ref4;\n            const { enableRowPinning, enablePinning } = table.options;\n            if (typeof enableRowPinning === \"function\") {\n                return enableRowPinning(row);\n            }\n            return (_ref4 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref4 : true;\n        };\n        row.getIsPinned = ()=>{\n            const rowIds = [\n                row.id\n            ];\n            const { top, bottom } = table.getState().rowPinning;\n            const isTop = rowIds.some((d)=>top == null ? void 0 : top.includes(d));\n            const isBottom = rowIds.some((d)=>bottom == null ? void 0 : bottom.includes(d));\n            return isTop ? \"top\" : isBottom ? \"bottom\" : false;\n        };\n        row.getPinnedIndex = ()=>{\n            var _table$_getPinnedRows, _visiblePinnedRowIds$;\n            const position = row.getIsPinned();\n            if (!position) return -1;\n            const visiblePinnedRowIds = (_table$_getPinnedRows = table._getPinnedRows(position)) == null ? void 0 : _table$_getPinnedRows.map((_ref5)=>{\n                let { id } = _ref5;\n                return id;\n            });\n            return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;\n        };\n        row.getCenterVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allCells, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allCells.filter((d)=>!leftAndRight.includes(d.column.id));\n        }, getMemoOptions(table.options, \"debugRows\", \"getCenterVisibleCells\"));\n        row.getLeftVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left\n            ], (allCells, left)=>{\n            const cells = (left != null ? left : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"left\"\n                }));\n            return cells;\n        }, getMemoOptions(table.options, \"debugRows\", \"getLeftVisibleCells\"));\n        row.getRightVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.right\n            ], (allCells, right)=>{\n            const cells = (right != null ? right : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"right\"\n                }));\n            return cells;\n        }, getMemoOptions(table.options, \"debugRows\", \"getRightVisibleCells\"));\n    },\n    createTable: (table)=>{\n        table.setColumnPinning = (updater)=>table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);\n        table.resetColumnPinning = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());\n        };\n        table.getIsSomeColumnsPinned = (position)=>{\n            var _pinningState$positio;\n            const pinningState = table.getState().columnPinning;\n            if (!position) {\n                var _pinningState$left, _pinningState$right;\n                return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));\n            }\n            return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n        };\n        table.getLeftLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, left)=>{\n            return (left != null ? left : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, getMemoOptions(table.options, \"debugColumns\", \"getLeftLeafColumns\"));\n        table.getRightLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, right)=>{\n            return (right != null ? right : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, getMemoOptions(table.options, \"debugColumns\", \"getRightLeafColumns\"));\n        table.getCenterLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allColumns.filter((d)=>!leftAndRight.includes(d.id));\n        }, getMemoOptions(table.options, \"debugColumns\", \"getCenterLeafColumns\"));\n        table.setRowPinning = (updater)=>table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);\n        table.resetRowPinning = (defaultState)=>{\n            var _table$initialState$r, _table$initialState2;\n            return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState2 = table.initialState) == null ? void 0 : _table$initialState2.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());\n        };\n        table.getIsSomeRowsPinned = (position)=>{\n            var _pinningState$positio2;\n            const pinningState = table.getState().rowPinning;\n            if (!position) {\n                var _pinningState$top, _pinningState$bottom;\n                return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));\n            }\n            return Boolean((_pinningState$positio2 = pinningState[position]) == null ? void 0 : _pinningState$positio2.length);\n        };\n        table._getPinnedRows = memo((position)=>[\n                table.getRowModel().rows,\n                table.getState().rowPinning[position],\n                position\n            ], (visibleRows, pinnedRowIds, position)=>{\n            var _table$options$keepPi;\n            const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? //get all rows that are pinned even if they would not be otherwise visible\n            //account for expanded parent rows, but not pagination or filtering\n            (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>{\n                const row = table.getRow(rowId, true);\n                return row.getIsAllParentsExpanded() ? row : null;\n            }) : //else get only visible rows that are pinned\n            (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>visibleRows.find((row)=>row.id === rowId));\n            return rows.filter(Boolean).map((d)=>({\n                    ...d,\n                    position\n                }));\n        }, getMemoOptions(table.options, \"debugRows\", \"_getPinnedRows\"));\n        table.getTopRows = ()=>table._getPinnedRows(\"top\");\n        table.getBottomRows = ()=>table._getPinnedRows(\"bottom\");\n        table.getCenterRows = memo(()=>[\n                table.getRowModel().rows,\n                table.getState().rowPinning.top,\n                table.getState().rowPinning.bottom\n            ], (allRows, top, bottom)=>{\n            const topAndBottom = new Set([\n                ...top != null ? top : [],\n                ...bottom != null ? bottom : []\n            ]);\n            return allRows.filter((d)=>!topAndBottom.has(d.id));\n        }, getMemoOptions(table.options, \"debugRows\", \"getCenterRows\"));\n    }\n};\n//\nconst RowSelection = {\n    getInitialState: (state)=>{\n        return {\n            rowSelection: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onRowSelectionChange: makeStateUpdater(\"rowSelection\", table),\n            enableRowSelection: true,\n            enableMultiRowSelection: true,\n            enableSubRowSelection: true\n        };\n    },\n    createTable: (table)=>{\n        table.setRowSelection = (updater)=>table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);\n        table.resetRowSelection = (defaultState)=>{\n            var _table$initialState$r;\n            return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});\n        };\n        table.toggleAllRowsSelected = (value)=>{\n            table.setRowSelection((old)=>{\n                value = typeof value !== \"undefined\" ? value : !table.getIsAllRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;\n                // We don't use `mutateRowIsSelected` here for performance reasons.\n                // All of the rows are flat already, so it wouldn't be worth it\n                if (value) {\n                    preGroupedFlatRows.forEach((row)=>{\n                        if (!row.getCanSelect()) {\n                            return;\n                        }\n                        rowSelection[row.id] = true;\n                    });\n                } else {\n                    preGroupedFlatRows.forEach((row)=>{\n                        delete rowSelection[row.id];\n                    });\n                }\n                return rowSelection;\n            });\n        };\n        table.toggleAllPageRowsSelected = (value)=>table.setRowSelection((old)=>{\n                const resolvedValue = typeof value !== \"undefined\" ? value : !table.getIsAllPageRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                table.getRowModel().rows.forEach((row)=>{\n                    mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);\n                });\n                return rowSelection;\n            });\n        // addRowSelectionRange: rowId => {\n        //   const {\n        //     rows,\n        //     rowsById,\n        //     options: { selectGroupingRows, selectSubRows },\n        //   } = table\n        //   const findSelectedRow = (rows: Row[]) => {\n        //     let found\n        //     rows.find(d => {\n        //       if (d.getIsSelected()) {\n        //         found = d\n        //         return true\n        //       }\n        //       const subFound = findSelectedRow(d.subRows || [])\n        //       if (subFound) {\n        //         found = subFound\n        //         return true\n        //       }\n        //       return false\n        //     })\n        //     return found\n        //   }\n        //   const firstRow = findSelectedRow(rows) || rows[0]\n        //   const lastRow = rowsById[rowId]\n        //   let include = false\n        //   const selectedRowIds = {}\n        //   const addRow = (row: Row) => {\n        //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n        //       rowsById,\n        //       selectGroupingRows: selectGroupingRows!,\n        //       selectSubRows: selectSubRows!,\n        //     })\n        //   }\n        //   table.rows.forEach(row => {\n        //     const isFirstRow = row.id === firstRow.id\n        //     const isLastRow = row.id === lastRow.id\n        //     if (isFirstRow || isLastRow) {\n        //       if (!include) {\n        //         include = true\n        //       } else if (include) {\n        //         addRow(row)\n        //         include = false\n        //       }\n        //     }\n        //     if (include) {\n        //       addRow(row)\n        //     }\n        //   })\n        //   table.setRowSelection(selectedRowIds)\n        // },\n        table.getPreSelectedRowModel = ()=>table.getCoreRowModel();\n        table.getSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getCoreRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getSelectedRowModel\"));\n        table.getFilteredSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getFilteredRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getFilteredSelectedRowModel\"));\n        table.getGroupedSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getSortedRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getGroupedSelectedRowModel\"));\n        ///\n        // getGroupingRowCanSelect: rowId => {\n        //   const row = table.getRow(rowId)\n        //   if (!row) {\n        //     throw new Error()\n        //   }\n        //   if (typeof table.options.enableGroupingRowSelection === 'function') {\n        //     return table.options.enableGroupingRowSelection(row)\n        //   }\n        //   return table.options.enableGroupingRowSelection ?? false\n        // },\n        table.getIsAllRowsSelected = ()=>{\n            const preGroupedFlatRows = table.getFilteredRowModel().flatRows;\n            const { rowSelection } = table.getState();\n            let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);\n            if (isAllRowsSelected) {\n                if (preGroupedFlatRows.some((row)=>row.getCanSelect() && !rowSelection[row.id])) {\n                    isAllRowsSelected = false;\n                }\n            }\n            return isAllRowsSelected;\n        };\n        table.getIsAllPageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row)=>row.getCanSelect());\n            const { rowSelection } = table.getState();\n            let isAllPageRowsSelected = !!paginationFlatRows.length;\n            if (isAllPageRowsSelected && paginationFlatRows.some((row)=>!rowSelection[row.id])) {\n                isAllPageRowsSelected = false;\n            }\n            return isAllPageRowsSelected;\n        };\n        table.getIsSomeRowsSelected = ()=>{\n            var _table$getState$rowSe;\n            const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;\n            return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;\n        };\n        table.getIsSomePageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows;\n            return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row)=>row.getCanSelect()).some((d)=>d.getIsSelected() || d.getIsSomeSelected());\n        };\n        table.getToggleAllRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllRowsSelected(e.target.checked);\n            };\n        };\n        table.getToggleAllPageRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllPageRowsSelected(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleSelected = (value, opts)=>{\n            const isSelected = row.getIsSelected();\n            table.setRowSelection((old)=>{\n                var _opts$selectChildren;\n                value = typeof value !== \"undefined\" ? value : !isSelected;\n                if (row.getCanSelect() && isSelected === value) {\n                    return old;\n                }\n                const selectedRowIds = {\n                    ...old\n                };\n                mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);\n                return selectedRowIds;\n            });\n        };\n        row.getIsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isRowSelected(row, rowSelection);\n        };\n        row.getIsSomeSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"some\";\n        };\n        row.getIsAllSubRowsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"all\";\n        };\n        row.getCanSelect = ()=>{\n            var _table$options$enable;\n            if (typeof table.options.enableRowSelection === \"function\") {\n                return table.options.enableRowSelection(row);\n            }\n            return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;\n        };\n        row.getCanSelectSubRows = ()=>{\n            var _table$options$enable2;\n            if (typeof table.options.enableSubRowSelection === \"function\") {\n                return table.options.enableSubRowSelection(row);\n            }\n            return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;\n        };\n        row.getCanMultiSelect = ()=>{\n            var _table$options$enable3;\n            if (typeof table.options.enableMultiRowSelection === \"function\") {\n                return table.options.enableMultiRowSelection(row);\n            }\n            return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;\n        };\n        row.getToggleSelectedHandler = ()=>{\n            const canSelect = row.getCanSelect();\n            return (e)=>{\n                var _target;\n                if (!canSelect) return;\n                row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nconst mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table)=>{\n    var _row$subRows;\n    const row = table.getRow(id, true);\n    // const isGrouped = row.getIsGrouped()\n    // if ( // TODO: enforce grouping row selection rules\n    //   !isGrouped ||\n    //   (isGrouped && table.options.enableGroupingRowSelection)\n    // ) {\n    if (value) {\n        if (!row.getCanMultiSelect()) {\n            Object.keys(selectedRowIds).forEach((key)=>delete selectedRowIds[key]);\n        }\n        if (row.getCanSelect()) {\n            selectedRowIds[id] = true;\n        }\n    } else {\n        delete selectedRowIds[id];\n    }\n    // }\n    if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {\n        row.subRows.forEach((row)=>mutateRowIsSelected(selectedRowIds, row.id, value, includeChildren, table));\n    }\n};\nfunction selectRowsFn(table, rowModel) {\n    const rowSelection = table.getState().rowSelection;\n    const newSelectedFlatRows = [];\n    const newSelectedRowsById = {};\n    // Filters top level and nested rows\n    const recurseRows = function(rows, depth) {\n        return rows.map((row)=>{\n            var _row$subRows2;\n            const isSelected = isRowSelected(row, rowSelection);\n            if (isSelected) {\n                newSelectedFlatRows.push(row);\n                newSelectedRowsById[row.id] = row;\n            }\n            if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\n                row = {\n                    ...row,\n                    subRows: recurseRows(row.subRows)\n                };\n            }\n            if (isSelected) {\n                return row;\n            }\n        }).filter(Boolean);\n    };\n    return {\n        rows: recurseRows(rowModel.rows),\n        flatRows: newSelectedFlatRows,\n        rowsById: newSelectedRowsById\n    };\n}\nfunction isRowSelected(row, selection) {\n    var _selection$row$id;\n    return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;\n}\nfunction isSubRowSelected(row, selection, table) {\n    var _row$subRows3;\n    if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;\n    let allChildrenSelected = true;\n    let someSelected = false;\n    row.subRows.forEach((subRow)=>{\n        // Bail out early if we know both of these\n        if (someSelected && !allChildrenSelected) {\n            return;\n        }\n        if (subRow.getCanSelect()) {\n            if (isRowSelected(subRow, selection)) {\n                someSelected = true;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n        // Check row selection of nested subrows\n        if (subRow.subRows && subRow.subRows.length) {\n            const subRowChildrenSelected = isSubRowSelected(subRow, selection);\n            if (subRowChildrenSelected === \"all\") {\n                someSelected = true;\n            } else if (subRowChildrenSelected === \"some\") {\n                someSelected = true;\n                allChildrenSelected = false;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n    });\n    return allChildrenSelected ? \"all\" : someSelected ? \"some\" : false;\n}\nconst reSplitAlphaNumeric = /([0-9]+)/gm;\nconst alphanumeric = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\nconst alphanumericCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst text = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst textCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\nconst datetime = (rowA, rowB, columnId)=>{\n    const a = rowA.getValue(columnId);\n    const b = rowB.getValue(columnId);\n    // Can handle nullish values\n    // Use > and < because == (and ===) doesn't work with\n    // Date objects (would require calling getTime()).\n    return a > b ? 1 : a < b ? -1 : 0;\n};\nconst basic = (rowA, rowB, columnId)=>{\n    return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));\n};\n// Utils\nfunction compareBasic(a, b) {\n    return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction toString(a) {\n    if (typeof a === \"number\") {\n        if (isNaN(a) || a === Infinity || a === -Infinity) {\n            return \"\";\n        }\n        return String(a);\n    }\n    if (typeof a === \"string\") {\n        return a;\n    }\n    return \"\";\n}\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nfunction compareAlphanumeric(aStr, bStr) {\n    // Split on number groups, but keep the delimiter\n    // Then remove falsey split values\n    const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);\n    const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);\n    // While\n    while(a.length && b.length){\n        const aa = a.shift();\n        const bb = b.shift();\n        const an = parseInt(aa, 10);\n        const bn = parseInt(bb, 10);\n        const combo = [\n            an,\n            bn\n        ].sort();\n        // Both are string\n        if (isNaN(combo[0])) {\n            if (aa > bb) {\n                return 1;\n            }\n            if (bb > aa) {\n                return -1;\n            }\n            continue;\n        }\n        // One is a string, one is a number\n        if (isNaN(combo[1])) {\n            return isNaN(an) ? -1 : 1;\n        }\n        // Both are numbers\n        if (an > bn) {\n            return 1;\n        }\n        if (bn > an) {\n            return -1;\n        }\n    }\n    return a.length - b.length;\n}\n// Exports\nconst sortingFns = {\n    alphanumeric,\n    alphanumericCaseSensitive,\n    text,\n    textCaseSensitive,\n    datetime,\n    basic\n};\n//\nconst Sorting = {\n    getInitialState: (state)=>{\n        return {\n            sorting: [],\n            ...state\n        };\n    },\n    getDefaultColumnDef: ()=>{\n        return {\n            sortingFn: \"auto\",\n            sortUndefined: 1\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onSortingChange: makeStateUpdater(\"sorting\", table),\n            isMultiSortEvent: (e)=>{\n                return e.shiftKey;\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoSortingFn = ()=>{\n            const firstRows = table.getFilteredRowModel().flatRows.slice(10);\n            let isString = false;\n            for (const row of firstRows){\n                const value = row == null ? void 0 : row.getValue(column.id);\n                if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                    return sortingFns.datetime;\n                }\n                if (typeof value === \"string\") {\n                    isString = true;\n                    if (value.split(reSplitAlphaNumeric).length > 1) {\n                        return sortingFns.alphanumeric;\n                    }\n                }\n            }\n            if (isString) {\n                return sortingFns.text;\n            }\n            return sortingFns.basic;\n        };\n        column.getAutoSortDir = ()=>{\n            const firstRow = table.getFilteredRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return \"asc\";\n            }\n            return \"desc\";\n        };\n        column.getSortingFn = ()=>{\n            var _table$options$sortin, _table$options$sortin2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === \"auto\" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];\n        };\n        column.toggleSorting = (desc, multi)=>{\n            // if (column.columns.length) {\n            //   column.columns.forEach((c, i) => {\n            //     if (c.id) {\n            //       table.toggleColumnSorting(c.id, undefined, multi || !!i)\n            //     }\n            //   })\n            //   return\n            // }\n            // this needs to be outside of table.setSorting to be in sync with rerender\n            const nextSortingOrder = column.getNextSortingOrder();\n            const hasManualValue = typeof desc !== \"undefined\" && desc !== null;\n            table.setSorting((old)=>{\n                // Find any existing sorting for this column\n                const existingSorting = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const existingIndex = old == null ? void 0 : old.findIndex((d)=>d.id === column.id);\n                let newSorting = [];\n                // What should we do with this sort action?\n                let sortAction;\n                let nextDesc = hasManualValue ? desc : nextSortingOrder === \"desc\";\n                // Multi-mode\n                if (old != null && old.length && column.getCanMultiSort() && multi) {\n                    if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"add\";\n                    }\n                } else {\n                    // Normal mode\n                    if (old != null && old.length && existingIndex !== old.length - 1) {\n                        sortAction = \"replace\";\n                    } else if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"replace\";\n                    }\n                }\n                // Handle toggle states that will remove the sorting\n                if (sortAction === \"toggle\") {\n                    // If we are \"actually\" toggling (not a manual set value), should we remove the sorting?\n                    if (!hasManualValue) {\n                        // Is our intention to remove?\n                        if (!nextSortingOrder) {\n                            sortAction = \"remove\";\n                        }\n                    }\n                }\n                if (sortAction === \"add\") {\n                    var _table$options$maxMul;\n                    newSorting = [\n                        ...old,\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                    // Take latest n columns\n                    newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));\n                } else if (sortAction === \"toggle\") {\n                    // This flips (or sets) the\n                    newSorting = old.map((d)=>{\n                        if (d.id === column.id) {\n                            return {\n                                ...d,\n                                desc: nextDesc\n                            };\n                        }\n                        return d;\n                    });\n                } else if (sortAction === \"remove\") {\n                    newSorting = old.filter((d)=>d.id !== column.id);\n                } else {\n                    newSorting = [\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                }\n                return newSorting;\n            });\n        };\n        column.getFirstSortDir = ()=>{\n            var _ref, _column$columnDef$sor;\n            const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === \"desc\";\n            return sortDescFirst ? \"desc\" : \"asc\";\n        };\n        column.getNextSortingOrder = (multi)=>{\n            var _table$options$enable, _table$options$enable2;\n            const firstSortDirection = column.getFirstSortDir();\n            const isSorted = column.getIsSorted();\n            if (!isSorted) {\n                return firstSortDirection;\n            }\n            if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general\n            (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true // If multi, don't allow if enableMultiRemove))\n            )) {\n                return false;\n            }\n            return isSorted === \"desc\" ? \"asc\" : \"desc\";\n        };\n        column.getCanSort = ()=>{\n            var _column$columnDef$ena, _table$options$enable3;\n            return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;\n        };\n        column.getCanMultiSort = ()=>{\n            var _ref2, _column$columnDef$ena2;\n            return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;\n        };\n        column.getIsSorted = ()=>{\n            var _table$getState$sorti;\n            const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d)=>d.id === column.id);\n            return !columnSort ? false : columnSort.desc ? \"desc\" : \"asc\";\n        };\n        column.getSortIndex = ()=>{\n            var _table$getState$sorti2, _table$getState$sorti3;\n            return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$sorti2 : -1;\n        };\n        column.clearSorting = ()=>{\n            //clear sorting for just 1 column\n            table.setSorting((old)=>old != null && old.length ? old.filter((d)=>d.id !== column.id) : []);\n        };\n        column.getToggleSortingHandler = ()=>{\n            const canSort = column.getCanSort();\n            return (e)=>{\n                if (!canSort) return;\n                e.persist == null || e.persist();\n                column.toggleSorting == null || column.toggleSorting(undefined, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setSorting = (updater)=>table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);\n        table.resetSorting = (defaultState)=>{\n            var _table$initialState$s, _table$initialState;\n            table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);\n        };\n        table.getPreSortedRowModel = ()=>table.getGroupedRowModel();\n        table.getSortedRowModel = ()=>{\n            if (!table._getSortedRowModel && table.options.getSortedRowModel) {\n                table._getSortedRowModel = table.options.getSortedRowModel(table);\n            }\n            if (table.options.manualSorting || !table._getSortedRowModel) {\n                return table.getPreSortedRowModel();\n            }\n            return table._getSortedRowModel();\n        };\n    }\n};\n//\nconst Visibility = {\n    getInitialState: (state)=>{\n        return {\n            columnVisibility: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnVisibilityChange: makeStateUpdater(\"columnVisibility\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleVisibility = (value)=>{\n            if (column.getCanHide()) {\n                table.setColumnVisibility((old)=>({\n                        ...old,\n                        [column.id]: value != null ? value : !column.getIsVisible()\n                    }));\n            }\n        };\n        column.getIsVisible = ()=>{\n            var _ref, _table$getState$colum;\n            const childColumns = column.columns;\n            return (_ref = childColumns.length ? childColumns.some((c)=>c.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column.id]) != null ? _ref : true;\n        };\n        column.getCanHide = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);\n        };\n        column.getToggleVisibilityHandler = ()=>{\n            return (e)=>{\n                column.toggleVisibility == null || column.toggleVisibility(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row._getAllVisibleCells = memo(()=>[\n                row.getAllCells(),\n                table.getState().columnVisibility\n            ], (cells)=>{\n            return cells.filter((cell)=>cell.column.getIsVisible());\n        }, getMemoOptions(table.options, \"debugRows\", \"_getAllVisibleCells\"));\n        row.getVisibleCells = memo(()=>[\n                row.getLeftVisibleCells(),\n                row.getCenterVisibleCells(),\n                row.getRightVisibleCells()\n            ], (left, center, right)=>[\n                ...left,\n                ...center,\n                ...right\n            ], getMemoOptions(table.options, \"debugRows\", \"getVisibleCells\"));\n    },\n    createTable: (table)=>{\n        const makeVisibleColumnsMethod = (key, getColumns)=>{\n            return memo(()=>[\n                    getColumns(),\n                    getColumns().filter((d)=>d.getIsVisible()).map((d)=>d.id).join(\"_\")\n                ], (columns)=>{\n                return columns.filter((d)=>d.getIsVisible == null ? void 0 : d.getIsVisible());\n            }, getMemoOptions(table.options, \"debugColumns\", key));\n        };\n        table.getVisibleFlatColumns = makeVisibleColumnsMethod(\"getVisibleFlatColumns\", ()=>table.getAllFlatColumns());\n        table.getVisibleLeafColumns = makeVisibleColumnsMethod(\"getVisibleLeafColumns\", ()=>table.getAllLeafColumns());\n        table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod(\"getLeftVisibleLeafColumns\", ()=>table.getLeftLeafColumns());\n        table.getRightVisibleLeafColumns = makeVisibleColumnsMethod(\"getRightVisibleLeafColumns\", ()=>table.getRightLeafColumns());\n        table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod(\"getCenterVisibleLeafColumns\", ()=>table.getCenterLeafColumns());\n        table.setColumnVisibility = (updater)=>table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);\n        table.resetColumnVisibility = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});\n        };\n        table.toggleAllColumnsVisible = (value)=>{\n            var _value;\n            value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();\n            table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column)=>({\n                    ...obj,\n                    [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value\n                }), {}));\n        };\n        table.getIsAllColumnsVisible = ()=>!table.getAllLeafColumns().some((column)=>!(column.getIsVisible != null && column.getIsVisible()));\n        table.getIsSomeColumnsVisible = ()=>table.getAllLeafColumns().some((column)=>column.getIsVisible == null ? void 0 : column.getIsVisible());\n        table.getToggleAllColumnsVisibilityHandler = ()=>{\n            return (e)=>{\n                var _target;\n                table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nfunction _getVisibleLeafColumns(table, position) {\n    return !position ? table.getVisibleLeafColumns() : position === \"center\" ? table.getCenterVisibleLeafColumns() : position === \"left\" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();\n}\nconst features = [\n    Headers,\n    Visibility,\n    Ordering,\n    Pinning,\n    Filters,\n    Sorting,\n    Grouping,\n    Expanding,\n    Pagination,\n    RowSelection,\n    ColumnSizing\n];\n//\nfunction createTable(options) {\n    var _options$initialState;\n    if (options.debugAll || options.debugTable) {\n        console.info(\"Creating Table Instance...\");\n    }\n    let table = {\n        _features: features\n    };\n    const defaultOptions = table._features.reduce((obj, feature)=>{\n        return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));\n    }, {});\n    const mergeOptions = (options)=>{\n        if (table.options.mergeOptions) {\n            return table.options.mergeOptions(defaultOptions, options);\n        }\n        return {\n            ...defaultOptions,\n            ...options\n        };\n    };\n    const coreInitialState = {};\n    let initialState = {\n        ...coreInitialState,\n        ...(_options$initialState = options.initialState) != null ? _options$initialState : {}\n    };\n    table._features.forEach((feature)=>{\n        var _feature$getInitialSt;\n        initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;\n    });\n    const queued = [];\n    let queuedTimeout = false;\n    const coreInstance = {\n        _features: features,\n        options: {\n            ...defaultOptions,\n            ...options\n        },\n        initialState,\n        _queue: (cb)=>{\n            queued.push(cb);\n            if (!queuedTimeout) {\n                queuedTimeout = true;\n                // Schedule a microtask to run the queued callbacks after\n                // the current call stack (render, etc) has finished.\n                Promise.resolve().then(()=>{\n                    while(queued.length){\n                        queued.shift()();\n                    }\n                    queuedTimeout = false;\n                }).catch((error)=>setTimeout(()=>{\n                        throw error;\n                    }));\n            }\n        },\n        reset: ()=>{\n            table.setState(table.initialState);\n        },\n        setOptions: (updater)=>{\n            const newOptions = functionalUpdate(updater, table.options);\n            table.options = mergeOptions(newOptions);\n        },\n        getState: ()=>{\n            return table.options.state;\n        },\n        setState: (updater)=>{\n            table.options.onStateChange == null || table.options.onStateChange(updater);\n        },\n        _getRowId: (row, index, parent)=>{\n            var _table$options$getRow;\n            return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [\n                parent.id,\n                index\n            ].join(\".\") : index}`;\n        },\n        getCoreRowModel: ()=>{\n            if (!table._getCoreRowModel) {\n                table._getCoreRowModel = table.options.getCoreRowModel(table);\n            }\n            return table._getCoreRowModel();\n        },\n        // The final calls start at the bottom of the model,\n        // expanded rows, which then work their way up\n        getRowModel: ()=>{\n            return table.getPaginationRowModel();\n        },\n        //in next version, we should just pass in the row model as the optional 2nd arg\n        getRow: (id, searchAll)=>{\n            let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id];\n            if (!row) {\n                row = table.getCoreRowModel().rowsById[id];\n                if (!row) {\n                    if (true) {\n                        throw new Error(`getRow could not find row with ID: ${id}`);\n                    }\n                    throw new Error();\n                }\n            }\n            return row;\n        },\n        _getDefaultColumnDef: memo(()=>[\n                table.options.defaultColumn\n            ], (defaultColumn)=>{\n            var _defaultColumn;\n            defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};\n            return {\n                header: (props)=>{\n                    const resolvedColumnDef = props.header.column.columnDef;\n                    if (resolvedColumnDef.accessorKey) {\n                        return resolvedColumnDef.accessorKey;\n                    }\n                    if (resolvedColumnDef.accessorFn) {\n                        return resolvedColumnDef.id;\n                    }\n                    return null;\n                },\n                // footer: props => props.header.column.id,\n                cell: (props)=>{\n                    var _props$renderValue$to, _props$renderValue;\n                    return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;\n                },\n                ...table._features.reduce((obj, feature)=>{\n                    return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());\n                }, {}),\n                ...defaultColumn\n            };\n        }, getMemoOptions(options, \"debugColumns\", \"_getDefaultColumnDef\")),\n        _getColumnDefs: ()=>table.options.columns,\n        getAllColumns: memo(()=>[\n                table._getColumnDefs()\n            ], (columnDefs)=>{\n            const recurseColumns = function(columnDefs, parent, depth) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                return columnDefs.map((columnDef)=>{\n                    const column = createColumn(table, columnDef, depth, parent);\n                    const groupingColumnDef = columnDef;\n                    column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];\n                    return column;\n                });\n            };\n            return recurseColumns(columnDefs);\n        }, getMemoOptions(options, \"debugColumns\", \"getAllColumns\")),\n        getAllFlatColumns: memo(()=>[\n                table.getAllColumns()\n            ], (allColumns)=>{\n            return allColumns.flatMap((column)=>{\n                return column.getFlatColumns();\n            });\n        }, getMemoOptions(options, \"debugColumns\", \"getAllFlatColumns\")),\n        _getAllFlatColumnsById: memo(()=>[\n                table.getAllFlatColumns()\n            ], (flatColumns)=>{\n            return flatColumns.reduce((acc, column)=>{\n                acc[column.id] = column;\n                return acc;\n            }, {});\n        }, getMemoOptions(options, \"debugColumns\", \"getAllFlatColumnsById\")),\n        getAllLeafColumns: memo(()=>[\n                table.getAllColumns(),\n                table._getOrderColumnsFn()\n            ], (allColumns, orderColumns)=>{\n            let leafColumns = allColumns.flatMap((column)=>column.getLeafColumns());\n            return orderColumns(leafColumns);\n        }, getMemoOptions(options, \"debugColumns\", \"getAllLeafColumns\")),\n        getColumn: (columnId)=>{\n            const column = table._getAllFlatColumnsById()[columnId];\n            if ( true && !column) {\n                console.error(`[Table] Column with id '${columnId}' does not exist.`);\n            }\n            return column;\n        }\n    };\n    Object.assign(table, coreInstance);\n    for(let index = 0; index < table._features.length; index++){\n        const feature = table._features[index];\n        feature == null || feature.createTable == null || feature.createTable(table);\n    }\n    return table;\n}\nfunction createCell(table, row, column, columnId) {\n    const getRenderValue = ()=>{\n        var _cell$getValue;\n        return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;\n    };\n    const cell = {\n        id: `${row.id}_${column.id}`,\n        row,\n        column,\n        getValue: ()=>row.getValue(columnId),\n        renderValue: getRenderValue,\n        getContext: memo(()=>[\n                table,\n                column,\n                row,\n                cell\n            ], (table, column, row, cell)=>({\n                table,\n                column,\n                row,\n                cell: cell,\n                getValue: cell.getValue,\n                renderValue: cell.renderValue\n            }), getMemoOptions(table.options, \"debugCells\", \"cell.getContext\"))\n    };\n    table._features.forEach((feature)=>{\n        feature.createCell == null || feature.createCell(cell, column, row, table);\n    }, {});\n    return cell;\n}\nconst createRow = (table, id, original, rowIndex, depth, subRows, parentId)=>{\n    let row = {\n        id,\n        index: rowIndex,\n        original,\n        depth,\n        parentId,\n        _valuesCache: {},\n        _uniqueValuesCache: {},\n        getValue: (columnId)=>{\n            if (row._valuesCache.hasOwnProperty(columnId)) {\n                return row._valuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);\n            return row._valuesCache[columnId];\n        },\n        getUniqueValues: (columnId)=>{\n            if (row._uniqueValuesCache.hasOwnProperty(columnId)) {\n                return row._uniqueValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            if (!column.columnDef.getUniqueValues) {\n                row._uniqueValuesCache[columnId] = [\n                    row.getValue(columnId)\n                ];\n                return row._uniqueValuesCache[columnId];\n            }\n            row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);\n            return row._uniqueValuesCache[columnId];\n        },\n        renderValue: (columnId)=>{\n            var _row$getValue;\n            return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;\n        },\n        subRows: subRows != null ? subRows : [],\n        getLeafRows: ()=>flattenBy(row.subRows, (d)=>d.subRows),\n        getParentRow: ()=>row.parentId ? table.getRow(row.parentId, true) : undefined,\n        getParentRows: ()=>{\n            let parentRows = [];\n            let currentRow = row;\n            while(true){\n                const parentRow = currentRow.getParentRow();\n                if (!parentRow) break;\n                parentRows.push(parentRow);\n                currentRow = parentRow;\n            }\n            return parentRows.reverse();\n        },\n        getAllCells: memo(()=>[\n                table.getAllLeafColumns()\n            ], (leafColumns)=>{\n            return leafColumns.map((column)=>{\n                return createCell(table, row, column, column.id);\n            });\n        }, getMemoOptions(table.options, \"debugRows\", \"getAllCells\")),\n        _getAllCellsByColumnId: memo(()=>[\n                row.getAllCells()\n            ], (allCells)=>{\n            return allCells.reduce((acc, cell)=>{\n                acc[cell.column.id] = cell;\n                return acc;\n            }, {});\n        }, getMemoOptions(table.options, \"debugRows\", \"getAllCellsByColumnId\"))\n    };\n    for(let i = 0; i < table._features.length; i++){\n        const feature = table._features[i];\n        feature == null || feature.createRow == null || feature.createRow(row, table);\n    }\n    return row;\n};\n// type Person = {\n//   firstName: string\n//   lastName: string\n//   age: number\n//   visits: number\n//   status: string\n//   progress: number\n//   createdAt: Date\n//   nested: {\n//     foo: [\n//       {\n//         bar: 'bar'\n//       }\n//     ]\n//     bar: { subBar: boolean }[]\n//     baz: {\n//       foo: 'foo'\n//       bar: {\n//         baz: 'baz'\n//       }\n//     }\n//   }\n// }\n// const test: DeepKeys<Person> = 'nested.foo.0.bar'\n// const test2: DeepKeys<Person> = 'nested.bar'\n// const helper = createColumnHelper<Person>()\n// helper.accessor('nested.foo', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.foo.0.bar', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.bar', {\n//   cell: info => info.getValue(),\n// })\nfunction createColumnHelper() {\n    return {\n        accessor: (accessor, column)=>{\n            return typeof accessor === \"function\" ? {\n                ...column,\n                accessorFn: accessor\n            } : {\n                ...column,\n                accessorKey: accessor\n            };\n        },\n        display: (column)=>column,\n        group: (column)=>column\n    };\n}\nfunction getCoreRowModel() {\n    return (table)=>memo(()=>[\n                table.options.data\n            ], (data)=>{\n            const rowModel = {\n                rows: [],\n                flatRows: [],\n                rowsById: {}\n            };\n            const accessRows = function(originalRows, depth, parentRow) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                const rows = [];\n                for(let i = 0; i < originalRows.length; i++){\n                    // This could be an expensive check at scale, so we should move it somewhere else, but where?\n                    // if (!id) {\n                    //   if (process.env.NODE_ENV !== 'production') {\n                    //     throw new Error(`getRowId expected an ID, but got ${id}`)\n                    //   }\n                    // }\n                    // Make the row\n                    const row = createRow(table, table._getRowId(originalRows[i], i, parentRow), originalRows[i], i, depth, undefined, parentRow == null ? void 0 : parentRow.id);\n                    // Keep track of every row in a flat array\n                    rowModel.flatRows.push(row);\n                    // Also keep track of every row by its ID\n                    rowModel.rowsById[row.id] = row;\n                    // Push table row into parent\n                    rows.push(row);\n                    // Get the original subrows\n                    if (table.options.getSubRows) {\n                        var _row$originalSubRows;\n                        row.originalSubRows = table.options.getSubRows(originalRows[i], i);\n                        // Then recursively access them\n                        if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {\n                            row.subRows = accessRows(row.originalSubRows, depth + 1, row);\n                        }\n                    }\n                }\n                return rows;\n            };\n            rowModel.rows = accessRows(data);\n            return rowModel;\n        }, getMemoOptions(table.options, \"debugTable\", \"getRowModel\", ()=>table._autoResetPageIndex()));\n}\nfunction filterRows(rows, filterRowImpl, table) {\n    if (table.options.filterFromLeafRows) {\n        return filterRowModelFromLeafs(rows, filterRowImpl, table);\n    }\n    return filterRowModelFromRoot(rows, filterRowImpl, table);\n}\nfunction filterRowModelFromLeafs(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        const rows = [];\n        // Filter from children up first\n        for(let i = 0; i < rowsToFilter.length; i++){\n            var _row$subRows;\n            let row = rowsToFilter[i];\n            const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n            newRow.columnFilters = row.columnFilters;\n            if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {\n                newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                row = newRow;\n                if (filterRow(row) && !newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n                if (filterRow(row) || newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n            } else {\n                row = newRow;\n                if (filterRow(row)) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                }\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction filterRowModelFromRoot(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea2;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;\n    // Filters top level and nested rows\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        // Filter from parents downward first\n        const rows = [];\n        // Apply the filter to any subRows\n        for(let i = 0; i < rowsToFilter.length; i++){\n            let row = rowsToFilter[i];\n            const pass = filterRow(row);\n            if (pass) {\n                var _row$subRows2;\n                if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {\n                    const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n                    newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                    row = newRow;\n                }\n                rows.push(row);\n                newFilteredFlatRows.push(row);\n                newFilteredRowsById[row.id] = row;\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction getFilteredRowModel() {\n    return (table)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter\n            ], (rowModel, columnFilters, globalFilter)=>{\n            if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                for(let i = 0; i < rowModel.flatRows.length; i++){\n                    rowModel.flatRows[i].columnFilters = {};\n                    rowModel.flatRows[i].columnFiltersMeta = {};\n                }\n                return rowModel;\n            }\n            const resolvedColumnFilters = [];\n            const resolvedGlobalFilters = [];\n            (columnFilters != null ? columnFilters : []).forEach((d)=>{\n                var _filterFn$resolveFilt;\n                const column = table.getColumn(d.id);\n                if (!column) {\n                    return;\n                }\n                const filterFn = column.getFilterFn();\n                if (!filterFn) {\n                    if (true) {\n                        console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);\n                    }\n                    return;\n                }\n                resolvedColumnFilters.push({\n                    id: d.id,\n                    filterFn,\n                    resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value\n                });\n            });\n            const filterableIds = columnFilters.map((d)=>d.id);\n            const globalFilterFn = table.getGlobalFilterFn();\n            const globallyFilterableColumns = table.getAllLeafColumns().filter((column)=>column.getCanGlobalFilter());\n            if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {\n                filterableIds.push(\"__global__\");\n                globallyFilterableColumns.forEach((column)=>{\n                    var _globalFilterFn$resol;\n                    resolvedGlobalFilters.push({\n                        id: column.id,\n                        filterFn: globalFilterFn,\n                        resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter\n                    });\n                });\n            }\n            let currentColumnFilter;\n            let currentGlobalFilter;\n            // Flag the prefiltered row model with each filter state\n            for(let j = 0; j < rowModel.flatRows.length; j++){\n                const row = rowModel.flatRows[j];\n                row.columnFilters = {};\n                if (resolvedColumnFilters.length) {\n                    for(let i = 0; i < resolvedColumnFilters.length; i++){\n                        currentColumnFilter = resolvedColumnFilters[i];\n                        const id = currentColumnFilter.id;\n                        // Tag the row with the column filter state\n                        row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        });\n                    }\n                }\n                if (resolvedGlobalFilters.length) {\n                    for(let i = 0; i < resolvedGlobalFilters.length; i++){\n                        currentGlobalFilter = resolvedGlobalFilters[i];\n                        const id = currentGlobalFilter.id;\n                        // Tag the row with the first truthy global filter state\n                        if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        })) {\n                            row.columnFilters.__global__ = true;\n                            break;\n                        }\n                    }\n                    if (row.columnFilters.__global__ !== true) {\n                        row.columnFilters.__global__ = false;\n                    }\n                }\n            }\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            // Filter final rows using all of the active filters\n            return filterRows(rowModel.rows, filterRowsImpl, table);\n        }, getMemoOptions(table.options, \"debugTable\", \"getFilteredRowModel\", ()=>table._autoResetPageIndex()));\n}\nfunction getFacetedRowModel() {\n    return (table, columnId)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter,\n                table.getFilteredRowModel()\n            ], (preRowModel, columnFilters, globalFilter)=>{\n            if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                return preRowModel;\n            }\n            const filterableIds = [\n                ...columnFilters.map((d)=>d.id).filter((d)=>d !== columnId),\n                globalFilter ? \"__global__\" : undefined\n            ].filter(Boolean);\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            return filterRows(preRowModel.rows, filterRowsImpl, table);\n        }, getMemoOptions(table.options, \"debugTable\", \"getFacetedRowModel\"));\n}\nfunction getFacetedUniqueValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            if (!facetedRowModel) return new Map();\n            let facetedUniqueValues = new Map();\n            for(let i = 0; i < facetedRowModel.flatRows.length; i++){\n                const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n                for(let j = 0; j < values.length; j++){\n                    const value = values[j];\n                    if (facetedUniqueValues.has(value)) {\n                        var _facetedUniqueValues$;\n                        facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);\n                    } else {\n                        facetedUniqueValues.set(value, 1);\n                    }\n                }\n            }\n            return facetedUniqueValues;\n        }, getMemoOptions(table.options, \"debugTable\", `getFacetedUniqueValues_${columnId}`));\n}\nfunction getFacetedMinMaxValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            var _facetedRowModel$flat;\n            if (!facetedRowModel) return undefined;\n            const firstValue = (_facetedRowModel$flat = facetedRowModel.flatRows[0]) == null ? void 0 : _facetedRowModel$flat.getUniqueValues(columnId);\n            if (typeof firstValue === \"undefined\") {\n                return undefined;\n            }\n            let facetedMinMaxValues = [\n                firstValue,\n                firstValue\n            ];\n            for(let i = 0; i < facetedRowModel.flatRows.length; i++){\n                const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n                for(let j = 0; j < values.length; j++){\n                    const value = values[j];\n                    if (value < facetedMinMaxValues[0]) {\n                        facetedMinMaxValues[0] = value;\n                    } else if (value > facetedMinMaxValues[1]) {\n                        facetedMinMaxValues[1] = value;\n                    }\n                }\n            }\n            return facetedMinMaxValues;\n        }, getMemoOptions(table.options, \"debugTable\", \"getFacetedMinMaxValues\"));\n}\nfunction getSortedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().sorting,\n                table.getPreSortedRowModel()\n            ], (sorting, rowModel)=>{\n            if (!rowModel.rows.length || !(sorting != null && sorting.length)) {\n                return rowModel;\n            }\n            const sortingState = table.getState().sorting;\n            const sortedFlatRows = [];\n            // Filter out sortings that correspond to non existing columns\n            const availableSorting = sortingState.filter((sort)=>{\n                var _table$getColumn;\n                return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();\n            });\n            const columnInfoById = {};\n            availableSorting.forEach((sortEntry)=>{\n                const column = table.getColumn(sortEntry.id);\n                if (!column) return;\n                columnInfoById[sortEntry.id] = {\n                    sortUndefined: column.columnDef.sortUndefined,\n                    invertSorting: column.columnDef.invertSorting,\n                    sortingFn: column.getSortingFn()\n                };\n            });\n            const sortData = (rows)=>{\n                // This will also perform a stable sorting using the row index\n                // if needed.\n                const sortedData = rows.map((row)=>({\n                        ...row\n                    }));\n                sortedData.sort((rowA, rowB)=>{\n                    for(let i = 0; i < availableSorting.length; i += 1){\n                        var _sortEntry$desc;\n                        const sortEntry = availableSorting[i];\n                        const columnInfo = columnInfoById[sortEntry.id];\n                        const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;\n                        let sortInt = 0;\n                        // All sorting ints should always return in ascending order\n                        if (columnInfo.sortUndefined) {\n                            const aValue = rowA.getValue(sortEntry.id);\n                            const bValue = rowB.getValue(sortEntry.id);\n                            const aUndefined = aValue === undefined;\n                            const bUndefined = bValue === undefined;\n                            if (aUndefined || bUndefined) {\n                                sortInt = aUndefined && bUndefined ? 0 : aUndefined ? columnInfo.sortUndefined : -columnInfo.sortUndefined;\n                            }\n                        }\n                        if (sortInt === 0) {\n                            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);\n                        }\n                        // If sorting is non-zero, take care of desc and inversion\n                        if (sortInt !== 0) {\n                            if (isDesc) {\n                                sortInt *= -1;\n                            }\n                            if (columnInfo.invertSorting) {\n                                sortInt *= -1;\n                            }\n                            return sortInt;\n                        }\n                    }\n                    return rowA.index - rowB.index;\n                });\n                // If there are sub-rows, sort them\n                sortedData.forEach((row)=>{\n                    var _row$subRows;\n                    sortedFlatRows.push(row);\n                    if ((_row$subRows = row.subRows) != null && _row$subRows.length) {\n                        row.subRows = sortData(row.subRows);\n                    }\n                });\n                return sortedData;\n            };\n            return {\n                rows: sortData(rowModel.rows),\n                flatRows: sortedFlatRows,\n                rowsById: rowModel.rowsById\n            };\n        }, getMemoOptions(table.options, \"debugTable\", \"getSortedRowModel\", ()=>table._autoResetPageIndex()));\n}\nfunction getGroupedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().grouping,\n                table.getPreGroupedRowModel()\n            ], (grouping, rowModel)=>{\n            if (!rowModel.rows.length || !grouping.length) {\n                return rowModel;\n            }\n            // Filter the grouping list down to columns that exist\n            const existingGrouping = grouping.filter((columnId)=>table.getColumn(columnId));\n            const groupedFlatRows = [];\n            const groupedRowsById = {};\n            // const onlyGroupedFlatRows: Row[] = [];\n            // const onlyGroupedRowsById: Record<RowId, Row> = {};\n            // const nonGroupedFlatRows: Row[] = [];\n            // const nonGroupedRowsById: Record<RowId, Row> = {};\n            // Recursively group the data\n            const groupUpRecursively = function(rows, depth, parentId) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                // Grouping depth has been been met\n                // Stop grouping and simply rewrite thd depth and row relationships\n                if (depth >= existingGrouping.length) {\n                    return rows.map((row)=>{\n                        row.depth = depth;\n                        groupedFlatRows.push(row);\n                        groupedRowsById[row.id] = row;\n                        if (row.subRows) {\n                            row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id);\n                        }\n                        return row;\n                    });\n                }\n                const columnId = existingGrouping[depth];\n                // Group the rows together for this level\n                const rowGroupsMap = groupBy(rows, columnId);\n                // Peform aggregations for each group\n                const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index)=>{\n                    let [groupingValue, groupedRows] = _ref;\n                    let id = `${columnId}:${groupingValue}`;\n                    id = parentId ? `${parentId}>${id}` : id;\n                    // First, Recurse to group sub rows before aggregation\n                    const subRows = groupUpRecursively(groupedRows, depth + 1, id);\n                    // Flatten the leaf rows of the rows in this group\n                    const leafRows = depth ? flattenBy(groupedRows, (row)=>row.subRows) : groupedRows;\n                    const row = createRow(table, id, leafRows[0].original, index, depth, undefined, parentId);\n                    Object.assign(row, {\n                        groupingColumnId: columnId,\n                        groupingValue,\n                        subRows,\n                        leafRows,\n                        getValue: (columnId)=>{\n                            // Don't aggregate columns that are in the grouping\n                            if (existingGrouping.includes(columnId)) {\n                                if (row._valuesCache.hasOwnProperty(columnId)) {\n                                    return row._valuesCache[columnId];\n                                }\n                                if (groupedRows[0]) {\n                                    var _groupedRows$0$getVal;\n                                    row._valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;\n                                }\n                                return row._valuesCache[columnId];\n                            }\n                            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                                return row._groupingValuesCache[columnId];\n                            }\n                            // Aggregate the values\n                            const column = table.getColumn(columnId);\n                            const aggregateFn = column == null ? void 0 : column.getAggregationFn();\n                            if (aggregateFn) {\n                                row._groupingValuesCache[columnId] = aggregateFn(columnId, leafRows, groupedRows);\n                                return row._groupingValuesCache[columnId];\n                            }\n                        }\n                    });\n                    subRows.forEach((subRow)=>{\n                        groupedFlatRows.push(subRow);\n                        groupedRowsById[subRow.id] = subRow;\n                    // if (subRow.getIsGrouped?.()) {\n                    //   onlyGroupedFlatRows.push(subRow);\n                    //   onlyGroupedRowsById[subRow.id] = subRow;\n                    // } else {\n                    //   nonGroupedFlatRows.push(subRow);\n                    //   nonGroupedRowsById[subRow.id] = subRow;\n                    // }\n                    });\n                    return row;\n                });\n                return aggregatedGroupedRows;\n            };\n            const groupedRows = groupUpRecursively(rowModel.rows, 0);\n            groupedRows.forEach((subRow)=>{\n                groupedFlatRows.push(subRow);\n                groupedRowsById[subRow.id] = subRow;\n            // if (subRow.getIsGrouped?.()) {\n            //   onlyGroupedFlatRows.push(subRow);\n            //   onlyGroupedRowsById[subRow.id] = subRow;\n            // } else {\n            //   nonGroupedFlatRows.push(subRow);\n            //   nonGroupedRowsById[subRow.id] = subRow;\n            // }\n            });\n            return {\n                rows: groupedRows,\n                flatRows: groupedFlatRows,\n                rowsById: groupedRowsById\n            };\n        }, getMemoOptions(table.options, \"debugTable\", \"getGroupedRowModel\", ()=>{\n            table._queue(()=>{\n                table._autoResetExpanded();\n                table._autoResetPageIndex();\n            });\n        }));\n}\nfunction groupBy(rows, columnId) {\n    const groupMap = new Map();\n    return rows.reduce((map, row)=>{\n        const resKey = `${row.getGroupingValue(columnId)}`;\n        const previous = map.get(resKey);\n        if (!previous) {\n            map.set(resKey, [\n                row\n            ]);\n        } else {\n            previous.push(row);\n        }\n        return map;\n    }, groupMap);\n}\nfunction getExpandedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().expanded,\n                table.getPreExpandedRowModel(),\n                table.options.paginateExpandedRows\n            ], (expanded, rowModel, paginateExpandedRows)=>{\n            if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {\n                return rowModel;\n            }\n            if (!paginateExpandedRows) {\n                // Only expand rows at this point if they are being paginated\n                return rowModel;\n            }\n            return expandRows(rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getExpandedRowModel\"));\n}\nfunction expandRows(rowModel) {\n    const expandedRows = [];\n    const handleRow = (row)=>{\n        var _row$subRows;\n        expandedRows.push(row);\n        if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {\n            row.subRows.forEach(handleRow);\n        }\n    };\n    rowModel.rows.forEach(handleRow);\n    return {\n        rows: expandedRows,\n        flatRows: rowModel.flatRows,\n        rowsById: rowModel.rowsById\n    };\n}\nfunction getPaginationRowModel(opts) {\n    return (table)=>memo(()=>[\n                table.getState().pagination,\n                table.getPrePaginationRowModel(),\n                table.options.paginateExpandedRows ? undefined : table.getState().expanded\n            ], (pagination, rowModel)=>{\n            if (!rowModel.rows.length) {\n                return rowModel;\n            }\n            const { pageSize, pageIndex } = pagination;\n            let { rows, flatRows, rowsById } = rowModel;\n            const pageStart = pageSize * pageIndex;\n            const pageEnd = pageStart + pageSize;\n            rows = rows.slice(pageStart, pageEnd);\n            let paginatedRowModel;\n            if (!table.options.paginateExpandedRows) {\n                paginatedRowModel = expandRows({\n                    rows,\n                    flatRows,\n                    rowsById\n                });\n            } else {\n                paginatedRowModel = {\n                    rows,\n                    flatRows,\n                    rowsById\n                };\n            }\n            paginatedRowModel.flatRows = [];\n            const handleRow = (row)=>{\n                paginatedRowModel.flatRows.push(row);\n                if (row.subRows.length) {\n                    row.subRows.forEach(handleRow);\n                }\n            };\n            paginatedRowModel.rows.forEach(handleRow);\n            return paginatedRowModel;\n        }, getMemoOptions(table.options, \"debugTable\", \"getPaginationRowModel\"));\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3RhYmxlLWNvcmUvYnVpbGQvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7R0FTRyxHQUNILHdCQUF3QjtBQUV4QixxREFBcUQ7QUFFckQsR0FBRztBQUVILFNBQVNBLGlCQUFpQkMsT0FBTyxFQUFFQyxLQUFLO0lBQ3RDLE9BQU8sT0FBT0QsWUFBWSxhQUFhQSxRQUFRQyxTQUFTRDtBQUMxRDtBQUNBLFNBQVNFO0FBQ1AsRUFBRTtBQUNKO0FBQ0EsU0FBU0MsaUJBQWlCQyxHQUFHLEVBQUVDLFFBQVE7SUFDckMsT0FBT0wsQ0FBQUE7UUFDTEssU0FBU0MsUUFBUSxDQUFDQyxDQUFBQTtZQUNoQixPQUFPO2dCQUNMLEdBQUdBLEdBQUc7Z0JBQ04sQ0FBQ0gsSUFBSSxFQUFFTCxpQkFBaUJDLFNBQVNPLEdBQUcsQ0FBQ0gsSUFBSTtZQUMzQztRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVNJLFdBQVdDLENBQUM7SUFDbkIsT0FBT0EsYUFBYUM7QUFDdEI7QUFDQSxTQUFTQyxjQUFjRixDQUFDO0lBQ3RCLE9BQU9HLE1BQU1DLE9BQU8sQ0FBQ0osTUFBTUEsRUFBRUssS0FBSyxDQUFDQyxDQUFBQSxNQUFPLE9BQU9BLFFBQVE7QUFDM0Q7QUFDQSxTQUFTQyxVQUFVQyxHQUFHLEVBQUVDLFdBQVc7SUFDakMsTUFBTUMsT0FBTyxFQUFFO0lBQ2YsTUFBTUMsVUFBVUMsQ0FBQUE7UUFDZEEsT0FBT0MsT0FBTyxDQUFDQyxDQUFBQTtZQUNiSixLQUFLSyxJQUFJLENBQUNEO1lBQ1YsTUFBTUUsV0FBV1AsWUFBWUs7WUFDN0IsSUFBSUUsWUFBWSxRQUFRQSxTQUFTQyxNQUFNLEVBQUU7Z0JBQ3ZDTixRQUFRSztZQUNWO1FBQ0Y7SUFDRjtJQUNBTCxRQUFRSDtJQUNSLE9BQU9FO0FBQ1Q7QUFDQSxTQUFTUSxL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VztvQkFDQWpSO29CQUNBWTtnQkFDRjtZQUNGLE9BQU87Z0JBQ0xvbkIsb0JBQW9CO29CQUNsQi9XO29CQUNBalI7b0JBQ0FZO2dCQUNGO1lBQ0Y7WUFDQW9uQixrQkFBa0Job0IsUUFBUSxHQUFHLEVBQUU7WUFDL0IsTUFBTTZuQixZQUFZNW5CLENBQUFBO2dCQUNoQituQixrQkFBa0Job0IsUUFBUSxDQUFDalMsSUFBSSxDQUFDa1M7Z0JBQ2hDLElBQUlBLElBQUk2QixPQUFPLENBQUM3VCxNQUFNLEVBQUU7b0JBQ3RCZ1MsSUFBSTZCLE9BQU8sQ0FBQ2pVLE9BQU8sQ0FBQ2c2QjtnQkFDdEI7WUFDRjtZQUNBRyxrQkFBa0IvVyxJQUFJLENBQUNwakIsT0FBTyxDQUFDZzZCO1lBQy9CLE9BQU9HO1FBQ1QsR0FBRy8zQixlQUFlTyxNQUFNMEIsT0FBTyxFQUFFLGNBQWM7QUFDakQ7QUFFOHRCLENBQzl0QixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYWNrc3ViLWZlLW5leHQvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3RhYmxlLWNvcmUvYnVpbGQvbGliL2luZGV4Lm1qcz81NTZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICAgKiB0YWJsZS1jb3JlXG4gICAqXG4gICAqIENvcHlyaWdodCAoYykgVGFuU3RhY2tcbiAgICpcbiAgICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gICAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAgICpcbiAgICogQGxpY2Vuc2UgTUlUXG4gICAqL1xuLy8gSXMgdGhpcyB0eXBlIGEgdHVwbGU/XG5cbi8vIElmIHRoaXMgdHlwZSBpcyBhIHR1cGxlLCB3aGF0IGluZGljZXMgYXJlIGFsbG93ZWQ/XG5cbi8vL1xuXG5mdW5jdGlvbiBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIGlucHV0KSB7XG4gIHJldHVybiB0eXBlb2YgdXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IHVwZGF0ZXIoaW5wdXQpIDogdXBkYXRlcjtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vXG59XG5mdW5jdGlvbiBtYWtlU3RhdGVVcGRhdGVyKGtleSwgaW5zdGFuY2UpIHtcbiAgcmV0dXJuIHVwZGF0ZXIgPT4ge1xuICAgIGluc3RhbmNlLnNldFN0YXRlKG9sZCA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5vbGQsXG4gICAgICAgIFtrZXldOiBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZFtrZXldKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZCkge1xuICByZXR1cm4gZCBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufVxuZnVuY3Rpb24gaXNOdW1iZXJBcnJheShkKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGQpICYmIGQuZXZlcnkodmFsID0+IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5CeShhcnIsIGdldENoaWxkcmVuKSB7XG4gIGNvbnN0IGZsYXQgPSBbXTtcbiAgY29uc3QgcmVjdXJzZSA9IHN1YkFyciA9PiB7XG4gICAgc3ViQXJyLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBmbGF0LnB1c2goaXRlbSk7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKGl0ZW0pO1xuICAgICAgaWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJlY3Vyc2UoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICByZWN1cnNlKGFycik7XG4gIHJldHVybiBmbGF0O1xufVxuZnVuY3Rpb24gbWVtbyhnZXREZXBzLCBmbiwgb3B0cykge1xuICBsZXQgZGVwcyA9IFtdO1xuICBsZXQgcmVzdWx0O1xuICByZXR1cm4gZGVwQXJncyA9PiB7XG4gICAgbGV0IGRlcFRpbWU7XG4gICAgaWYgKG9wdHMua2V5ICYmIG9wdHMuZGVidWcpIGRlcFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG5ld0RlcHMgPSBnZXREZXBzKGRlcEFyZ3MpO1xuICAgIGNvbnN0IGRlcHNDaGFuZ2VkID0gbmV3RGVwcy5sZW5ndGggIT09IGRlcHMubGVuZ3RoIHx8IG5ld0RlcHMuc29tZSgoZGVwLCBpbmRleCkgPT4gZGVwc1tpbmRleF0gIT09IGRlcCk7XG4gICAgaWYgKCFkZXBzQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZGVwcyA9IG5ld0RlcHM7XG4gICAgbGV0IHJlc3VsdFRpbWU7XG4gICAgaWYgKG9wdHMua2V5ICYmIG9wdHMuZGVidWcpIHJlc3VsdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJlc3VsdCA9IGZuKC4uLm5ld0RlcHMpO1xuICAgIG9wdHMgPT0gbnVsbCB8fCBvcHRzLm9uQ2hhbmdlID09IG51bGwgfHwgb3B0cy5vbkNoYW5nZShyZXN1bHQpO1xuICAgIGlmIChvcHRzLmtleSAmJiBvcHRzLmRlYnVnKSB7XG4gICAgICBpZiAob3B0cyAhPSBudWxsICYmIG9wdHMuZGVidWcoKSkge1xuICAgICAgICBjb25zdCBkZXBFbmRUaW1lID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIGRlcFRpbWUpICogMTAwKSAvIDEwMDtcbiAgICAgICAgY29uc3QgcmVzdWx0RW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSByZXN1bHRUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgIGNvbnN0IHJlc3VsdEZwc1BlcmNlbnRhZ2UgPSByZXN1bHRFbmRUaW1lIC8gMTY7XG4gICAgICAgIGNvbnN0IHBhZCA9IChzdHIsIG51bSkgPT4ge1xuICAgICAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgICAgICBzdHIgPSAnICcgKyBzdHI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUuaW5mbyhgJWPij7EgJHtwYWQocmVzdWx0RW5kVGltZSwgNSl9IC8ke3BhZChkZXBFbmRUaW1lLCA1KX0gbXNgLCBgXG4gICAgICAgICAgICBmb250LXNpemU6IC42cmVtO1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICBjb2xvcjogaHNsKCR7TWF0aC5tYXgoMCwgTWF0aC5taW4oMTIwIC0gMTIwICogcmVzdWx0RnBzUGVyY2VudGFnZSwgMTIwKSl9ZGVnIDEwMCUgMzElKTtgLCBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRNZW1vT3B0aW9ucyh0YWJsZU9wdGlvbnMsIGRlYnVnTGV2ZWwsIGtleSwgb25DaGFuZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZU9wdGlvbnMkZGVidWdBbDtcbiAgICAgIHJldHVybiAoX3RhYmxlT3B0aW9ucyRkZWJ1Z0FsID0gdGFibGVPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZU9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGVPcHRpb25zJGRlYnVnQWwgOiB0YWJsZU9wdGlvbnNbZGVidWdMZXZlbF07XG4gICAgfSxcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIGtleSxcbiAgICBvbkNoYW5nZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb2x1bW4odGFibGUsIGNvbHVtbkRlZiwgZGVwdGgsIHBhcmVudCkge1xuICB2YXIgX3JlZiwgX3Jlc29sdmVkQ29sdW1uRGVmJGlkO1xuICBjb25zdCBkZWZhdWx0Q29sdW1uID0gdGFibGUuX2dldERlZmF1bHRDb2x1bW5EZWYoKTtcbiAgY29uc3QgcmVzb2x2ZWRDb2x1bW5EZWYgPSB7XG4gICAgLi4uZGVmYXVsdENvbHVtbixcbiAgICAuLi5jb2x1bW5EZWZcbiAgfTtcbiAgY29uc3QgYWNjZXNzb3JLZXkgPSByZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvcktleTtcbiAgbGV0IGlkID0gKF9yZWYgPSAoX3Jlc29sdmVkQ29sdW1uRGVmJGlkID0gcmVzb2x2ZWRDb2x1bW5EZWYuaWQpICE9IG51bGwgPyBfcmVzb2x2ZWRDb2x1bW5EZWYkaWQgOiBhY2Nlc3NvcktleSA/IGFjY2Vzc29yS2V5LnJlcGxhY2UoJy4nLCAnXycpIDogdW5kZWZpbmVkKSAhPSBudWxsID8gX3JlZiA6IHR5cGVvZiByZXNvbHZlZENvbHVtbkRlZi5oZWFkZXIgPT09ICdzdHJpbmcnID8gcmVzb2x2ZWRDb2x1bW5EZWYuaGVhZGVyIDogdW5kZWZpbmVkO1xuICBsZXQgYWNjZXNzb3JGbjtcbiAgaWYgKHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yRm4pIHtcbiAgICBhY2Nlc3NvckZuID0gcmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGbjtcbiAgfSBlbHNlIGlmIChhY2Nlc3NvcktleSkge1xuICAgIC8vIFN1cHBvcnQgZGVlcCBhY2Nlc3NvciBrZXlzXG4gICAgaWYgKGFjY2Vzc29yS2V5LmluY2x1ZGVzKCcuJykpIHtcbiAgICAgIGFjY2Vzc29yRm4gPSBvcmlnaW5hbFJvdyA9PiB7XG4gICAgICAgIGxldCByZXN1bHQgPSBvcmlnaW5hbFJvdztcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgYWNjZXNzb3JLZXkuc3BsaXQoJy4nKSkge1xuICAgICAgICAgIHZhciBfcmVzdWx0O1xuICAgICAgICAgIHJlc3VsdCA9IChfcmVzdWx0ID0gcmVzdWx0KSA9PSBudWxsID8gdm9pZCAwIDogX3Jlc3VsdFtrZXldO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFwiJHtrZXl9XCIgaW4gZGVlcGx5IG5lc3RlZCBrZXkgXCIke2FjY2Vzc29yS2V5fVwiIHJldHVybmVkIHVuZGVmaW5lZC5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY2Vzc29yRm4gPSBvcmlnaW5hbFJvdyA9PiBvcmlnaW5hbFJvd1tyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvcktleV07XG4gICAgfVxuICB9XG4gIGlmICghaWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yRm4gPyBgQ29sdW1ucyByZXF1aXJlIGFuIGlkIHdoZW4gdXNpbmcgYW4gYWNjZXNzb3JGbmAgOiBgQ29sdW1ucyByZXF1aXJlIGFuIGlkIHdoZW4gdXNpbmcgYSBub24tc3RyaW5nIGhlYWRlcmApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgfVxuICBsZXQgY29sdW1uID0ge1xuICAgIGlkOiBgJHtTdHJpbmcoaWQpfWAsXG4gICAgYWNjZXNzb3JGbixcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBkZXB0aCxcbiAgICBjb2x1bW5EZWY6IHJlc29sdmVkQ29sdW1uRGVmLFxuICAgIGNvbHVtbnM6IFtdLFxuICAgIGdldEZsYXRDb2x1bW5zOiBtZW1vKCgpID0+IFt0cnVlXSwgKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1ucztcbiAgICAgIHJldHVybiBbY29sdW1uLCAuLi4oKF9jb2x1bW4kY29sdW1ucyA9IGNvbHVtbi5jb2x1bW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbHVtbiRjb2x1bW5zLmZsYXRNYXAoZCA9PiBkLmdldEZsYXRDb2x1bW5zKCkpKV07XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdjb2x1bW4uZ2V0RmxhdENvbHVtbnMnKSksXG4gICAgZ2V0TGVhZkNvbHVtbnM6IG1lbW8oKCkgPT4gW3RhYmxlLl9nZXRPcmRlckNvbHVtbnNGbigpXSwgb3JkZXJDb2x1bW5zID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbnMyO1xuICAgICAgaWYgKChfY29sdW1uJGNvbHVtbnMyID0gY29sdW1uLmNvbHVtbnMpICE9IG51bGwgJiYgX2NvbHVtbiRjb2x1bW5zMi5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGxlYWZDb2x1bW5zID0gY29sdW1uLmNvbHVtbnMuZmxhdE1hcChjb2x1bW4gPT4gY29sdW1uLmdldExlYWZDb2x1bW5zKCkpO1xuICAgICAgICByZXR1cm4gb3JkZXJDb2x1bW5zKGxlYWZDb2x1bW5zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbY29sdW1uXTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2NvbHVtbi5nZXRMZWFmQ29sdW1ucycpKVxuICB9O1xuICBmb3IgKGNvbnN0IGZlYXR1cmUgb2YgdGFibGUuX2ZlYXR1cmVzKSB7XG4gICAgZmVhdHVyZS5jcmVhdGVDb2x1bW4gPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZUNvbHVtbihjb2x1bW4sIHRhYmxlKTtcbiAgfVxuXG4gIC8vIFllcywgd2UgaGF2ZSB0byBjb252ZXJ0IHRhYmxlIHRvIHVrbm93biwgYmVjYXVzZSB3ZSBrbm93IG1vcmUgdGhhbiB0aGUgY29tcGlsZXIgaGVyZS5cbiAgcmV0dXJuIGNvbHVtbjtcbn1cblxuY29uc3QgZGVidWcgPSAnZGVidWdIZWFkZXJzJztcbi8vXG5cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcih0YWJsZSwgY29sdW1uLCBvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRpZDtcbiAgY29uc3QgaWQgPSAoX29wdGlvbnMkaWQgPSBvcHRpb25zLmlkKSAhPSBudWxsID8gX29wdGlvbnMkaWQgOiBjb2x1bW4uaWQ7XG4gIGxldCBoZWFkZXIgPSB7XG4gICAgaWQsXG4gICAgY29sdW1uLFxuICAgIGluZGV4OiBvcHRpb25zLmluZGV4LFxuICAgIGlzUGxhY2Vob2xkZXI6ICEhb3B0aW9ucy5pc1BsYWNlaG9sZGVyLFxuICAgIHBsYWNlaG9sZGVySWQ6IG9wdGlvbnMucGxhY2Vob2xkZXJJZCxcbiAgICBkZXB0aDogb3B0aW9ucy5kZXB0aCxcbiAgICBzdWJIZWFkZXJzOiBbXSxcbiAgICBjb2xTcGFuOiAwLFxuICAgIHJvd1NwYW46IDAsXG4gICAgaGVhZGVyR3JvdXA6IG51bGwsXG4gICAgZ2V0TGVhZkhlYWRlcnM6ICgpID0+IHtcbiAgICAgIGNvbnN0IGxlYWZIZWFkZXJzID0gW107XG4gICAgICBjb25zdCByZWN1cnNlSGVhZGVyID0gaCA9PiB7XG4gICAgICAgIGlmIChoLnN1YkhlYWRlcnMgJiYgaC5zdWJIZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICAgIGguc3ViSGVhZGVycy5tYXAocmVjdXJzZUhlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgbGVhZkhlYWRlcnMucHVzaChoKTtcbiAgICAgIH07XG4gICAgICByZWN1cnNlSGVhZGVyKGhlYWRlcik7XG4gICAgICByZXR1cm4gbGVhZkhlYWRlcnM7XG4gICAgfSxcbiAgICBnZXRDb250ZXh0OiAoKSA9PiAoe1xuICAgICAgdGFibGUsXG4gICAgICBoZWFkZXI6IGhlYWRlcixcbiAgICAgIGNvbHVtblxuICAgIH0pXG4gIH07XG4gIHRhYmxlLl9mZWF0dXJlcy5mb3JFYWNoKGZlYXR1cmUgPT4ge1xuICAgIGZlYXR1cmUuY3JlYXRlSGVhZGVyID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVIZWFkZXIoaGVhZGVyLCB0YWJsZSk7XG4gIH0pO1xuICByZXR1cm4gaGVhZGVyO1xufVxuY29uc3QgSGVhZGVycyA9IHtcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICAvLyBIZWFkZXIgR3JvdXBzXG5cbiAgICB0YWJsZS5nZXRIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCBsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgdmFyIF9sZWZ0JG1hcCRmaWx0ZXIsIF9yaWdodCRtYXAkZmlsdGVyO1xuICAgICAgY29uc3QgbGVmdENvbHVtbnMgPSAoX2xlZnQkbWFwJGZpbHRlciA9IGxlZnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlZnQubWFwKGNvbHVtbklkID0+IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IF9sZWZ0JG1hcCRmaWx0ZXIgOiBbXTtcbiAgICAgIGNvbnN0IHJpZ2h0Q29sdW1ucyA9IChfcmlnaHQkbWFwJGZpbHRlciA9IHJpZ2h0ID09IG51bGwgPyB2b2lkIDAgOiByaWdodC5tYXAoY29sdW1uSWQgPT4gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pKSAhPSBudWxsID8gX3JpZ2h0JG1hcCRmaWx0ZXIgOiBbXTtcbiAgICAgIGNvbnN0IGNlbnRlckNvbHVtbnMgPSBsZWFmQ29sdW1ucy5maWx0ZXIoY29sdW1uID0+ICEobGVmdCAhPSBudWxsICYmIGxlZnQuaW5jbHVkZXMoY29sdW1uLmlkKSkgJiYgIShyaWdodCAhPSBudWxsICYmIHJpZ2h0LmluY2x1ZGVzKGNvbHVtbi5pZCkpKTtcbiAgICAgIGNvbnN0IGhlYWRlckdyb3VwcyA9IGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIFsuLi5sZWZ0Q29sdW1ucywgLi4uY2VudGVyQ29sdW1ucywgLi4ucmlnaHRDb2x1bW5zXSwgdGFibGUpO1xuICAgICAgcmV0dXJuIGhlYWRlckdyb3VwcztcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldEhlYWRlckdyb3VwcycpKTtcbiAgICB0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCBsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgbGVhZkNvbHVtbnMgPSBsZWFmQ29sdW1ucy5maWx0ZXIoY29sdW1uID0+ICEobGVmdCAhPSBudWxsICYmIGxlZnQuaW5jbHVkZXMoY29sdW1uLmlkKSkgJiYgIShyaWdodCAhPSBudWxsICYmIHJpZ2h0LmluY2x1ZGVzKGNvbHVtbi5pZCkpKTtcbiAgICAgIHJldHVybiBidWlsZEhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBsZWFmQ29sdW1ucywgdGFibGUsICdjZW50ZXInKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldENlbnRlckhlYWRlckdyb3VwcycpKTtcbiAgICB0YWJsZS5nZXRMZWZ0SGVhZGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpLCB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIGxlZnQpID0+IHtcbiAgICAgIHZhciBfbGVmdCRtYXAkZmlsdGVyMjtcbiAgICAgIGNvbnN0IG9yZGVyZWRMZWFmQ29sdW1ucyA9IChfbGVmdCRtYXAkZmlsdGVyMiA9IGxlZnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlZnQubWFwKGNvbHVtbklkID0+IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IF9sZWZ0JG1hcCRmaWx0ZXIyIDogW107XG4gICAgICByZXR1cm4gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgb3JkZXJlZExlYWZDb2x1bW5zLCB0YWJsZSwgJ2xlZnQnKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldExlZnRIZWFkZXJHcm91cHMnKSk7XG4gICAgdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIHJpZ2h0KSA9PiB7XG4gICAgICB2YXIgX3JpZ2h0JG1hcCRmaWx0ZXIyO1xuICAgICAgY29uc3Qgb3JkZXJlZExlYWZDb2x1bW5zID0gKF9yaWdodCRtYXAkZmlsdGVyMiA9IHJpZ2h0ID09IG51bGwgPyB2b2lkIDAgOiByaWdodC5tYXAoY29sdW1uSWQgPT4gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pKSAhPSBudWxsID8gX3JpZ2h0JG1hcCRmaWx0ZXIyIDogW107XG4gICAgICByZXR1cm4gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgb3JkZXJlZExlYWZDb2x1bW5zLCB0YWJsZSwgJ3JpZ2h0Jyk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRSaWdodEhlYWRlckdyb3VwcycpKTtcblxuICAgIC8vIEZvb3RlciBHcm91cHNcblxuICAgIHRhYmxlLmdldEZvb3Rlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRGb290ZXJHcm91cHMnKSk7XG4gICAgdGFibGUuZ2V0TGVmdEZvb3Rlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0TGVmdEZvb3Rlckdyb3VwcycpKTtcbiAgICB0YWJsZS5nZXRDZW50ZXJGb290ZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0Q2VudGVyRm9vdGVyR3JvdXBzJykpO1xuICAgIHRhYmxlLmdldFJpZ2h0Rm9vdGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0UmlnaHRGb290ZXJHcm91cHMnKSk7XG5cbiAgICAvLyBGbGF0IEhlYWRlcnNcblxuICAgIHRhYmxlLmdldEZsYXRIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0SGVhZGVyR3JvdXBzKCldLCBoZWFkZXJHcm91cHMgPT4ge1xuICAgICAgcmV0dXJuIGhlYWRlckdyb3Vwcy5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldEZsYXRIZWFkZXJzJykpO1xuICAgIHRhYmxlLmdldExlZnRGbGF0SGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKV0sIGxlZnQgPT4ge1xuICAgICAgcmV0dXJuIGxlZnQubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYWRlckdyb3VwLmhlYWRlcnM7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRMZWZ0RmxhdEhlYWRlcnMnKSk7XG4gICAgdGFibGUuZ2V0Q2VudGVyRmxhdEhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKV0sIGxlZnQgPT4ge1xuICAgICAgcmV0dXJuIGxlZnQubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYWRlckdyb3VwLmhlYWRlcnM7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRDZW50ZXJGbGF0SGVhZGVycycpKTtcbiAgICB0YWJsZS5nZXRSaWdodEZsYXRIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKV0sIGxlZnQgPT4ge1xuICAgICAgcmV0dXJuIGxlZnQubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYWRlckdyb3VwLmhlYWRlcnM7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRSaWdodEZsYXRIZWFkZXJzJykpO1xuXG4gICAgLy8gTGVhZiBIZWFkZXJzXG5cbiAgICB0YWJsZS5nZXRDZW50ZXJMZWFmSGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldENlbnRlckZsYXRIZWFkZXJzKCldLCBmbGF0SGVhZGVycyA9PiB7XG4gICAgICByZXR1cm4gZmxhdEhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7XG4gICAgICAgIHZhciBfaGVhZGVyJHN1YkhlYWRlcnM7XG4gICAgICAgIHJldHVybiAhKChfaGVhZGVyJHN1YkhlYWRlcnMgPSBoZWFkZXIuc3ViSGVhZGVycykgIT0gbnVsbCAmJiBfaGVhZGVyJHN1YkhlYWRlcnMubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0Q2VudGVyTGVhZkhlYWRlcnMnKSk7XG4gICAgdGFibGUuZ2V0TGVmdExlYWZIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEZsYXRIZWFkZXJzKCldLCBmbGF0SGVhZGVycyA9PiB7XG4gICAgICByZXR1cm4gZmxhdEhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7XG4gICAgICAgIHZhciBfaGVhZGVyJHN1YkhlYWRlcnMyO1xuICAgICAgICByZXR1cm4gISgoX2hlYWRlciRzdWJIZWFkZXJzMiA9IGhlYWRlci5zdWJIZWFkZXJzKSAhPSBudWxsICYmIF9oZWFkZXIkc3ViSGVhZGVyczIubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0TGVmdExlYWZIZWFkZXJzJykpO1xuICAgIHRhYmxlLmdldFJpZ2h0TGVhZkhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSaWdodEZsYXRIZWFkZXJzKCldLCBmbGF0SGVhZGVycyA9PiB7XG4gICAgICByZXR1cm4gZmxhdEhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7XG4gICAgICAgIHZhciBfaGVhZGVyJHN1YkhlYWRlcnMzO1xuICAgICAgICByZXR1cm4gISgoX2hlYWRlciRzdWJIZWFkZXJzMyA9IGhlYWRlci5zdWJIZWFkZXJzKSAhPSBudWxsICYmIF9oZWFkZXIkc3ViSGVhZGVyczMubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0UmlnaHRMZWFmSGVhZGVycycpKTtcbiAgICB0YWJsZS5nZXRMZWFmSGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKSwgdGFibGUuZ2V0Q2VudGVySGVhZGVyR3JvdXBzKCksIHRhYmxlLmdldFJpZ2h0SGVhZGVyR3JvdXBzKCldLCAobGVmdCwgY2VudGVyLCByaWdodCkgPT4ge1xuICAgICAgdmFyIF9sZWZ0JDAkaGVhZGVycywgX2xlZnQkLCBfY2VudGVyJDAkaGVhZGVycywgX2NlbnRlciQsIF9yaWdodCQwJGhlYWRlcnMsIF9yaWdodCQ7XG4gICAgICByZXR1cm4gWy4uLigoX2xlZnQkMCRoZWFkZXJzID0gKF9sZWZ0JCA9IGxlZnRbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfbGVmdCQuaGVhZGVycykgIT0gbnVsbCA/IF9sZWZ0JDAkaGVhZGVycyA6IFtdKSwgLi4uKChfY2VudGVyJDAkaGVhZGVycyA9IChfY2VudGVyJCA9IGNlbnRlclswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jZW50ZXIkLmhlYWRlcnMpICE9IG51bGwgPyBfY2VudGVyJDAkaGVhZGVycyA6IFtdKSwgLi4uKChfcmlnaHQkMCRoZWFkZXJzID0gKF9yaWdodCQgPSByaWdodFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yaWdodCQuaGVhZGVycykgIT0gbnVsbCA/IF9yaWdodCQwJGhlYWRlcnMgOiBbXSldLm1hcChoZWFkZXIgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyLmdldExlYWZIZWFkZXJzKCk7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRMZWFmSGVhZGVycycpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIGNvbHVtbnNUb0dyb3VwLCB0YWJsZSwgaGVhZGVyRmFtaWx5KSB7XG4gIHZhciBfaGVhZGVyR3JvdXBzJDAkaGVhZGUsIF9oZWFkZXJHcm91cHMkO1xuICAvLyBGaW5kIHRoZSBtYXggZGVwdGggb2YgdGhlIGNvbHVtbnM6XG4gIC8vIGJ1aWxkIHRoZSBsZWFmIGNvbHVtbiByb3dcbiAgLy8gYnVpbGQgZWFjaCBidWZmZXIgcm93IGdvaW5nIHVwXG4gIC8vICAgIHBsYWNlaG9sZGVyIGZvciBub24tZXhpc3RlbnQgbGV2ZWxcbiAgLy8gICAgcmVhbCBjb2x1bW4gZm9yIGV4aXN0aW5nIGxldmVsXG5cbiAgbGV0IG1heERlcHRoID0gMDtcbiAgY29uc3QgZmluZE1heERlcHRoID0gZnVuY3Rpb24gKGNvbHVtbnMsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgIGRlcHRoID0gMTtcbiAgICB9XG4gICAgbWF4RGVwdGggPSBNYXRoLm1heChtYXhEZXB0aCwgZGVwdGgpO1xuICAgIGNvbHVtbnMuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4uZ2V0SXNWaXNpYmxlKCkpLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbnM7XG4gICAgICBpZiAoKF9jb2x1bW4kY29sdW1ucyA9IGNvbHVtbi5jb2x1bW5zKSAhPSBudWxsICYmIF9jb2x1bW4kY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgZmluZE1heERlcHRoKGNvbHVtbi5jb2x1bW5zLCBkZXB0aCArIDEpO1xuICAgICAgfVxuICAgIH0sIDApO1xuICB9O1xuICBmaW5kTWF4RGVwdGgoYWxsQ29sdW1ucyk7XG4gIGxldCBoZWFkZXJHcm91cHMgPSBbXTtcbiAgY29uc3QgY3JlYXRlSGVhZGVyR3JvdXAgPSAoaGVhZGVyc1RvR3JvdXAsIGRlcHRoKSA9PiB7XG4gICAgLy8gVGhlIGhlYWRlciBncm91cCB3ZSBhcmUgY3JlYXRpbmdcbiAgICBjb25zdCBoZWFkZXJHcm91cCA9IHtcbiAgICAgIGRlcHRoLFxuICAgICAgaWQ6IFtoZWFkZXJGYW1pbHksIGAke2RlcHRofWBdLmZpbHRlcihCb29sZWFuKS5qb2luKCdfJyksXG4gICAgICBoZWFkZXJzOiBbXVxuICAgIH07XG5cbiAgICAvLyBUaGUgcGFyZW50IGNvbHVtbnMgd2UncmUgZ29pbmcgdG8gc2NhbiBuZXh0XG4gICAgY29uc3QgcGVuZGluZ1BhcmVudEhlYWRlcnMgPSBbXTtcblxuICAgIC8vIFNjYW4gZWFjaCBjb2x1bW4gZm9yIHBhcmVudHNcbiAgICBoZWFkZXJzVG9Hcm91cC5mb3JFYWNoKGhlYWRlclRvR3JvdXAgPT4ge1xuICAgICAgLy8gV2hhdCBpcyB0aGUgbGF0ZXN0IChsYXN0KSBwYXJlbnQgY29sdW1uP1xuXG4gICAgICBjb25zdCBsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyID0gWy4uLnBlbmRpbmdQYXJlbnRIZWFkZXJzXS5yZXZlcnNlKClbMF07XG4gICAgICBjb25zdCBpc0xlYWZIZWFkZXIgPSBoZWFkZXJUb0dyb3VwLmNvbHVtbi5kZXB0aCA9PT0gaGVhZGVyR3JvdXAuZGVwdGg7XG4gICAgICBsZXQgY29sdW1uO1xuICAgICAgbGV0IGlzUGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgICAgIGlmIChpc0xlYWZIZWFkZXIgJiYgaGVhZGVyVG9Hcm91cC5jb2x1bW4ucGFyZW50KSB7XG4gICAgICAgIC8vIFRoZSBwYXJlbnQgaGVhZGVyIGlzIG5ld1xuICAgICAgICBjb2x1bW4gPSBoZWFkZXJUb0dyb3VwLmNvbHVtbi5wYXJlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgcGFyZW50IGhlYWRlciBpcyByZXBlYXRlZFxuICAgICAgICBjb2x1bW4gPSBoZWFkZXJUb0dyb3VwLmNvbHVtbjtcbiAgICAgICAgaXNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlciAmJiAobGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlciA9PSBudWxsID8gdm9pZCAwIDogbGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlci5jb2x1bW4pID09PSBjb2x1bW4pIHtcbiAgICAgICAgLy8gVGhpcyBjb2x1bW4gaXMgcmVwZWF0ZWQuIEFkZCBpdCBhcyBhIHN1YiBoZWFkZXIgdG8gdGhlIG5leHQgYmF0Y2hcbiAgICAgICAgbGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlci5zdWJIZWFkZXJzLnB1c2goaGVhZGVyVG9Hcm91cCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IGhlYWRlci4gTGV0J3MgY3JlYXRlIGl0XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGNyZWF0ZUhlYWRlcih0YWJsZSwgY29sdW1uLCB7XG4gICAgICAgICAgaWQ6IFtoZWFkZXJGYW1pbHksIGRlcHRoLCBjb2x1bW4uaWQsIGhlYWRlclRvR3JvdXAgPT0gbnVsbCA/IHZvaWQgMCA6IGhlYWRlclRvR3JvdXAuaWRdLmZpbHRlcihCb29sZWFuKS5qb2luKCdfJyksXG4gICAgICAgICAgaXNQbGFjZWhvbGRlcixcbiAgICAgICAgICBwbGFjZWhvbGRlcklkOiBpc1BsYWNlaG9sZGVyID8gYCR7cGVuZGluZ1BhcmVudEhlYWRlcnMuZmlsdGVyKGQgPT4gZC5jb2x1bW4gPT09IGNvbHVtbikubGVuZ3RofWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgaW5kZXg6IHBlbmRpbmdQYXJlbnRIZWFkZXJzLmxlbmd0aFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgdGhlIGhlYWRlclRvR3JvdXAgYXMgYSBzdWJIZWFkZXIgb2YgdGhlIG5ldyBoZWFkZXJcbiAgICAgICAgaGVhZGVyLnN1YkhlYWRlcnMucHVzaChoZWFkZXJUb0dyb3VwKTtcbiAgICAgICAgLy8gQWRkIHRoZSBuZXcgaGVhZGVyIHRvIHRoZSBwZW5kaW5nUGFyZW50SGVhZGVycyB0byBnZXQgZ3JvdXBlZFxuICAgICAgICAvLyBpbiB0aGUgbmV4dCBiYXRjaFxuICAgICAgICBwZW5kaW5nUGFyZW50SGVhZGVycy5wdXNoKGhlYWRlcik7XG4gICAgICB9XG4gICAgICBoZWFkZXJHcm91cC5oZWFkZXJzLnB1c2goaGVhZGVyVG9Hcm91cCk7XG4gICAgICBoZWFkZXJUb0dyb3VwLmhlYWRlckdyb3VwID0gaGVhZGVyR3JvdXA7XG4gICAgfSk7XG4gICAgaGVhZGVyR3JvdXBzLnB1c2goaGVhZGVyR3JvdXApO1xuICAgIGlmIChkZXB0aCA+IDApIHtcbiAgICAgIGNyZWF0ZUhlYWRlckdyb3VwKHBlbmRpbmdQYXJlbnRIZWFkZXJzLCBkZXB0aCAtIDEpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgYm90dG9tSGVhZGVycyA9IGNvbHVtbnNUb0dyb3VwLm1hcCgoY29sdW1uLCBpbmRleCkgPT4gY3JlYXRlSGVhZGVyKHRhYmxlLCBjb2x1bW4sIHtcbiAgICBkZXB0aDogbWF4RGVwdGgsXG4gICAgaW5kZXhcbiAgfSkpO1xuICBjcmVhdGVIZWFkZXJHcm91cChib3R0b21IZWFkZXJzLCBtYXhEZXB0aCAtIDEpO1xuICBoZWFkZXJHcm91cHMucmV2ZXJzZSgpO1xuXG4gIC8vIGhlYWRlckdyb3VwcyA9IGhlYWRlckdyb3Vwcy5maWx0ZXIoaGVhZGVyR3JvdXAgPT4ge1xuICAvLyAgIHJldHVybiAhaGVhZGVyR3JvdXAuaGVhZGVycy5ldmVyeShoZWFkZXIgPT4gaGVhZGVyLmlzUGxhY2Vob2xkZXIpXG4gIC8vIH0pXG5cbiAgY29uc3QgcmVjdXJzZUhlYWRlcnNGb3JTcGFucyA9IGhlYWRlcnMgPT4ge1xuICAgIGNvbnN0IGZpbHRlcmVkSGVhZGVycyA9IGhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiBoZWFkZXIuY29sdW1uLmdldElzVmlzaWJsZSgpKTtcbiAgICByZXR1cm4gZmlsdGVyZWRIZWFkZXJzLm1hcChoZWFkZXIgPT4ge1xuICAgICAgbGV0IGNvbFNwYW4gPSAwO1xuICAgICAgbGV0IHJvd1NwYW4gPSAwO1xuICAgICAgbGV0IGNoaWxkUm93U3BhbnMgPSBbMF07XG4gICAgICBpZiAoaGVhZGVyLnN1YkhlYWRlcnMgJiYgaGVhZGVyLnN1YkhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGNoaWxkUm93U3BhbnMgPSBbXTtcbiAgICAgICAgcmVjdXJzZUhlYWRlcnNGb3JTcGFucyhoZWFkZXIuc3ViSGVhZGVycykuZm9yRWFjaChfcmVmID0+IHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgY29sU3BhbjogY2hpbGRDb2xTcGFuLFxuICAgICAgICAgICAgcm93U3BhbjogY2hpbGRSb3dTcGFuXG4gICAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgICAgY29sU3BhbiArPSBjaGlsZENvbFNwYW47XG4gICAgICAgICAgY2hpbGRSb3dTcGFucy5wdXNoKGNoaWxkUm93U3Bhbik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sU3BhbiA9IDE7XG4gICAgICB9XG4gICAgICBjb25zdCBtaW5DaGlsZFJvd1NwYW4gPSBNYXRoLm1pbiguLi5jaGlsZFJvd1NwYW5zKTtcbiAgICAgIHJvd1NwYW4gPSByb3dTcGFuICsgbWluQ2hpbGRSb3dTcGFuO1xuICAgICAgaGVhZGVyLmNvbFNwYW4gPSBjb2xTcGFuO1xuICAgICAgaGVhZGVyLnJvd1NwYW4gPSByb3dTcGFuO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29sU3BhbixcbiAgICAgICAgcm93U3BhblxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbiAgcmVjdXJzZUhlYWRlcnNGb3JTcGFucygoX2hlYWRlckdyb3VwcyQwJGhlYWRlID0gKF9oZWFkZXJHcm91cHMkID0gaGVhZGVyR3JvdXBzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2hlYWRlckdyb3VwcyQuaGVhZGVycykgIT0gbnVsbCA/IF9oZWFkZXJHcm91cHMkMCRoZWFkZSA6IFtdKTtcbiAgcmV0dXJuIGhlYWRlckdyb3Vwcztcbn1cblxuLy9cblxuLy9cblxuY29uc3QgZGVmYXVsdENvbHVtblNpemluZyA9IHtcbiAgc2l6ZTogMTUwLFxuICBtaW5TaXplOiAyMCxcbiAgbWF4U2l6ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbn07XG5jb25zdCBnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlID0gKCkgPT4gKHtcbiAgc3RhcnRPZmZzZXQ6IG51bGwsXG4gIHN0YXJ0U2l6ZTogbnVsbCxcbiAgZGVsdGFPZmZzZXQ6IG51bGwsXG4gIGRlbHRhUGVyY2VudGFnZTogbnVsbCxcbiAgaXNSZXNpemluZ0NvbHVtbjogZmFsc2UsXG4gIGNvbHVtblNpemluZ1N0YXJ0OiBbXVxufSk7XG5jb25zdCBDb2x1bW5TaXppbmcgPSB7XG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpID0+IHtcbiAgICByZXR1cm4gZGVmYXVsdENvbHVtblNpemluZztcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtblNpemluZzoge30sXG4gICAgICBjb2x1bW5TaXppbmdJbmZvOiBnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlKCksXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtblJlc2l6ZU1vZGU6ICdvbkVuZCcsXG4gICAgICBjb2x1bW5SZXNpemVEaXJlY3Rpb246ICdsdHInLFxuICAgICAgb25Db2x1bW5TaXppbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblNpemluZycsIHRhYmxlKSxcbiAgICAgIG9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uU2l6aW5nSW5mbycsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4uZ2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRtaW4sIF9yZWYsIF9jb2x1bW4kY29sdW1uRGVmJG1heDtcbiAgICAgIGNvbnN0IGNvbHVtblNpemUgPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblNpemluZ1tjb2x1bW4uaWRdO1xuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KChfY29sdW1uJGNvbHVtbkRlZiRtaW4gPSBjb2x1bW4uY29sdW1uRGVmLm1pblNpemUpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRtaW4gOiBkZWZhdWx0Q29sdW1uU2l6aW5nLm1pblNpemUsIChfcmVmID0gY29sdW1uU2l6ZSAhPSBudWxsID8gY29sdW1uU2l6ZSA6IGNvbHVtbi5jb2x1bW5EZWYuc2l6ZSkgIT0gbnVsbCA/IF9yZWYgOiBkZWZhdWx0Q29sdW1uU2l6aW5nLnNpemUpLCAoX2NvbHVtbiRjb2x1bW5EZWYkbWF4ID0gY29sdW1uLmNvbHVtbkRlZi5tYXhTaXplKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkbWF4IDogZGVmYXVsdENvbHVtblNpemluZy5tYXhTaXplKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRTdGFydCA9IG1lbW8ocG9zaXRpb24gPT4gW3Bvc2l0aW9uLCBfZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKHRhYmxlLCBwb3NpdGlvbiksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uU2l6aW5nXSwgKHBvc2l0aW9uLCBjb2x1bW5zKSA9PiBjb2x1bW5zLnNsaWNlKDAsIGNvbHVtbi5nZXRJbmRleChwb3NpdGlvbikpLnJlZHVjZSgoc3VtLCBjb2x1bW4pID0+IHN1bSArIGNvbHVtbi5nZXRTaXplKCksIDApLCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldFN0YXJ0JykpO1xuICAgIGNvbHVtbi5nZXRBZnRlciA9IG1lbW8ocG9zaXRpb24gPT4gW3Bvc2l0aW9uLCBfZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKHRhYmxlLCBwb3NpdGlvbiksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uU2l6aW5nXSwgKHBvc2l0aW9uLCBjb2x1bW5zKSA9PiBjb2x1bW5zLnNsaWNlKGNvbHVtbi5nZXRJbmRleChwb3NpdGlvbikgKyAxKS5yZWR1Y2UoKHN1bSwgY29sdW1uKSA9PiBzdW0gKyBjb2x1bW4uZ2V0U2l6ZSgpLCAwKSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRBZnRlcicpKTtcbiAgICBjb2x1bW4ucmVzZXRTaXplID0gKCkgPT4ge1xuICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBbY29sdW1uLmlkXTogXyxcbiAgICAgICAgICAuLi5yZXN0XG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5SZXNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZVJlc2l6aW5nKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUNvbHVtblJlc2l6aW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNSZXNpemluZyA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblNpemluZ0luZm8uaXNSZXNpemluZ0NvbHVtbiA9PT0gY29sdW1uLmlkO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUhlYWRlcjogKGhlYWRlciwgdGFibGUpID0+IHtcbiAgICBoZWFkZXIuZ2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgY29uc3QgcmVjdXJzZSA9IGhlYWRlciA9PiB7XG4gICAgICAgIGlmIChoZWFkZXIuc3ViSGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBoZWFkZXIuc3ViSGVhZGVycy5mb3JFYWNoKHJlY3Vyc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfaGVhZGVyJGNvbHVtbiRnZXRTaXo7XG4gICAgICAgICAgc3VtICs9IChfaGVhZGVyJGNvbHVtbiRnZXRTaXogPSBoZWFkZXIuY29sdW1uLmdldFNpemUoKSkgIT0gbnVsbCA/IF9oZWFkZXIkY29sdW1uJGdldFNpeiA6IDA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZWN1cnNlKGhlYWRlcik7XG4gICAgICByZXR1cm4gc3VtO1xuICAgIH07XG4gICAgaGVhZGVyLmdldFN0YXJ0ID0gKCkgPT4ge1xuICAgICAgaWYgKGhlYWRlci5pbmRleCA+IDApIHtcbiAgICAgICAgY29uc3QgcHJldlNpYmxpbmdIZWFkZXIgPSBoZWFkZXIuaGVhZGVyR3JvdXAuaGVhZGVyc1toZWFkZXIuaW5kZXggLSAxXTtcbiAgICAgICAgcmV0dXJuIHByZXZTaWJsaW5nSGVhZGVyLmdldFN0YXJ0KCkgKyBwcmV2U2libGluZ0hlYWRlci5nZXRTaXplKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIGhlYWRlci5nZXRSZXNpemVIYW5kbGVyID0gX2NvbnRleHREb2N1bWVudCA9PiB7XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oaGVhZGVyLmNvbHVtbi5pZCk7XG4gICAgICBjb25zdCBjYW5SZXNpemUgPSBjb2x1bW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbHVtbi5nZXRDYW5SZXNpemUoKTtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgaWYgKCFjb2x1bW4gfHwgIWNhblJlc2l6ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlLnBlcnNpc3QgPT0gbnVsbCB8fCBlLnBlcnNpc3QoKTtcbiAgICAgICAgaWYgKGlzVG91Y2hTdGFydEV2ZW50KGUpKSB7XG4gICAgICAgICAgLy8gbGV0cyBub3QgcmVzcG9uZCB0byBtdWx0aXBsZSB0b3VjaGVzIChlLmcuIDIgb3IgMyBmaW5nZXJzKVxuICAgICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRTaXplID0gaGVhZGVyLmdldFNpemUoKTtcbiAgICAgICAgY29uc3QgY29sdW1uU2l6aW5nU3RhcnQgPSBoZWFkZXIgPyBoZWFkZXIuZ2V0TGVhZkhlYWRlcnMoKS5tYXAoZCA9PiBbZC5jb2x1bW4uaWQsIGQuY29sdW1uLmdldFNpemUoKV0pIDogW1tjb2x1bW4uaWQsIGNvbHVtbi5nZXRTaXplKCldXTtcbiAgICAgICAgY29uc3QgY2xpZW50WCA9IGlzVG91Y2hTdGFydEV2ZW50KGUpID8gTWF0aC5yb3VuZChlLnRvdWNoZXNbMF0uY2xpZW50WCkgOiBlLmNsaWVudFg7XG4gICAgICAgIGNvbnN0IG5ld0NvbHVtblNpemluZyA9IHt9O1xuICAgICAgICBjb25zdCB1cGRhdGVPZmZzZXQgPSAoZXZlbnRUeXBlLCBjbGllbnRYUG9zKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjbGllbnRYUG9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKG9sZCA9PiB7XG4gICAgICAgICAgICB2YXIgX29sZCRzdGFydE9mZnNldCwgX29sZCRzdGFydFNpemU7XG4gICAgICAgICAgICBjb25zdCBkZWx0YURpcmVjdGlvbiA9IHRhYmxlLm9wdGlvbnMuY29sdW1uUmVzaXplRGlyZWN0aW9uID09PSAncnRsJyA/IC0xIDogMTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhT2Zmc2V0ID0gKGNsaWVudFhQb3MgLSAoKF9vbGQkc3RhcnRPZmZzZXQgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5zdGFydE9mZnNldCkgIT0gbnVsbCA/IF9vbGQkc3RhcnRPZmZzZXQgOiAwKSkgKiBkZWx0YURpcmVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhUGVyY2VudGFnZSA9IE1hdGgubWF4KGRlbHRhT2Zmc2V0IC8gKChfb2xkJHN0YXJ0U2l6ZSA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnN0YXJ0U2l6ZSkgIT0gbnVsbCA/IF9vbGQkc3RhcnRTaXplIDogMCksIC0wLjk5OTk5OSk7XG4gICAgICAgICAgICBvbGQuY29sdW1uU2l6aW5nU3RhcnQuZm9yRWFjaChfcmVmMyA9PiB7XG4gICAgICAgICAgICAgIGxldCBbY29sdW1uSWQsIGhlYWRlclNpemVdID0gX3JlZjM7XG4gICAgICAgICAgICAgIG5ld0NvbHVtblNpemluZ1tjb2x1bW5JZF0gPSBNYXRoLnJvdW5kKE1hdGgubWF4KGhlYWRlclNpemUgKyBoZWFkZXJTaXplICogZGVsdGFQZXJjZW50YWdlLCAwKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICAgICAgZGVsdGFPZmZzZXQsXG4gICAgICAgICAgICAgIGRlbHRhUGVyY2VudGFnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodGFibGUub3B0aW9ucy5jb2x1bW5SZXNpemVNb2RlID09PSAnb25DaGFuZ2UnIHx8IGV2ZW50VHlwZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZyhvbGQgPT4gKHtcbiAgICAgICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgICAgICAuLi5uZXdDb2x1bW5TaXppbmdcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uTW92ZSA9IGNsaWVudFhQb3MgPT4gdXBkYXRlT2Zmc2V0KCdtb3ZlJywgY2xpZW50WFBvcyk7XG4gICAgICAgIGNvbnN0IG9uRW5kID0gY2xpZW50WFBvcyA9PiB7XG4gICAgICAgICAgdXBkYXRlT2Zmc2V0KCdlbmQnLCBjbGllbnRYUG9zKTtcbiAgICAgICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKG9sZCA9PiAoe1xuICAgICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgICAgaXNSZXNpemluZ0NvbHVtbjogZmFsc2UsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogbnVsbCxcbiAgICAgICAgICAgIHN0YXJ0U2l6ZTogbnVsbCxcbiAgICAgICAgICAgIGRlbHRhT2Zmc2V0OiBudWxsLFxuICAgICAgICAgICAgZGVsdGFQZXJjZW50YWdlOiBudWxsLFxuICAgICAgICAgICAgY29sdW1uU2l6aW5nU3RhcnQ6IFtdXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb250ZXh0RG9jdW1lbnQgPSBfY29udGV4dERvY3VtZW50IHx8IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IG51bGw7XG4gICAgICAgIGNvbnN0IG1vdXNlRXZlbnRzID0ge1xuICAgICAgICAgIG1vdmVIYW5kbGVyOiBlID0+IG9uTW92ZShlLmNsaWVudFgpLFxuICAgICAgICAgIHVwSGFuZGxlcjogZSA9PiB7XG4gICAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VFdmVudHMubW92ZUhhbmRsZXIpO1xuICAgICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZUV2ZW50cy51cEhhbmRsZXIpO1xuICAgICAgICAgICAgb25FbmQoZS5jbGllbnRYKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRvdWNoRXZlbnRzID0ge1xuICAgICAgICAgIG1vdmVIYW5kbGVyOiBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25Nb3ZlKGUudG91Y2hlc1swXS5jbGllbnRYKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVwSGFuZGxlcjogZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2UkdG91Y2hlcyQ7XG4gICAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdG91Y2hFdmVudHMubW92ZUhhbmRsZXIpO1xuICAgICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hFdmVudHMudXBIYW5kbGVyKTtcbiAgICAgICAgICAgIGlmIChlLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25FbmQoKF9lJHRvdWNoZXMkID0gZS50b3VjaGVzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2UkdG91Y2hlcyQuY2xpZW50WCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXNzaXZlSWZTdXBwb3J0ZWQgPSBwYXNzaXZlRXZlbnRTdXBwb3J0ZWQoKSA/IHtcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9IDogZmFsc2U7XG4gICAgICAgIGlmIChpc1RvdWNoU3RhcnRFdmVudChlKSkge1xuICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaEV2ZW50cy5tb3ZlSGFuZGxlciwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcbiAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaEV2ZW50cy51cEhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlRXZlbnRzLm1vdmVIYW5kbGVyLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VFdmVudHMudXBIYW5kbGVyLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8ob2xkID0+ICh7XG4gICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBjbGllbnRYLFxuICAgICAgICAgIHN0YXJ0U2l6ZSxcbiAgICAgICAgICBkZWx0YU9mZnNldDogMCxcbiAgICAgICAgICBkZWx0YVBlcmNlbnRhZ2U6IDAsXG4gICAgICAgICAgY29sdW1uU2l6aW5nU3RhcnQsXG4gICAgICAgICAgaXNSZXNpemluZ0NvbHVtbjogY29sdW1uLmlkXG4gICAgICAgIH0pKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Db2x1bW5TaXppbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5TaXppbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nSW5mbyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0luZm9DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5TaXppbmdJbmZvQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Q29sdW1uU2l6aW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGM7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmcoZGVmYXVsdFN0YXRlID8ge30gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjID0gdGFibGUuaW5pdGlhbFN0YXRlLmNvbHVtblNpemluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYyA6IHt9KTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0SGVhZGVyU2l6ZUluZm8gPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYzI7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKGRlZmF1bHRTdGF0ZSA/IGdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUoKSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMyID0gdGFibGUuaW5pdGlhbFN0YXRlLmNvbHVtblNpemluZ0luZm8pICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMyIDogZ2V0RGVmYXVsdENvbHVtblNpemluZ0luZm9TdGF0ZSgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0SGVhZGVyR3JvdXAsIF90YWJsZSRnZXRIZWFkZXJHcm91cDI7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRIZWFkZXJHcm91cCA9IChfdGFibGUkZ2V0SGVhZGVyR3JvdXAyID0gdGFibGUuZ2V0SGVhZGVyR3JvdXBzKClbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0SGVhZGVyR3JvdXAyLmhlYWRlcnMucmVkdWNlKChzdW0sIGhlYWRlcikgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgaGVhZGVyLmdldFNpemUoKTtcbiAgICAgIH0sIDApKSAhPSBudWxsID8gX3RhYmxlJGdldEhlYWRlckdyb3VwIDogMDtcbiAgICB9O1xuICAgIHRhYmxlLmdldExlZnRUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldExlZnRIZWFkZXJHLCBfdGFibGUkZ2V0TGVmdEhlYWRlckcyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0TGVmdEhlYWRlckcgPSAoX3RhYmxlJGdldExlZnRIZWFkZXJHMiA9IHRhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRMZWZ0SGVhZGVyRzIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0TGVmdEhlYWRlckcgOiAwO1xuICAgIH07XG4gICAgdGFibGUuZ2V0Q2VudGVyVG90YWxTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRDZW50ZXJIZWFkZSwgX3RhYmxlJGdldENlbnRlckhlYWRlMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldENlbnRlckhlYWRlID0gKF90YWJsZSRnZXRDZW50ZXJIZWFkZTIgPSB0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDZW50ZXJIZWFkZTIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0Q2VudGVySGVhZGUgOiAwO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UmlnaHRUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFJpZ2h0SGVhZGVyLCBfdGFibGUkZ2V0UmlnaHRIZWFkZXIyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0UmlnaHRIZWFkZXIgPSAoX3RhYmxlJGdldFJpZ2h0SGVhZGVyMiA9IHRhYmxlLmdldFJpZ2h0SGVhZGVyR3JvdXBzKClbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0UmlnaHRIZWFkZXIyLmhlYWRlcnMucmVkdWNlKChzdW0sIGhlYWRlcikgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgaGVhZGVyLmdldFNpemUoKTtcbiAgICAgIH0sIDApKSAhPSBudWxsID8gX3RhYmxlJGdldFJpZ2h0SGVhZGVyIDogMDtcbiAgICB9O1xuICB9XG59O1xubGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBudWxsO1xuZnVuY3Rpb24gcGFzc2l2ZUV2ZW50U3VwcG9ydGVkKCkge1xuICBpZiAodHlwZW9mIHBhc3NpdmVTdXBwb3J0ZWQgPT09ICdib29sZWFuJykgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG4gIGxldCBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG5vb3AsIG9wdGlvbnMpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0Jywgbm9vcCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICB9XG4gIHBhc3NpdmVTdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xufVxuZnVuY3Rpb24gaXNUb3VjaFN0YXJ0RXZlbnQoZSkge1xuICByZXR1cm4gZS50eXBlID09PSAndG91Y2hzdGFydCc7XG59XG5cbi8vXG5cbmNvbnN0IEV4cGFuZGluZyA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cGFuZGVkOiB7fSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25FeHBhbmRlZENoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignZXhwYW5kZWQnLCB0YWJsZSksXG4gICAgICBwYWdpbmF0ZUV4cGFuZGVkUm93czogdHJ1ZVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgbGV0IHJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICBsZXQgcXVldWVkID0gZmFsc2U7XG4gICAgdGFibGUuX2F1dG9SZXNldEV4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYsIF90YWJsZSRvcHRpb25zJGF1dG9SZTtcbiAgICAgIGlmICghcmVnaXN0ZXJlZCkge1xuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChfcmVmID0gKF90YWJsZSRvcHRpb25zJGF1dG9SZSA9IHRhYmxlLm9wdGlvbnMuYXV0b1Jlc2V0QWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkYXV0b1JlIDogdGFibGUub3B0aW9ucy5hdXRvUmVzZXRFeHBhbmRlZCkgIT0gbnVsbCA/IF9yZWYgOiAhdGFibGUub3B0aW9ucy5tYW51YWxFeHBhbmRpbmcpIHtcbiAgICAgICAgaWYgKHF1ZXVlZCkgcmV0dXJuO1xuICAgICAgICBxdWV1ZWQgPSB0cnVlO1xuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHRhYmxlLnJlc2V0RXhwYW5kZWQoKTtcbiAgICAgICAgICBxdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0YWJsZS5zZXRFeHBhbmRlZCA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkV4cGFuZGVkQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uRXhwYW5kZWRDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUudG9nZ2xlQWxsUm93c0V4cGFuZGVkID0gZXhwYW5kZWQgPT4ge1xuICAgICAgaWYgKGV4cGFuZGVkICE9IG51bGwgPyBleHBhbmRlZCA6ICF0YWJsZS5nZXRJc0FsbFJvd3NFeHBhbmRlZCgpKSB7XG4gICAgICAgIHRhYmxlLnNldEV4cGFuZGVkKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFibGUuc2V0RXhwYW5kZWQoe30pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGFibGUucmVzZXRFeHBhbmRlZCA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRlLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgdGFibGUuc2V0RXhwYW5kZWQoZGVmYXVsdFN0YXRlID8ge30gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRlID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLmV4cGFuZGVkKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRlIDoge30pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0Q2FuU29tZVJvd3NFeHBhbmQgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkuZmxhdFJvd3Muc29tZShyb3cgPT4gcm93LmdldENhbkV4cGFuZCgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFRvZ2dsZUFsbFJvd3NFeHBhbmRlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIGUucGVyc2lzdCA9PSBudWxsIHx8IGUucGVyc2lzdCgpO1xuICAgICAgICB0YWJsZS50b2dnbGVBbGxSb3dzRXhwYW5kZWQoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVSb3dzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBleHBhbmRlZCA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQ7XG4gICAgICByZXR1cm4gZXhwYW5kZWQgPT09IHRydWUgfHwgT2JqZWN0LnZhbHVlcyhleHBhbmRlZCkuc29tZShCb29sZWFuKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzQWxsUm93c0V4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgZXhwYW5kZWQgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkO1xuXG4gICAgICAvLyBJZiBleHBhbmRlZCBpcyB0cnVlLCBzYXZlIHNvbWUgY3ljbGVzIGFuZCByZXR1cm4gdHJ1ZVxuICAgICAgaWYgKHR5cGVvZiBleHBhbmRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBleHBhbmRlZCA9PT0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghT2JqZWN0LmtleXMoZXhwYW5kZWQpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGFueSByb3cgaXMgbm90IGV4cGFuZGVkLCByZXR1cm4gZmFsc2VcbiAgICAgIGlmICh0YWJsZS5nZXRSb3dNb2RlbCgpLmZsYXRSb3dzLnNvbWUocm93ID0+ICFyb3cuZ2V0SXNFeHBhbmRlZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZXkgbXVzdCBhbGwgYmUgZXhwYW5kZWQgOnNocnVnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRFeHBhbmRlZERlcHRoID0gKCkgPT4ge1xuICAgICAgbGV0IG1heERlcHRoID0gMDtcbiAgICAgIGNvbnN0IHJvd0lkcyA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQgPT09IHRydWUgPyBPYmplY3Qua2V5cyh0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3NCeUlkKSA6IE9iamVjdC5rZXlzKHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQpO1xuICAgICAgcm93SWRzLmZvckVhY2goaWQgPT4ge1xuICAgICAgICBjb25zdCBzcGxpdElkID0gaWQuc3BsaXQoJy4nKTtcbiAgICAgICAgbWF4RGVwdGggPSBNYXRoLm1heChtYXhEZXB0aCwgc3BsaXRJZC5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWF4RGVwdGg7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVFeHBhbmRlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0U29ydGVkUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRFeHBhbmRlZFJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEV4cGFuZGVkUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldEV4cGFuZGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEV4cGFuZGVkUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsRXhwYW5kaW5nIHx8ICF0YWJsZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlRXhwYW5kZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRFeHBhbmRlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAocm93LCB0YWJsZSkgPT4ge1xuICAgIHJvdy50b2dnbGVFeHBhbmRlZCA9IGV4cGFuZGVkID0+IHtcbiAgICAgIHRhYmxlLnNldEV4cGFuZGVkKG9sZCA9PiB7XG4gICAgICAgIHZhciBfZXhwYW5kZWQ7XG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IG9sZCA9PT0gdHJ1ZSA/IHRydWUgOiAhIShvbGQgIT0gbnVsbCAmJiBvbGRbcm93LmlkXSk7XG4gICAgICAgIGxldCBvbGRFeHBhbmRlZCA9IHt9O1xuICAgICAgICBpZiAob2xkID09PSB0cnVlKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXModGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzQnlJZCkuZm9yRWFjaChyb3dJZCA9PiB7XG4gICAgICAgICAgICBvbGRFeHBhbmRlZFtyb3dJZF0gPSB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZEV4cGFuZGVkID0gb2xkO1xuICAgICAgICB9XG4gICAgICAgIGV4cGFuZGVkID0gKF9leHBhbmRlZCA9IGV4cGFuZGVkKSAhPSBudWxsID8gX2V4cGFuZGVkIDogIWV4aXN0cztcbiAgICAgICAgaWYgKCFleGlzdHMgJiYgZXhwYW5kZWQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ub2xkRXhwYW5kZWQsXG4gICAgICAgICAgICBbcm93LmlkXTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4aXN0cyAmJiAhZXhwYW5kZWQpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBbcm93LmlkXTogXyxcbiAgICAgICAgICAgIC4uLnJlc3RcbiAgICAgICAgICB9ID0gb2xkRXhwYW5kZWQ7XG4gICAgICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9sZDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcm93LmdldElzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZ2V0SXNSO1xuICAgICAgY29uc3QgZXhwYW5kZWQgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkO1xuICAgICAgcmV0dXJuICEhKChfdGFibGUkb3B0aW9ucyRnZXRJc1IgPSB0YWJsZS5vcHRpb25zLmdldElzUm93RXhwYW5kZWQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuZ2V0SXNSb3dFeHBhbmRlZChyb3cpKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0SXNSIDogZXhwYW5kZWQgPT09IHRydWUgfHwgKGV4cGFuZGVkID09IG51bGwgPyB2b2lkIDAgOiBleHBhbmRlZFtyb3cuaWRdKSk7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuRXhwYW5kID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGdldFJvdywgX3RhYmxlJG9wdGlvbnMkZW5hYmxlLCBfcm93JHN1YlJvd3M7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGdldFJvdyA9IHRhYmxlLm9wdGlvbnMuZ2V0Um93Q2FuRXhwYW5kID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmdldFJvd0NhbkV4cGFuZChyb3cpKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0Um93IDogKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUV4cGFuZGluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmICEhKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoKTtcbiAgICB9O1xuICAgIHJvdy5nZXRJc0FsbFBhcmVudHNFeHBhbmRlZCA9ICgpID0+IHtcbiAgICAgIGxldCBpc0Z1bGx5RXhwYW5kZWQgPSB0cnVlO1xuICAgICAgbGV0IGN1cnJlbnRSb3cgPSByb3c7XG4gICAgICB3aGlsZSAoaXNGdWxseUV4cGFuZGVkICYmIGN1cnJlbnRSb3cucGFyZW50SWQpIHtcbiAgICAgICAgY3VycmVudFJvdyA9IHRhYmxlLmdldFJvdyhjdXJyZW50Um93LnBhcmVudElkLCB0cnVlKTtcbiAgICAgICAgaXNGdWxseUV4cGFuZGVkID0gY3VycmVudFJvdy5nZXRJc0V4cGFuZGVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNGdWxseUV4cGFuZGVkO1xuICAgIH07XG4gICAgcm93LmdldFRvZ2dsZUV4cGFuZGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbkV4cGFuZCA9IHJvdy5nZXRDYW5FeHBhbmQoKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmICghY2FuRXhwYW5kKSByZXR1cm47XG4gICAgICAgIHJvdy50b2dnbGVFeHBhbmRlZCgpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59O1xuXG5jb25zdCBpbmNsdWRlc1N0cmluZyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICB2YXIgX3JvdyRnZXRWYWx1ZTtcbiAgY29uc3Qgc2VhcmNoID0gZmlsdGVyVmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIEJvb2xlYW4oKF9yb3ckZ2V0VmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsIHx8IChfcm93JGdldFZhbHVlID0gX3JvdyRnZXRWYWx1ZS50b1N0cmluZygpKSA9PSBudWxsIHx8IChfcm93JGdldFZhbHVlID0gX3JvdyRnZXRWYWx1ZS50b0xvd2VyQ2FzZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdyRnZXRWYWx1ZS5pbmNsdWRlcyhzZWFyY2gpKTtcbn07XG5pbmNsdWRlc1N0cmluZy5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKTtcbmNvbnN0IGluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHZhciBfcm93JGdldFZhbHVlMjtcbiAgcmV0dXJuIEJvb2xlYW4oKF9yb3ckZ2V0VmFsdWUyID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCB8fCAoX3JvdyRnZXRWYWx1ZTIgPSBfcm93JGdldFZhbHVlMi50b1N0cmluZygpKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdyRnZXRWYWx1ZTIuaW5jbHVkZXMoZmlsdGVyVmFsdWUpKTtcbn07XG5pbmNsdWRlc1N0cmluZ1NlbnNpdGl2ZS5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKTtcbmNvbnN0IGVxdWFsc1N0cmluZyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICB2YXIgX3JvdyRnZXRWYWx1ZTM7XG4gIHJldHVybiAoKF9yb3ckZ2V0VmFsdWUzID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCB8fCAoX3JvdyRnZXRWYWx1ZTMgPSBfcm93JGdldFZhbHVlMy50b1N0cmluZygpKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdyRnZXRWYWx1ZTMudG9Mb3dlckNhc2UoKSkgPT09IChmaWx0ZXJWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogZmlsdGVyVmFsdWUudG9Mb3dlckNhc2UoKSk7XG59O1xuZXF1YWxzU3RyaW5nLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xuY29uc3QgYXJySW5jbHVkZXMgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgdmFyIF9yb3ckZ2V0VmFsdWU0O1xuICByZXR1cm4gKF9yb3ckZ2V0VmFsdWU0ID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWU0LmluY2x1ZGVzKGZpbHRlclZhbHVlKTtcbn07XG5hcnJJbmNsdWRlcy5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKSB8fCAhKHZhbCAhPSBudWxsICYmIHZhbC5sZW5ndGgpO1xuY29uc3QgYXJySW5jbHVkZXNBbGwgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgcmV0dXJuICFmaWx0ZXJWYWx1ZS5zb21lKHZhbCA9PiB7XG4gICAgdmFyIF9yb3ckZ2V0VmFsdWU1O1xuICAgIHJldHVybiAhKChfcm93JGdldFZhbHVlNSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpICE9IG51bGwgJiYgX3JvdyRnZXRWYWx1ZTUuaW5jbHVkZXModmFsKSk7XG4gIH0pO1xufTtcbmFyckluY2x1ZGVzQWxsLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpIHx8ICEodmFsICE9IG51bGwgJiYgdmFsLmxlbmd0aCk7XG5jb25zdCBhcnJJbmNsdWRlc1NvbWUgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgcmV0dXJuIGZpbHRlclZhbHVlLnNvbWUodmFsID0+IHtcbiAgICB2YXIgX3JvdyRnZXRWYWx1ZTY7XG4gICAgcmV0dXJuIChfcm93JGdldFZhbHVlNiA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlNi5pbmNsdWRlcyh2YWwpO1xuICB9KTtcbn07XG5hcnJJbmNsdWRlc1NvbWUuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCkgfHwgISh2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoKTtcbmNvbnN0IGVxdWFscyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICByZXR1cm4gcm93LmdldFZhbHVlKGNvbHVtbklkKSA9PT0gZmlsdGVyVmFsdWU7XG59O1xuZXF1YWxzLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xuY29uc3Qgd2Vha0VxdWFscyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICByZXR1cm4gcm93LmdldFZhbHVlKGNvbHVtbklkKSA9PSBmaWx0ZXJWYWx1ZTtcbn07XG53ZWFrRXF1YWxzLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xuY29uc3QgaW5OdW1iZXJSYW5nZSA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICBsZXQgW21pbiwgbWF4XSA9IGZpbHRlclZhbHVlO1xuICBjb25zdCByb3dWYWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gIHJldHVybiByb3dWYWx1ZSA+PSBtaW4gJiYgcm93VmFsdWUgPD0gbWF4O1xufTtcbmluTnVtYmVyUmFuZ2UucmVzb2x2ZUZpbHRlclZhbHVlID0gdmFsID0+IHtcbiAgbGV0IFt1bnNhZmVNaW4sIHVuc2FmZU1heF0gPSB2YWw7XG4gIGxldCBwYXJzZWRNaW4gPSB0eXBlb2YgdW5zYWZlTWluICE9PSAnbnVtYmVyJyA/IHBhcnNlRmxvYXQodW5zYWZlTWluKSA6IHVuc2FmZU1pbjtcbiAgbGV0IHBhcnNlZE1heCA9IHR5cGVvZiB1bnNhZmVNYXggIT09ICdudW1iZXInID8gcGFyc2VGbG9hdCh1bnNhZmVNYXgpIDogdW5zYWZlTWF4O1xuICBsZXQgbWluID0gdW5zYWZlTWluID09PSBudWxsIHx8IE51bWJlci5pc05hTihwYXJzZWRNaW4pID8gLUluZmluaXR5IDogcGFyc2VkTWluO1xuICBsZXQgbWF4ID0gdW5zYWZlTWF4ID09PSBudWxsIHx8IE51bWJlci5pc05hTihwYXJzZWRNYXgpID8gSW5maW5pdHkgOiBwYXJzZWRNYXg7XG4gIGlmIChtaW4gPiBtYXgpIHtcbiAgICBjb25zdCB0ZW1wID0gbWluO1xuICAgIG1pbiA9IG1heDtcbiAgICBtYXggPSB0ZW1wO1xuICB9XG4gIHJldHVybiBbbWluLCBtYXhdO1xufTtcbmluTnVtYmVyUmFuZ2UuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCkgfHwgdGVzdEZhbHNleSh2YWxbMF0pICYmIHRlc3RGYWxzZXkodmFsWzFdKTtcblxuLy8gRXhwb3J0XG5cbmNvbnN0IGZpbHRlckZucyA9IHtcbiAgaW5jbHVkZXNTdHJpbmcsXG4gIGluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlLFxuICBlcXVhbHNTdHJpbmcsXG4gIGFyckluY2x1ZGVzLFxuICBhcnJJbmNsdWRlc0FsbCxcbiAgYXJySW5jbHVkZXNTb21lLFxuICBlcXVhbHMsXG4gIHdlYWtFcXVhbHMsXG4gIGluTnVtYmVyUmFuZ2Vcbn07XG4vLyBVdGlsc1xuXG5mdW5jdGlvbiB0ZXN0RmFsc2V5KHZhbCkge1xuICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBudWxsIHx8IHZhbCA9PT0gJyc7XG59XG5cbi8vXG5cbmNvbnN0IEZpbHRlcnMgPSB7XG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsdGVyRm46ICdhdXRvJ1xuICAgIH07XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5GaWx0ZXJzOiBbXSxcbiAgICAgIGdsb2JhbEZpbHRlcjogdW5kZWZpbmVkLFxuICAgICAgLy8gZmlsdGVyc1Byb2dyZXNzOiAxLFxuICAgICAgLy8gZmFjZXRQcm9ncmVzczoge30sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ29sdW1uRmlsdGVyc0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uRmlsdGVycycsIHRhYmxlKSxcbiAgICAgIG9uR2xvYmFsRmlsdGVyQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdnbG9iYWxGaWx0ZXInLCB0YWJsZSksXG4gICAgICBmaWx0ZXJGcm9tTGVhZlJvd3M6IGZhbHNlLFxuICAgICAgbWF4TGVhZlJvd0ZpbHRlckRlcHRoOiAxMDAsXG4gICAgICBnbG9iYWxGaWx0ZXJGbjogJ2F1dG8nLFxuICAgICAgZ2V0Q29sdW1uQ2FuR2xvYmFsRmlsdGVyOiBjb2x1bW4gPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJGdldENvcmVSb3dNb2RlO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IChfdGFibGUkZ2V0Q29yZVJvd01vZGUgPSB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKS5mbGF0Um93c1swXSkgPT0gbnVsbCB8fCAoX3RhYmxlJGdldENvcmVSb3dNb2RlID0gX3RhYmxlJGdldENvcmVSb3dNb2RlLl9nZXRBbGxDZWxsc0J5Q29sdW1uSWQoKVtjb2x1bW4uaWRdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENvcmVSb3dNb2RlLmdldFZhbHVlKCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi5nZXRBdXRvRmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFJvdyA9IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpLmZsYXRSb3dzWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBmaXJzdFJvdyA9PSBudWxsID8gdm9pZCAwIDogZmlyc3RSb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJGbnMuaW5jbHVkZXNTdHJpbmc7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmluTnVtYmVyUmFuZ2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5lcXVhbHM7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmVxdWFscztcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmFyckluY2x1ZGVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbHRlckZucy53ZWFrRXF1YWxzO1xuICAgIH07XG4gICAgY29sdW1uLmdldEZpbHRlckZuID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGZpbHRlciwgX3RhYmxlJG9wdGlvbnMkZmlsdGVyMjtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGNvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm4pID8gY29sdW1uLmNvbHVtbkRlZi5maWx0ZXJGbiA6IGNvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm4gPT09ICdhdXRvJyA/IGNvbHVtbi5nZXRBdXRvRmlsdGVyRm4oKSA6IC8vIEB0cy1pZ25vcmVcbiAgICAgIChfdGFibGUkb3B0aW9ucyRmaWx0ZXIgPSAoX3RhYmxlJG9wdGlvbnMkZmlsdGVyMiA9IHRhYmxlLm9wdGlvbnMuZmlsdGVyRm5zKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJG9wdGlvbnMkZmlsdGVyMltjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuXSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGZpbHRlciA6IGZpbHRlckZuc1tjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuXTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5GaWx0ZXIgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGUsIF90YWJsZSRvcHRpb25zJGVuYWJsZTI7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUNvbHVtbkZpbHRlcikgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVDb2x1bW5GaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUyID0gdGFibGUub3B0aW9ucy5lbmFibGVGaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA6IHRydWUpICYmICEhY29sdW1uLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuR2xvYmFsRmlsdGVyID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJGVuYTIsIF90YWJsZSRvcHRpb25zJGVuYWJsZTMsIF90YWJsZSRvcHRpb25zJGVuYWJsZTQsIF90YWJsZSRvcHRpb25zJGdldENvbDtcbiAgICAgIHJldHVybiAoKF9jb2x1bW4kY29sdW1uRGVmJGVuYTIgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUdsb2JhbEZpbHRlcikgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYTIgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZTMgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUdsb2JhbEZpbHRlcikgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTMgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZTQgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUZpbHRlcnMpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGU0IDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRnZXRDb2wgPSB0YWJsZS5vcHRpb25zLmdldENvbHVtbkNhbkdsb2JhbEZpbHRlciA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5nZXRDb2x1bW5DYW5HbG9iYWxGaWx0ZXIoY29sdW1uKSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGdldENvbCA6IHRydWUpICYmICEhY29sdW1uLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNGaWx0ZXJlZCA9ICgpID0+IGNvbHVtbi5nZXRGaWx0ZXJJbmRleCgpID4gLTE7XG4gICAgY29sdW1uLmdldEZpbHRlclZhbHVlID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGNvbHVtID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzKSA9PSBudWxsIHx8IChfdGFibGUkZ2V0U3RhdGUkY29sdW0gPSBfdGFibGUkZ2V0U3RhdGUkY29sdW0uZmluZChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkY29sdW0udmFsdWU7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0RmlsdGVySW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJGNvbHVtMiwgX3RhYmxlJGdldFN0YXRlJGNvbHVtMztcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGNvbHVtMiA9IChfdGFibGUkZ2V0U3RhdGUkY29sdW0zID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJGNvbHVtMy5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpKSAhPSBudWxsID8gX3RhYmxlJGdldFN0YXRlJGNvbHVtMiA6IC0xO1xuICAgIH07XG4gICAgY29sdW1uLnNldEZpbHRlclZhbHVlID0gdmFsdWUgPT4ge1xuICAgICAgdGFibGUuc2V0Q29sdW1uRmlsdGVycyhvbGQgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJGbiA9IGNvbHVtbi5nZXRGaWx0ZXJGbigpO1xuICAgICAgICBjb25zdCBwcmV2aW91c2ZpbHRlciA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpO1xuICAgICAgICBjb25zdCBuZXdGaWx0ZXIgPSBmdW5jdGlvbmFsVXBkYXRlKHZhbHVlLCBwcmV2aW91c2ZpbHRlciA/IHByZXZpb3VzZmlsdGVyLnZhbHVlIDogdW5kZWZpbmVkKTtcblxuICAgICAgICAvL1xuICAgICAgICBpZiAoc2hvdWxkQXV0b1JlbW92ZUZpbHRlcihmaWx0ZXJGbiwgbmV3RmlsdGVyLCBjb2x1bW4pKSB7XG4gICAgICAgICAgdmFyIF9vbGQkZmlsdGVyO1xuICAgICAgICAgIHJldHVybiAoX29sZCRmaWx0ZXIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5maWx0ZXIoZCA9PiBkLmlkICE9PSBjb2x1bW4uaWQpKSAhPSBudWxsID8gX29sZCRmaWx0ZXIgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdGaWx0ZXJPYmogPSB7XG4gICAgICAgICAgaWQ6IGNvbHVtbi5pZCxcbiAgICAgICAgICB2YWx1ZTogbmV3RmlsdGVyXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcmV2aW91c2ZpbHRlcikge1xuICAgICAgICAgIHZhciBfb2xkJG1hcDtcbiAgICAgICAgICByZXR1cm4gKF9vbGQkbWFwID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubWFwKGQgPT4ge1xuICAgICAgICAgICAgaWYgKGQuaWQgPT09IGNvbHVtbi5pZCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3RmlsdGVyT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgfSkpICE9IG51bGwgPyBfb2xkJG1hcCA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGQgIT0gbnVsbCAmJiBvbGQubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIFsuLi5vbGQsIG5ld0ZpbHRlck9ial07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtuZXdGaWx0ZXJPYmpdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uX2dldEZhY2V0ZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsKHRhYmxlLCBjb2x1bW4uaWQpO1xuICAgIGNvbHVtbi5nZXRGYWNldGVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIWNvbHVtbi5fZ2V0RmFjZXRlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sdW1uLl9nZXRGYWNldGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICAgIGNvbHVtbi5fZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXModGFibGUsIGNvbHVtbi5pZCk7XG4gICAgY29sdW1uLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoIWNvbHVtbi5fZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbHVtbi5fZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcygpO1xuICAgIH07XG4gICAgY29sdW1uLl9nZXRGYWNldGVkTWluTWF4VmFsdWVzID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkTWluTWF4VmFsdWVzICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyh0YWJsZSwgY29sdW1uLmlkKTtcbiAgICBjb2x1bW4uZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyA9ICgpID0+IHtcbiAgICAgIGlmICghY29sdW1uLl9nZXRGYWNldGVkTWluTWF4VmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sdW1uLl9nZXRGYWNldGVkTWluTWF4VmFsdWVzKCk7XG4gICAgfTtcbiAgICAvLyAoKSA9PiBbY29sdW1uLmdldEZhY2V0ZWRSb3dNb2RlbCgpXSxcbiAgICAvLyBmYWNldGVkUm93TW9kZWwgPT4gZ2V0Um93TW9kZWxNaW5NYXhWYWx1ZXMoZmFjZXRlZFJvd01vZGVsLCBjb2x1bW4uaWQpLFxuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LmNvbHVtbkZpbHRlcnMgPSB7fTtcbiAgICByb3cuY29sdW1uRmlsdGVyc01ldGEgPSB7fTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5nZXRHbG9iYWxBdXRvRmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZmlsdGVyRm5zLmluY2x1ZGVzU3RyaW5nO1xuICAgIH07XG4gICAgdGFibGUuZ2V0R2xvYmFsRmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZmlsdGVyMywgX3RhYmxlJG9wdGlvbnMkZmlsdGVyNDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZ2xvYmFsRmlsdGVyRm46IGdsb2JhbEZpbHRlckZuXG4gICAgICB9ID0gdGFibGUub3B0aW9ucztcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGdsb2JhbEZpbHRlckZuKSA/IGdsb2JhbEZpbHRlckZuIDogZ2xvYmFsRmlsdGVyRm4gPT09ICdhdXRvJyA/IHRhYmxlLmdldEdsb2JhbEF1dG9GaWx0ZXJGbigpIDogLy8gQHRzLWlnbm9yZVxuICAgICAgKF90YWJsZSRvcHRpb25zJGZpbHRlcjMgPSAoX3RhYmxlJG9wdGlvbnMkZmlsdGVyNCA9IHRhYmxlLm9wdGlvbnMuZmlsdGVyRm5zKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJG9wdGlvbnMkZmlsdGVyNFtnbG9iYWxGaWx0ZXJGbl0pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRmaWx0ZXIzIDogZmlsdGVyRm5zW2dsb2JhbEZpbHRlckZuXTtcbiAgICB9O1xuICAgIHRhYmxlLnNldENvbHVtbkZpbHRlcnMgPSB1cGRhdGVyID0+IHtcbiAgICAgIGNvbnN0IGxlYWZDb2x1bW5zID0gdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKTtcbiAgICAgIGNvbnN0IHVwZGF0ZUZuID0gb2xkID0+IHtcbiAgICAgICAgdmFyIF9mdW5jdGlvbmFsVXBkYXRlO1xuICAgICAgICByZXR1cm4gKF9mdW5jdGlvbmFsVXBkYXRlID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBvbGQpKSA9PSBudWxsID8gdm9pZCAwIDogX2Z1bmN0aW9uYWxVcGRhdGUuZmlsdGVyKGZpbHRlciA9PiB7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGZpbHRlci5pZCk7XG4gICAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyRm4gPSBjb2x1bW4uZ2V0RmlsdGVyRm4oKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRBdXRvUmVtb3ZlRmlsdGVyKGZpbHRlckZuLCBmaWx0ZXIudmFsdWUsIGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdGFibGUub3B0aW9ucy5vbkNvbHVtbkZpbHRlcnNDaGFuZ2UgPT0gbnVsbCB8fCB0YWJsZS5vcHRpb25zLm9uQ29sdW1uRmlsdGVyc0NoYW5nZSh1cGRhdGVGbik7XG4gICAgfTtcbiAgICB0YWJsZS5zZXRHbG9iYWxGaWx0ZXIgPSB1cGRhdGVyID0+IHtcbiAgICAgIHRhYmxlLm9wdGlvbnMub25HbG9iYWxGaWx0ZXJDaGFuZ2UgPT0gbnVsbCB8fCB0YWJsZS5vcHRpb25zLm9uR2xvYmFsRmlsdGVyQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRHbG9iYWxGaWx0ZXIgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdGFibGUuc2V0R2xvYmFsRmlsdGVyKGRlZmF1bHRTdGF0ZSA/IHVuZGVmaW5lZCA6IHRhYmxlLmluaXRpYWxTdGF0ZS5nbG9iYWxGaWx0ZXIpO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRDb2x1bW5GaWx0ZXJzID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGMsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5GaWx0ZXJzKGRlZmF1bHRTdGF0ZSA/IFtdIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5jb2x1bW5GaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRGaWx0ZXJlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmlsdGVyZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0RmlsdGVyZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RmlsdGVyZWRSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxGaWx0ZXJpbmcgfHwgIXRhYmxlLl9nZXRGaWx0ZXJlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldEZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICB9O1xuICAgIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCh0YWJsZSwgJ19fZ2xvYmFsX18nKTtcbiAgICB0YWJsZS5nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxGaWx0ZXJpbmcgfHwgIXRhYmxlLl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgICB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXModGFibGUsICdfX2dsb2JhbF9fJyk7XG4gICAgdGFibGUuZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcygpO1xuICAgIH07XG4gICAgdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkTWluTWF4VmFsdWVzKHRhYmxlLCAnX19nbG9iYWxfXycpO1xuICAgIHRhYmxlLmdldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcygpO1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBzaG91bGRBdXRvUmVtb3ZlRmlsdGVyKGZpbHRlckZuLCB2YWx1ZSwgY29sdW1uKSB7XG4gIHJldHVybiAoZmlsdGVyRm4gJiYgZmlsdGVyRm4uYXV0b1JlbW92ZSA/IGZpbHRlckZuLmF1dG9SZW1vdmUodmFsdWUsIGNvbHVtbikgOiBmYWxzZSkgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICF2YWx1ZTtcbn1cblxuY29uc3Qgc3VtID0gKGNvbHVtbklkLCBfbGVhZlJvd3MsIGNoaWxkUm93cykgPT4ge1xuICAvLyBJdCdzIGZhc3RlciB0byBqdXN0IGFkZCB0aGUgYWdncmVnYXRpb25zIHRvZ2V0aGVyIGluc3RlYWQgb2ZcbiAgLy8gcHJvY2VzcyBsZWFmIG5vZGVzIGluZGl2aWR1YWxseVxuICByZXR1cm4gY2hpbGRSb3dzLnJlZHVjZSgoc3VtLCBuZXh0KSA9PiB7XG4gICAgY29uc3QgbmV4dFZhbHVlID0gbmV4dC5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgcmV0dXJuIHN1bSArICh0eXBlb2YgbmV4dFZhbHVlID09PSAnbnVtYmVyJyA/IG5leHRWYWx1ZSA6IDApO1xuICB9LCAwKTtcbn07XG5jb25zdCBtaW4gPSAoY29sdW1uSWQsIF9sZWFmUm93cywgY2hpbGRSb3dzKSA9PiB7XG4gIGxldCBtaW47XG4gIGNoaWxkUm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIChtaW4gPiB2YWx1ZSB8fCBtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpIHtcbiAgICAgIG1pbiA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtaW47XG59O1xuY29uc3QgbWF4ID0gKGNvbHVtbklkLCBfbGVhZlJvd3MsIGNoaWxkUm93cykgPT4ge1xuICBsZXQgbWF4O1xuICBjaGlsZFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAobWF4IDwgdmFsdWUgfHwgbWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSB7XG4gICAgICBtYXggPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWF4O1xufTtcbmNvbnN0IGV4dGVudCA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcbiAgbGV0IG1pbjtcbiAgbGV0IG1heDtcbiAgY2hpbGRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodmFsdWUgPj0gdmFsdWUpIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1pbiA+IHZhbHVlKSBtaW4gPSB2YWx1ZTtcbiAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gW21pbiwgbWF4XTtcbn07XG5jb25zdCBtZWFuID0gKGNvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgc3VtID0gMDtcbiAgbGVhZlJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIGxldCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgKytjb3VudCwgc3VtICs9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIGlmIChjb3VudCkgcmV0dXJuIHN1bSAvIGNvdW50O1xuICByZXR1cm47XG59O1xuY29uc3QgbWVkaWFuID0gKGNvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICBpZiAoIWxlYWZSb3dzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB2YWx1ZXMgPSBsZWFmUm93cy5tYXAocm93ID0+IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpO1xuICBpZiAoIWlzTnVtYmVyQXJyYXkodmFsdWVzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB2YWx1ZXNbMF07XG4gIH1cbiAgY29uc3QgbWlkID0gTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoIC8gMik7XG4gIGNvbnN0IG51bXMgPSB2YWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICByZXR1cm4gdmFsdWVzLmxlbmd0aCAlIDIgIT09IDAgPyBudW1zW21pZF0gOiAobnVtc1ttaWQgLSAxXSArIG51bXNbbWlkXSkgLyAyO1xufTtcbmNvbnN0IHVuaXF1ZSA9IChjb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChsZWFmUm93cy5tYXAoZCA9PiBkLmdldFZhbHVlKGNvbHVtbklkKSkpLnZhbHVlcygpKTtcbn07XG5jb25zdCB1bmlxdWVDb3VudCA9IChjb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgcmV0dXJuIG5ldyBTZXQobGVhZlJvd3MubWFwKGQgPT4gZC5nZXRWYWx1ZShjb2x1bW5JZCkpKS5zaXplO1xufTtcbmNvbnN0IGNvdW50ID0gKF9jb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgcmV0dXJuIGxlYWZSb3dzLmxlbmd0aDtcbn07XG5jb25zdCBhZ2dyZWdhdGlvbkZucyA9IHtcbiAgc3VtLFxuICBtaW4sXG4gIG1heCxcbiAgZXh0ZW50LFxuICBtZWFuLFxuICBtZWRpYW4sXG4gIHVuaXF1ZSxcbiAgdW5pcXVlQ291bnQsXG4gIGNvdW50XG59O1xuXG4vL1xuXG5jb25zdCBHcm91cGluZyA9IHtcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBhZ2dyZWdhdGVkQ2VsbDogcHJvcHMgPT4ge1xuICAgICAgICB2YXIgX3RvU3RyaW5nLCBfcHJvcHMkZ2V0VmFsdWU7XG4gICAgICAgIHJldHVybiAoX3RvU3RyaW5nID0gKF9wcm9wcyRnZXRWYWx1ZSA9IHByb3BzLmdldFZhbHVlKCkpID09IG51bGwgfHwgX3Byb3BzJGdldFZhbHVlLnRvU3RyaW5nID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkZ2V0VmFsdWUudG9TdHJpbmcoKSkgIT0gbnVsbCA/IF90b1N0cmluZyA6IG51bGw7XG4gICAgICB9LFxuICAgICAgYWdncmVnYXRpb25GbjogJ2F1dG8nXG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdyb3VwaW5nOiBbXSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Hcm91cGluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignZ3JvdXBpbmcnLCB0YWJsZSksXG4gICAgICBncm91cGVkQ29sdW1uTW9kZTogJ3Jlb3JkZXInXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi50b2dnbGVHcm91cGluZyA9ICgpID0+IHtcbiAgICAgIHRhYmxlLnNldEdyb3VwaW5nKG9sZCA9PiB7XG4gICAgICAgIC8vIEZpbmQgYW55IGV4aXN0aW5nIGdyb3VwaW5nIGZvciB0aGlzIGNvbHVtblxuICAgICAgICBpZiAob2xkICE9IG51bGwgJiYgb2xkLmluY2x1ZGVzKGNvbHVtbi5pZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkLmZpbHRlcihkID0+IGQgIT09IGNvbHVtbi5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsuLi4ob2xkICE9IG51bGwgPyBvbGQgOiBbXSksIGNvbHVtbi5pZF07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5Hcm91cCA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmLCBfcmVmMiwgX3JlZjMsIF9jb2x1bW4kY29sdW1uRGVmJGVuYTtcbiAgICAgIHJldHVybiAoX3JlZiA9IChfcmVmMiA9IChfcmVmMyA9IChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUdyb3VwaW5nKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgIT0gbnVsbCA/IF9yZWYzIDogdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZykgIT0gbnVsbCA/IF9yZWYyIDogdHJ1ZSkgIT0gbnVsbCA/IF9yZWYgOiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzR3JvdXBlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkZ3JvdXA7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRncm91cCA9IHRhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkZ3JvdXAuaW5jbHVkZXMoY29sdW1uLmlkKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRHcm91cGVkSW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJGdyb3VwMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGdyb3VwMiA9IHRhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkZ3JvdXAyLmluZGV4T2YoY29sdW1uLmlkKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRUb2dnbGVHcm91cGluZ0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYW5Hcm91cCA9IGNvbHVtbi5nZXRDYW5Hcm91cCgpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCFjYW5Hcm91cCkgcmV0dXJuO1xuICAgICAgICBjb2x1bW4udG9nZ2xlR3JvdXBpbmcoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0QXV0b0FnZ3JlZ2F0aW9uRm4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFJvdyA9IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpLmZsYXRSb3dzWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBmaXJzdFJvdyA9PSBudWxsID8gdm9pZCAwIDogZmlyc3RSb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBhZ2dyZWdhdGlvbkZucy5zdW07XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgICAgIHJldHVybiBhZ2dyZWdhdGlvbkZucy5leHRlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0QWdncmVnYXRpb25GbiA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRhZ2dyZWcsIF90YWJsZSRvcHRpb25zJGFnZ3JlZzI7XG4gICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGNvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25GbikgPyBjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm4gOiBjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm4gPT09ICdhdXRvJyA/IGNvbHVtbi5nZXRBdXRvQWdncmVnYXRpb25GbigpIDogKF90YWJsZSRvcHRpb25zJGFnZ3JlZyA9IChfdGFibGUkb3B0aW9ucyRhZ2dyZWcyID0gdGFibGUub3B0aW9ucy5hZ2dyZWdhdGlvbkZucykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRvcHRpb25zJGFnZ3JlZzJbY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuXSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGFnZ3JlZyA6IGFnZ3JlZ2F0aW9uRm5zW2NvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25Gbl07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRHcm91cGluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkdyb3VwaW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uR3JvdXBpbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRHcm91cGluZyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRnLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgdGFibGUuc2V0R3JvdXBpbmcoZGVmYXVsdFN0YXRlID8gW10gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRnID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLmdyb3VwaW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRnIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlR3JvdXBlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldEdyb3VwZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEdyb3VwZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEdyb3VwZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0R3JvdXBlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRHcm91cGVkUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsR3JvdXBpbmcgfHwgIXRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUdyb3VwZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LmdldElzR3JvdXBlZCA9ICgpID0+ICEhcm93Lmdyb3VwaW5nQ29sdW1uSWQ7XG4gICAgcm93LmdldEdyb3VwaW5nVmFsdWUgPSBjb2x1bW5JZCA9PiB7XG4gICAgICBpZiAocm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCk7XG4gICAgICBpZiAoIShjb2x1bW4gIT0gbnVsbCAmJiBjb2x1bW4uY29sdW1uRGVmLmdldEdyb3VwaW5nVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgICAgfVxuICAgICAgcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IGNvbHVtbi5jb2x1bW5EZWYuZ2V0R3JvdXBpbmdWYWx1ZShyb3cub3JpZ2luYWwpO1xuICAgICAgcmV0dXJuIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgfTtcbiAgICByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGUgPSB7fTtcbiAgfSxcbiAgY3JlYXRlQ2VsbDogKGNlbGwsIGNvbHVtbiwgcm93LCB0YWJsZSkgPT4ge1xuICAgIGNlbGwuZ2V0SXNHcm91cGVkID0gKCkgPT4gY29sdW1uLmdldElzR3JvdXBlZCgpICYmIGNvbHVtbi5pZCA9PT0gcm93Lmdyb3VwaW5nQ29sdW1uSWQ7XG4gICAgY2VsbC5nZXRJc1BsYWNlaG9sZGVyID0gKCkgPT4gIWNlbGwuZ2V0SXNHcm91cGVkKCkgJiYgY29sdW1uLmdldElzR3JvdXBlZCgpO1xuICAgIGNlbGwuZ2V0SXNBZ2dyZWdhdGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF9yb3ckc3ViUm93cztcbiAgICAgIHJldHVybiAhY2VsbC5nZXRJc0dyb3VwZWQoKSAmJiAhY2VsbC5nZXRJc1BsYWNlaG9sZGVyKCkgJiYgISEoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGgpO1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBvcmRlckNvbHVtbnMobGVhZkNvbHVtbnMsIGdyb3VwaW5nLCBncm91cGVkQ29sdW1uTW9kZSkge1xuICBpZiAoIShncm91cGluZyAhPSBudWxsICYmIGdyb3VwaW5nLmxlbmd0aCkgfHwgIWdyb3VwZWRDb2x1bW5Nb2RlKSB7XG4gICAgcmV0dXJuIGxlYWZDb2x1bW5zO1xuICB9XG4gIGNvbnN0IG5vbkdyb3VwaW5nQ29sdW1ucyA9IGxlYWZDb2x1bW5zLmZpbHRlcihjb2wgPT4gIWdyb3VwaW5nLmluY2x1ZGVzKGNvbC5pZCkpO1xuICBpZiAoZ3JvdXBlZENvbHVtbk1vZGUgPT09ICdyZW1vdmUnKSB7XG4gICAgcmV0dXJuIG5vbkdyb3VwaW5nQ29sdW1ucztcbiAgfVxuICBjb25zdCBncm91cGluZ0NvbHVtbnMgPSBncm91cGluZy5tYXAoZyA9PiBsZWFmQ29sdW1ucy5maW5kKGNvbCA9PiBjb2wuaWQgPT09IGcpKS5maWx0ZXIoQm9vbGVhbik7XG4gIHJldHVybiBbLi4uZ3JvdXBpbmdDb2x1bW5zLCAuLi5ub25Hcm91cGluZ0NvbHVtbnNdO1xufVxuXG4vL1xuXG5jb25zdCBPcmRlcmluZyA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtbk9yZGVyOiBbXSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Db2x1bW5PcmRlckNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uT3JkZXInLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLmdldEluZGV4ID0gbWVtbyhwb3NpdGlvbiA9PiBbX2dldFZpc2libGVMZWFmQ29sdW1ucyh0YWJsZSwgcG9zaXRpb24pXSwgY29sdW1ucyA9PiBjb2x1bW5zLmZpbmRJbmRleChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCksIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0SW5kZXgnKSk7XG4gICAgY29sdW1uLmdldElzRmlyc3RDb2x1bW4gPSBwb3NpdGlvbiA9PiB7XG4gICAgICB2YXIgX2NvbHVtbnMkO1xuICAgICAgY29uc3QgY29sdW1ucyA9IF9nZXRWaXNpYmxlTGVhZkNvbHVtbnModGFibGUsIHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiAoKF9jb2x1bW5zJCA9IGNvbHVtbnNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfY29sdW1ucyQuaWQpID09PSBjb2x1bW4uaWQ7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNMYXN0Q29sdW1uID0gcG9zaXRpb24gPT4ge1xuICAgICAgdmFyIF9jb2x1bW5zO1xuICAgICAgY29uc3QgY29sdW1ucyA9IF9nZXRWaXNpYmxlTGVhZkNvbHVtbnModGFibGUsIHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiAoKF9jb2x1bW5zID0gY29sdW1uc1tjb2x1bW5zLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbHVtbnMuaWQpID09PSBjb2x1bW4uaWQ7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRDb2x1bW5PcmRlciA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtbk9yZGVyQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uT3JkZXJDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRDb2x1bW5PcmRlciA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjO1xuICAgICAgdGFibGUuc2V0Q29sdW1uT3JkZXIoZGVmYXVsdFN0YXRlID8gW10gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjID0gdGFibGUuaW5pdGlhbFN0YXRlLmNvbHVtbk9yZGVyKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuX2dldE9yZGVyQ29sdW1uc0ZuID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5PcmRlciwgdGFibGUuZ2V0U3RhdGUoKS5ncm91cGluZywgdGFibGUub3B0aW9ucy5ncm91cGVkQ29sdW1uTW9kZV0sIChjb2x1bW5PcmRlciwgZ3JvdXBpbmcsIGdyb3VwZWRDb2x1bW5Nb2RlKSA9PiBjb2x1bW5zID0+IHtcbiAgICAgIC8vIFNvcnQgZ3JvdXBlZCBjb2x1bW5zIHRvIHRoZSBzdGFydCBvZiB0aGUgY29sdW1uIGxpc3RcbiAgICAgIC8vIGJlZm9yZSB0aGUgaGVhZGVycyBhcmUgYnVpbHRcbiAgICAgIGxldCBvcmRlcmVkQ29sdW1ucyA9IFtdO1xuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBvcmRlciwgcmV0dXJuIHRoZSBub3JtYWwgY29sdW1uc1xuICAgICAgaWYgKCEoY29sdW1uT3JkZXIgIT0gbnVsbCAmJiBjb2x1bW5PcmRlci5sZW5ndGgpKSB7XG4gICAgICAgIG9yZGVyZWRDb2x1bW5zID0gY29sdW1ucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbk9yZGVyQ29weSA9IFsuLi5jb2x1bW5PcmRlcl07XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gb3JkZXIsIG1ha2UgYSBjb3B5IG9mIHRoZSBjb2x1bW5zXG4gICAgICAgIGNvbnN0IGNvbHVtbnNDb3B5ID0gWy4uLmNvbHVtbnNdO1xuXG4gICAgICAgIC8vIEFuZCBtYWtlIGEgbmV3IG9yZGVyZWQgYXJyYXkgb2YgdGhlIGNvbHVtbnNcblxuICAgICAgICAvLyBMb29wIG92ZXIgdGhlIGNvbHVtbnMgYW5kIHBsYWNlIHRoZW0gaW4gb3JkZXIgaW50byB0aGUgbmV3IGFycmF5XG4gICAgICAgIHdoaWxlIChjb2x1bW5zQ29weS5sZW5ndGggJiYgY29sdW1uT3JkZXJDb3B5Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHRhcmdldENvbHVtbklkID0gY29sdW1uT3JkZXJDb3B5LnNoaWZ0KCk7XG4gICAgICAgICAgY29uc3QgZm91bmRJbmRleCA9IGNvbHVtbnNDb3B5LmZpbmRJbmRleChkID0+IGQuaWQgPT09IHRhcmdldENvbHVtbklkKTtcbiAgICAgICAgICBpZiAoZm91bmRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBvcmRlcmVkQ29sdW1ucy5wdXNoKGNvbHVtbnNDb3B5LnNwbGljZShmb3VuZEluZGV4LCAxKVswXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGFueSBjb2x1bW5zIGxlZnQsIGFkZCB0aGVtIHRvIHRoZSBlbmRcbiAgICAgICAgb3JkZXJlZENvbHVtbnMgPSBbLi4ub3JkZXJlZENvbHVtbnMsIC4uLmNvbHVtbnNDb3B5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmRlckNvbHVtbnMob3JkZXJlZENvbHVtbnMsIGdyb3VwaW5nLCBncm91cGVkQ29sdW1uTW9kZSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnX2dldE9yZGVyQ29sdW1uc0ZuJykpO1xuICB9XG59O1xuXG4vL1xuXG5jb25zdCBkZWZhdWx0UGFnZUluZGV4ID0gMDtcbmNvbnN0IGRlZmF1bHRQYWdlU2l6ZSA9IDEwO1xuY29uc3QgZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSA9ICgpID0+ICh7XG4gIHBhZ2VJbmRleDogZGVmYXVsdFBhZ2VJbmRleCxcbiAgcGFnZVNpemU6IGRlZmF1bHRQYWdlU2l6ZVxufSk7XG5jb25zdCBQYWdpbmF0aW9uID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgIC4uLmdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUoKSxcbiAgICAgICAgLi4uKHN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5wYWdpbmF0aW9uKVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uUGFnaW5hdGlvbkNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcigncGFnaW5hdGlvbicsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgbGV0IHJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICBsZXQgcXVldWVkID0gZmFsc2U7XG4gICAgdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmLCBfdGFibGUkb3B0aW9ucyRhdXRvUmU7XG4gICAgICBpZiAoIXJlZ2lzdGVyZWQpIHtcbiAgICAgICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgICAgICByZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgoX3JlZiA9IChfdGFibGUkb3B0aW9ucyRhdXRvUmUgPSB0YWJsZS5vcHRpb25zLmF1dG9SZXNldEFsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGF1dG9SZSA6IHRhYmxlLm9wdGlvbnMuYXV0b1Jlc2V0UGFnZUluZGV4KSAhPSBudWxsID8gX3JlZiA6ICF0YWJsZS5vcHRpb25zLm1hbnVhbFBhZ2luYXRpb24pIHtcbiAgICAgICAgaWYgKHF1ZXVlZCkgcmV0dXJuO1xuICAgICAgICBxdWV1ZWQgPSB0cnVlO1xuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHRhYmxlLnJlc2V0UGFnZUluZGV4KCk7XG4gICAgICAgICAgcXVldWVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGFibGUuc2V0UGFnaW5hdGlvbiA9IHVwZGF0ZXIgPT4ge1xuICAgICAgY29uc3Qgc2FmZVVwZGF0ZXIgPSBvbGQgPT4ge1xuICAgICAgICBsZXQgbmV3U3RhdGUgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZCk7XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5vblBhZ2luYXRpb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25QYWdpbmF0aW9uQ2hhbmdlKHNhZmVVcGRhdGVyKTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0UGFnaW5hdGlvbiA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRwO1xuICAgICAgdGFibGUuc2V0UGFnaW5hdGlvbihkZWZhdWx0U3RhdGUgPyBnZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlKCkgOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRwID0gdGFibGUuaW5pdGlhbFN0YXRlLnBhZ2luYXRpb24pICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHAgOiBnZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlKCkpO1xuICAgIH07XG4gICAgdGFibGUuc2V0UGFnZUluZGV4ID0gdXBkYXRlciA9PiB7XG4gICAgICB0YWJsZS5zZXRQYWdpbmF0aW9uKG9sZCA9PiB7XG4gICAgICAgIGxldCBwYWdlSW5kZXggPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZC5wYWdlSW5kZXgpO1xuICAgICAgICBjb25zdCBtYXhQYWdlSW5kZXggPSB0eXBlb2YgdGFibGUub3B0aW9ucy5wYWdlQ291bnQgPT09ICd1bmRlZmluZWQnIHx8IHRhYmxlLm9wdGlvbnMucGFnZUNvdW50ID09PSAtMSA/IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIDogdGFibGUub3B0aW9ucy5wYWdlQ291bnQgLSAxO1xuICAgICAgICBwYWdlSW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlSW5kZXgsIG1heFBhZ2VJbmRleCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICBwYWdlSW5kZXhcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRQYWdlSW5kZXggPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcDIsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRQYWdlSW5kZXgoZGVmYXVsdFN0YXRlID8gZGVmYXVsdFBhZ2VJbmRleCA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHAyID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgfHwgKF90YWJsZSRpbml0aWFsU3RhdGUgPSBfdGFibGUkaW5pdGlhbFN0YXRlLnBhZ2luYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLnBhZ2VJbmRleCkgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkcDIgOiBkZWZhdWx0UGFnZUluZGV4KTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0UGFnZVNpemUgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcDMsIF90YWJsZSRpbml0aWFsU3RhdGUyO1xuICAgICAgdGFibGUuc2V0UGFnZVNpemUoZGVmYXVsdFN0YXRlID8gZGVmYXVsdFBhZ2VTaXplIDogKF90YWJsZSRpbml0aWFsU3RhdGUkcDMgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZTIgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgfHwgKF90YWJsZSRpbml0aWFsU3RhdGUyID0gX3RhYmxlJGluaXRpYWxTdGF0ZTIucGFnaW5hdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUyLnBhZ2VTaXplKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRwMyA6IGRlZmF1bHRQYWdlU2l6ZSk7XG4gICAgfTtcbiAgICB0YWJsZS5zZXRQYWdlU2l6ZSA9IHVwZGF0ZXIgPT4ge1xuICAgICAgdGFibGUuc2V0UGFnaW5hdGlvbihvbGQgPT4ge1xuICAgICAgICBjb25zdCBwYWdlU2l6ZSA9IE1hdGgubWF4KDEsIGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkLnBhZ2VTaXplKSk7XG4gICAgICAgIGNvbnN0IHRvcFJvd0luZGV4ID0gb2xkLnBhZ2VTaXplICogb2xkLnBhZ2VJbmRleDtcbiAgICAgICAgY29uc3QgcGFnZUluZGV4ID0gTWF0aC5mbG9vcih0b3BSb3dJbmRleCAvIHBhZ2VTaXplKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgcGFnZUluZGV4LFxuICAgICAgICAgIHBhZ2VTaXplXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8vZGVwcmVjYXRlZFxuICAgIHRhYmxlLnNldFBhZ2VDb3VudCA9IHVwZGF0ZXIgPT4gdGFibGUuc2V0UGFnaW5hdGlvbihvbGQgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHBhZ2VDbztcbiAgICAgIGxldCBuZXdQYWdlQ291bnQgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIChfdGFibGUkb3B0aW9ucyRwYWdlQ28gPSB0YWJsZS5vcHRpb25zLnBhZ2VDb3VudCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJHBhZ2VDbyA6IC0xKTtcbiAgICAgIGlmICh0eXBlb2YgbmV3UGFnZUNvdW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICBuZXdQYWdlQ291bnQgPSBNYXRoLm1heCgtMSwgbmV3UGFnZUNvdW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9sZCxcbiAgICAgICAgcGFnZUNvdW50OiBuZXdQYWdlQ291bnRcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0UGFnZU9wdGlvbnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRQYWdlQ291bnQoKV0sIHBhZ2VDb3VudCA9PiB7XG4gICAgICBsZXQgcGFnZU9wdGlvbnMgPSBbXTtcbiAgICAgIGlmIChwYWdlQ291bnQgJiYgcGFnZUNvdW50ID4gMCkge1xuICAgICAgICBwYWdlT3B0aW9ucyA9IFsuLi5uZXcgQXJyYXkocGFnZUNvdW50KV0uZmlsbChudWxsKS5tYXAoKF8sIGkpID0+IGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhZ2VPcHRpb25zO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldFBhZ2VPcHRpb25zJykpO1xuICAgIHRhYmxlLmdldENhblByZXZpb3VzUGFnZSA9ICgpID0+IHRhYmxlLmdldFN0YXRlKCkucGFnaW5hdGlvbi5wYWdlSW5kZXggPiAwO1xuICAgIHRhYmxlLmdldENhbk5leHRQYWdlID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYWdlSW5kZXhcbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb247XG4gICAgICBjb25zdCBwYWdlQ291bnQgPSB0YWJsZS5nZXRQYWdlQ291bnQoKTtcbiAgICAgIGlmIChwYWdlQ291bnQgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHBhZ2VDb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFnZUluZGV4IDwgcGFnZUNvdW50IC0gMTtcbiAgICB9O1xuICAgIHRhYmxlLnByZXZpb3VzUGFnZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRQYWdlSW5kZXgob2xkID0+IG9sZCAtIDEpO1xuICAgIH07XG4gICAgdGFibGUubmV4dFBhZ2UgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuc2V0UGFnZUluZGV4KG9sZCA9PiB7XG4gICAgICAgIHJldHVybiBvbGQgKyAxO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0YWJsZS5maXJzdFBhZ2UgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuc2V0UGFnZUluZGV4KDApO1xuICAgIH07XG4gICAgdGFibGUubGFzdFBhZ2UgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuc2V0UGFnZUluZGV4KHRhYmxlLmdldFBhZ2VDb3VudCgpIC0gMSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRFeHBhbmRlZFJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0UGFnaW5hdGlvblJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0UGFnaW5hdGlvblJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0UGFnaW5hdGlvblJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldFBhZ2luYXRpb25Sb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxQYWdpbmF0aW9uIHx8ICF0YWJsZS5fZ2V0UGFnaW5hdGlvblJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0UGFnaW5hdGlvblJvd01vZGVsKCk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQYWdlQ291bnQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkcGFnZUNvMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkcGFnZUNvMiA9IHRhYmxlLm9wdGlvbnMucGFnZUNvdW50KSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkcGFnZUNvMiA6IE1hdGguY2VpbCh0YWJsZS5nZXRSb3dDb3VudCgpIC8gdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLnBhZ2VTaXplKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFJvd0NvdW50ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHJvd0NvdTtcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkcm93Q291ID0gdGFibGUub3B0aW9ucy5yb3dDb3VudCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJHJvd0NvdSA6IHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpLnJvd3MubGVuZ3RoO1xuICAgIH07XG4gIH1cbn07XG5cbi8vXG5cbmNvbnN0IGdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUgPSAoKSA9PiAoe1xuICBsZWZ0OiBbXSxcbiAgcmlnaHQ6IFtdXG59KTtcbmNvbnN0IGdldERlZmF1bHRSb3dQaW5uaW5nU3RhdGUgPSAoKSA9PiAoe1xuICB0b3A6IFtdLFxuICBib3R0b206IFtdXG59KTtcbmNvbnN0IFBpbm5pbmcgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5QaW5uaW5nOiBnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlKCksXG4gICAgICByb3dQaW5uaW5nOiBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlKCksXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ29sdW1uUGlubmluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uUGlubmluZycsIHRhYmxlKSxcbiAgICAgIG9uUm93UGlubmluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcigncm93UGlubmluZycsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4ucGluID0gcG9zaXRpb24gPT4ge1xuICAgICAgY29uc3QgY29sdW1uSWRzID0gY29sdW1uLmdldExlYWZDb2x1bW5zKCkubWFwKGQgPT4gZC5pZCkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgdGFibGUuc2V0Q29sdW1uUGlubmluZyhvbGQgPT4ge1xuICAgICAgICB2YXIgX29sZCRsZWZ0MywgX29sZCRyaWdodDM7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHZhciBfb2xkJGxlZnQsIF9vbGQkcmlnaHQ7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6ICgoX29sZCRsZWZ0ID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubGVmdCkgIT0gbnVsbCA/IF9vbGQkbGVmdCA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpLFxuICAgICAgICAgICAgcmlnaHQ6IFsuLi4oKF9vbGQkcmlnaHQgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5yaWdodCkgIT0gbnVsbCA/IF9vbGQkcmlnaHQgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKSwgLi4uY29sdW1uSWRzXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB2YXIgX29sZCRsZWZ0MiwgX29sZCRyaWdodDI7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IFsuLi4oKF9vbGQkbGVmdDIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5sZWZ0KSAhPSBudWxsID8gX29sZCRsZWZ0MiA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpLCAuLi5jb2x1bW5JZHNdLFxuICAgICAgICAgICAgcmlnaHQ6ICgoX29sZCRyaWdodDIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5yaWdodCkgIT0gbnVsbCA/IF9vbGQkcmlnaHQyIDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogKChfb2xkJGxlZnQzID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubGVmdCkgIT0gbnVsbCA/IF9vbGQkbGVmdDMgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKSxcbiAgICAgICAgICByaWdodDogKChfb2xkJHJpZ2h0MyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnJpZ2h0KSAhPSBudWxsID8gX29sZCRyaWdodDMgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuUGluID0gKCkgPT4ge1xuICAgICAgY29uc3QgbGVhZkNvbHVtbnMgPSBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKTtcbiAgICAgIHJldHVybiBsZWFmQ29sdW1ucy5zb21lKGQgPT4ge1xuICAgICAgICB2YXIgX2QkY29sdW1uRGVmJGVuYWJsZVBpLCBfcmVmLCBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICAgIHJldHVybiAoKF9kJGNvbHVtbkRlZiRlbmFibGVQaSA9IGQuY29sdW1uRGVmLmVuYWJsZVBpbm5pbmcpICE9IG51bGwgPyBfZCRjb2x1bW5EZWYkZW5hYmxlUGkgOiB0cnVlKSAmJiAoKF9yZWYgPSAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVDb2x1bW5QaW5uaW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdGFibGUub3B0aW9ucy5lbmFibGVQaW5uaW5nKSAhPSBudWxsID8gX3JlZiA6IHRydWUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNQaW5uZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBsZWFmQ29sdW1uSWRzID0gY29sdW1uLmdldExlYWZDb2x1bW5zKCkubWFwKGQgPT4gZC5pZCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0XG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nO1xuICAgICAgY29uc3QgaXNMZWZ0ID0gbGVhZkNvbHVtbklkcy5zb21lKGQgPT4gbGVmdCA9PSBudWxsID8gdm9pZCAwIDogbGVmdC5pbmNsdWRlcyhkKSk7XG4gICAgICBjb25zdCBpc1JpZ2h0ID0gbGVhZkNvbHVtbklkcy5zb21lKGQgPT4gcmlnaHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJpZ2h0LmluY2x1ZGVzKGQpKTtcbiAgICAgIHJldHVybiBpc0xlZnQgPyAnbGVmdCcgOiBpc1JpZ2h0ID8gJ3JpZ2h0JyA6IGZhbHNlO1xuICAgIH07XG4gICAgY29sdW1uLmdldFBpbm5lZEluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRjb2x1bSwgX3RhYmxlJGdldFN0YXRlJGNvbHVtMjtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gY29sdW1uLmdldElzUGlubmVkKCk7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPyAoX3RhYmxlJGdldFN0YXRlJGNvbHVtID0gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcpID09IG51bGwgfHwgKF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgPSBfdGFibGUkZ2V0U3RhdGUkY29sdW0yW3Bvc2l0aW9uXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIuaW5kZXhPZihjb2x1bW4uaWQpKSAhPSBudWxsID8gX3RhYmxlJGdldFN0YXRlJGNvbHVtIDogLTEgOiAwO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cucGluID0gKHBvc2l0aW9uLCBpbmNsdWRlTGVhZlJvd3MsIGluY2x1ZGVQYXJlbnRSb3dzKSA9PiB7XG4gICAgICBjb25zdCBsZWFmUm93SWRzID0gaW5jbHVkZUxlYWZSb3dzID8gcm93LmdldExlYWZSb3dzKCkubWFwKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0pIDogW107XG4gICAgICBjb25zdCBwYXJlbnRSb3dJZHMgPSBpbmNsdWRlUGFyZW50Um93cyA/IHJvdy5nZXRQYXJlbnRSb3dzKCkubWFwKF9yZWYzID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gX3JlZjM7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0pIDogW107XG4gICAgICBjb25zdCByb3dJZHMgPSBuZXcgU2V0KFsuLi5wYXJlbnRSb3dJZHMsIHJvdy5pZCwgLi4ubGVhZlJvd0lkc10pO1xuICAgICAgdGFibGUuc2V0Um93UGlubmluZyhvbGQgPT4ge1xuICAgICAgICB2YXIgX29sZCR0b3AzLCBfb2xkJGJvdHRvbTM7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICB2YXIgX29sZCR0b3AsIF9vbGQkYm90dG9tO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6ICgoX29sZCR0b3AgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC50b3ApICE9IG51bGwgPyBfb2xkJHRvcCA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKSxcbiAgICAgICAgICAgIGJvdHRvbTogWy4uLigoX29sZCRib3R0b20gPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5ib3R0b20pICE9IG51bGwgPyBfb2xkJGJvdHRvbSA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKSwgLi4uQXJyYXkuZnJvbShyb3dJZHMpXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgIHZhciBfb2xkJHRvcDIsIF9vbGQkYm90dG9tMjtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBbLi4uKChfb2xkJHRvcDIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC50b3ApICE9IG51bGwgPyBfb2xkJHRvcDIgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSksIC4uLkFycmF5LmZyb20ocm93SWRzKV0sXG4gICAgICAgICAgICBib3R0b206ICgoX29sZCRib3R0b20yID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuYm90dG9tKSAhPSBudWxsID8gX29sZCRib3R0b20yIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogKChfb2xkJHRvcDMgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC50b3ApICE9IG51bGwgPyBfb2xkJHRvcDMgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSksXG4gICAgICAgICAgYm90dG9tOiAoKF9vbGQkYm90dG9tMyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmJvdHRvbSkgIT0gbnVsbCA/IF9vbGQkYm90dG9tMyA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuUGluID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWY0O1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbmFibGVSb3dQaW5uaW5nLFxuICAgICAgICBlbmFibGVQaW5uaW5nXG4gICAgICB9ID0gdGFibGUub3B0aW9ucztcbiAgICAgIGlmICh0eXBlb2YgZW5hYmxlUm93UGlubmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZW5hYmxlUm93UGlubmluZyhyb3cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfcmVmNCA9IGVuYWJsZVJvd1Bpbm5pbmcgIT0gbnVsbCA/IGVuYWJsZVJvd1Bpbm5pbmcgOiBlbmFibGVQaW5uaW5nKSAhPSBudWxsID8gX3JlZjQgOiB0cnVlO1xuICAgIH07XG4gICAgcm93LmdldElzUGlubmVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qgcm93SWRzID0gW3Jvdy5pZF07XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRvcCxcbiAgICAgICAgYm90dG9tXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nO1xuICAgICAgY29uc3QgaXNUb3AgPSByb3dJZHMuc29tZShkID0+IHRvcCA9PSBudWxsID8gdm9pZCAwIDogdG9wLmluY2x1ZGVzKGQpKTtcbiAgICAgIGNvbnN0IGlzQm90dG9tID0gcm93SWRzLnNvbWUoZCA9PiBib3R0b20gPT0gbnVsbCA/IHZvaWQgMCA6IGJvdHRvbS5pbmNsdWRlcyhkKSk7XG4gICAgICByZXR1cm4gaXNUb3AgPyAndG9wJyA6IGlzQm90dG9tID8gJ2JvdHRvbScgOiBmYWxzZTtcbiAgICB9O1xuICAgIHJvdy5nZXRQaW5uZWRJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkX2dldFBpbm5lZFJvd3MsIF92aXNpYmxlUGlubmVkUm93SWRzJDtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcm93LmdldElzUGlubmVkKCk7XG4gICAgICBpZiAoIXBvc2l0aW9uKSByZXR1cm4gLTE7XG4gICAgICBjb25zdCB2aXNpYmxlUGlubmVkUm93SWRzID0gKF90YWJsZSRfZ2V0UGlubmVkUm93cyA9IHRhYmxlLl9nZXRQaW5uZWRSb3dzKHBvc2l0aW9uKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRfZ2V0UGlubmVkUm93cy5tYXAoX3JlZjUgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBfcmVmNTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKF92aXNpYmxlUGlubmVkUm93SWRzJCA9IHZpc2libGVQaW5uZWRSb3dJZHMgPT0gbnVsbCA/IHZvaWQgMCA6IHZpc2libGVQaW5uZWRSb3dJZHMuaW5kZXhPZihyb3cuaWQpKSAhPSBudWxsID8gX3Zpc2libGVQaW5uZWRSb3dJZHMkIDogLTE7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2VudGVyVmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnQsIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDZWxscywgbGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIGNvbnN0IGxlZnRBbmRSaWdodCA9IFsuLi4obGVmdCAhPSBudWxsID8gbGVmdCA6IFtdKSwgLi4uKHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IFtdKV07XG4gICAgICByZXR1cm4gYWxsQ2VsbHMuZmlsdGVyKGQgPT4gIWxlZnRBbmRSaWdodC5pbmNsdWRlcyhkLmNvbHVtbi5pZCkpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0Q2VudGVyVmlzaWJsZUNlbGxzJykpO1xuICAgIHJvdy5nZXRMZWZ0VmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnRdLCAoYWxsQ2VsbHMsIGxlZnQpID0+IHtcbiAgICAgIGNvbnN0IGNlbGxzID0gKGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBbXSkubWFwKGNvbHVtbklkID0+IGFsbENlbGxzLmZpbmQoY2VsbCA9PiBjZWxsLmNvbHVtbi5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikubWFwKGQgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgcG9zaXRpb246ICdsZWZ0J1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGNlbGxzO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0TGVmdFZpc2libGVDZWxscycpKTtcbiAgICByb3cuZ2V0UmlnaHRWaXNpYmxlQ2VsbHMgPSBtZW1vKCgpID0+IFtyb3cuX2dldEFsbFZpc2libGVDZWxscygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ2VsbHMsIHJpZ2h0KSA9PiB7XG4gICAgICBjb25zdCBjZWxscyA9IChyaWdodCAhPSBudWxsID8gcmlnaHQgOiBbXSkubWFwKGNvbHVtbklkID0+IGFsbENlbGxzLmZpbmQoY2VsbCA9PiBjZWxsLmNvbHVtbi5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikubWFwKGQgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgcG9zaXRpb246ICdyaWdodCdcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBjZWxscztcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldFJpZ2h0VmlzaWJsZUNlbGxzJykpO1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldENvbHVtblBpbm5pbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Db2x1bW5QaW5uaW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uUGlubmluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldENvbHVtblBpbm5pbmcgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYywgX3RhYmxlJGluaXRpYWxTdGF0ZTtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRDb2x1bW5QaW5uaW5nKGRlZmF1bHRTdGF0ZSA/IGdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUoKSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUuY29sdW1uUGlubmluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYyA6IGdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUoKSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVDb2x1bW5zUGlubmVkID0gcG9zaXRpb24gPT4ge1xuICAgICAgdmFyIF9waW5uaW5nU3RhdGUkcG9zaXRpbztcbiAgICAgIGNvbnN0IHBpbm5pbmdTdGF0ZSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZztcbiAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF9waW5uaW5nU3RhdGUkbGVmdCwgX3Bpbm5pbmdTdGF0ZSRyaWdodDtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKChfcGlubmluZ1N0YXRlJGxlZnQgPSBwaW5uaW5nU3RhdGUubGVmdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkbGVmdC5sZW5ndGgpIHx8ICgoX3Bpbm5pbmdTdGF0ZSRyaWdodCA9IHBpbm5pbmdTdGF0ZS5yaWdodCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkcmlnaHQubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQm9vbGVhbigoX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvID0gcGlubmluZ1N0YXRlW3Bvc2l0aW9uXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkcG9zaXRpby5sZW5ndGgpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0TGVmdExlYWZDb2x1bW5zID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnRdLCAoYWxsQ29sdW1ucywgbGVmdCkgPT4ge1xuICAgICAgcmV0dXJuIChsZWZ0ICE9IG51bGwgPyBsZWZ0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDb2x1bW5zLmZpbmQoY29sdW1uID0+IGNvbHVtbi5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRMZWZ0TGVhZkNvbHVtbnMnKSk7XG4gICAgdGFibGUuZ2V0UmlnaHRMZWFmQ29sdW1ucyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbExlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDb2x1bW5zLCByaWdodCkgPT4ge1xuICAgICAgcmV0dXJuIChyaWdodCAhPSBudWxsID8gcmlnaHQgOiBbXSkubWFwKGNvbHVtbklkID0+IGFsbENvbHVtbnMuZmluZChjb2x1bW4gPT4gY29sdW1uLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldFJpZ2h0TGVhZkNvbHVtbnMnKSk7XG4gICAgdGFibGUuZ2V0Q2VudGVyTGVhZkNvbHVtbnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENvbHVtbnMsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBjb25zdCBsZWZ0QW5kUmlnaHQgPSBbLi4uKGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBbXSksIC4uLihyaWdodCAhPSBudWxsID8gcmlnaHQgOiBbXSldO1xuICAgICAgcmV0dXJuIGFsbENvbHVtbnMuZmlsdGVyKGQgPT4gIWxlZnRBbmRSaWdodC5pbmNsdWRlcyhkLmlkKSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRDZW50ZXJMZWFmQ29sdW1ucycpKTtcbiAgICB0YWJsZS5zZXRSb3dQaW5uaW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uUm93UGlubmluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vblJvd1Bpbm5pbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRSb3dQaW5uaW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHIsIF90YWJsZSRpbml0aWFsU3RhdGUyO1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFJvd1Bpbm5pbmcoZGVmYXVsdFN0YXRlID8gZ2V0RGVmYXVsdFJvd1Bpbm5pbmdTdGF0ZSgpIDogKF90YWJsZSRpbml0aWFsU3RhdGUkciA9IChfdGFibGUkaW5pdGlhbFN0YXRlMiA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUyLnJvd1Bpbm5pbmcpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHIgOiBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlKCkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNTb21lUm93c1Bpbm5lZCA9IHBvc2l0aW9uID0+IHtcbiAgICAgIHZhciBfcGlubmluZ1N0YXRlJHBvc2l0aW8yO1xuICAgICAgY29uc3QgcGlubmluZ1N0YXRlID0gdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICB2YXIgX3Bpbm5pbmdTdGF0ZSR0b3AsIF9waW5uaW5nU3RhdGUkYm90dG9tO1xuICAgICAgICByZXR1cm4gQm9vbGVhbigoKF9waW5uaW5nU3RhdGUkdG9wID0gcGlubmluZ1N0YXRlLnRvcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkdG9wLmxlbmd0aCkgfHwgKChfcGlubmluZ1N0YXRlJGJvdHRvbSA9IHBpbm5pbmdTdGF0ZS5ib3R0b20pID09IG51bGwgPyB2b2lkIDAgOiBfcGlubmluZ1N0YXRlJGJvdHRvbS5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCb29sZWFuKChfcGlubmluZ1N0YXRlJHBvc2l0aW8yID0gcGlubmluZ1N0YXRlW3Bvc2l0aW9uXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkcG9zaXRpbzIubGVuZ3RoKTtcbiAgICB9O1xuICAgIHRhYmxlLl9nZXRQaW5uZWRSb3dzID0gbWVtbyhwb3NpdGlvbiA9PiBbdGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzLCB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmdbcG9zaXRpb25dLCBwb3NpdGlvbl0sICh2aXNpYmxlUm93cywgcGlubmVkUm93SWRzLCBwb3NpdGlvbikgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGtlZXBQaTtcbiAgICAgIGNvbnN0IHJvd3MgPSAoKF90YWJsZSRvcHRpb25zJGtlZXBQaSA9IHRhYmxlLm9wdGlvbnMua2VlcFBpbm5lZFJvd3MpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRrZWVwUGkgOiB0cnVlKSA/XG4gICAgICAvL2dldCBhbGwgcm93cyB0aGF0IGFyZSBwaW5uZWQgZXZlbiBpZiB0aGV5IHdvdWxkIG5vdCBiZSBvdGhlcndpc2UgdmlzaWJsZVxuICAgICAgLy9hY2NvdW50IGZvciBleHBhbmRlZCBwYXJlbnQgcm93cywgYnV0IG5vdCBwYWdpbmF0aW9uIG9yIGZpbHRlcmluZ1xuICAgICAgKHBpbm5lZFJvd0lkcyAhPSBudWxsID8gcGlubmVkUm93SWRzIDogW10pLm1hcChyb3dJZCA9PiB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHRhYmxlLmdldFJvdyhyb3dJZCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByb3cuZ2V0SXNBbGxQYXJlbnRzRXhwYW5kZWQoKSA/IHJvdyA6IG51bGw7XG4gICAgICB9KSA6XG4gICAgICAvL2Vsc2UgZ2V0IG9ubHkgdmlzaWJsZSByb3dzIHRoYXQgYXJlIHBpbm5lZFxuICAgICAgKHBpbm5lZFJvd0lkcyAhPSBudWxsID8gcGlubmVkUm93SWRzIDogW10pLm1hcChyb3dJZCA9PiB2aXNpYmxlUm93cy5maW5kKHJvdyA9PiByb3cuaWQgPT09IHJvd0lkKSk7XG4gICAgICByZXR1cm4gcm93cy5maWx0ZXIoQm9vbGVhbikubWFwKGQgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgcG9zaXRpb25cbiAgICAgIH0pKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ19nZXRQaW5uZWRSb3dzJykpO1xuICAgIHRhYmxlLmdldFRvcFJvd3MgPSAoKSA9PiB0YWJsZS5fZ2V0UGlubmVkUm93cygndG9wJyk7XG4gICAgdGFibGUuZ2V0Qm90dG9tUm93cyA9ICgpID0+IHRhYmxlLl9nZXRQaW5uZWRSb3dzKCdib3R0b20nKTtcbiAgICB0YWJsZS5nZXRDZW50ZXJSb3dzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzLCB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmcudG9wLCB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmcuYm90dG9tXSwgKGFsbFJvd3MsIHRvcCwgYm90dG9tKSA9PiB7XG4gICAgICBjb25zdCB0b3BBbmRCb3R0b20gPSBuZXcgU2V0KFsuLi4odG9wICE9IG51bGwgPyB0b3AgOiBbXSksIC4uLihib3R0b20gIT0gbnVsbCA/IGJvdHRvbSA6IFtdKV0pO1xuICAgICAgcmV0dXJuIGFsbFJvd3MuZmlsdGVyKGQgPT4gIXRvcEFuZEJvdHRvbS5oYXMoZC5pZCkpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0Q2VudGVyUm93cycpKTtcbiAgfVxufTtcblxuLy9cblxuY29uc3QgUm93U2VsZWN0aW9uID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcm93U2VsZWN0aW9uOiB7fSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Sb3dTZWxlY3Rpb25DaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ3Jvd1NlbGVjdGlvbicsIHRhYmxlKSxcbiAgICAgIGVuYWJsZVJvd1NlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIGVuYWJsZU11bHRpUm93U2VsZWN0aW9uOiB0cnVlLFxuICAgICAgZW5hYmxlU3ViUm93U2VsZWN0aW9uOiB0cnVlXG4gICAgICAvLyBlbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbjogZmFsc2UsXG4gICAgICAvLyBpc0FkZGl0aXZlU2VsZWN0RXZlbnQ6IChlOiB1bmtub3duKSA9PiAhIWUubWV0YUtleSxcbiAgICAgIC8vIGlzSW5jbHVzaXZlU2VsZWN0RXZlbnQ6IChlOiB1bmtub3duKSA9PiAhIWUuc2hpZnRLZXksXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRSb3dTZWxlY3Rpb24gPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Sb3dTZWxlY3Rpb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Sb3dTZWxlY3Rpb25DaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRSb3dTZWxlY3Rpb24gPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcjtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRSb3dTZWxlY3Rpb24oZGVmYXVsdFN0YXRlID8ge30gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRyID0gdGFibGUuaW5pdGlhbFN0YXRlLnJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkciA6IHt9KTtcbiAgICB9O1xuICAgIHRhYmxlLnRvZ2dsZUFsbFJvd3NTZWxlY3RlZCA9IHZhbHVlID0+IHtcbiAgICAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbihvbGQgPT4ge1xuICAgICAgICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6ICF0YWJsZS5nZXRJc0FsbFJvd3NTZWxlY3RlZCgpO1xuICAgICAgICBjb25zdCByb3dTZWxlY3Rpb24gPSB7XG4gICAgICAgICAgLi4ub2xkXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByZUdyb3VwZWRGbGF0Um93cyA9IHRhYmxlLmdldFByZUdyb3VwZWRSb3dNb2RlbCgpLmZsYXRSb3dzO1xuXG4gICAgICAgIC8vIFdlIGRvbid0IHVzZSBgbXV0YXRlUm93SXNTZWxlY3RlZGAgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAgICAgICAgLy8gQWxsIG9mIHRoZSByb3dzIGFyZSBmbGF0IGFscmVhZHksIHNvIGl0IHdvdWxkbid0IGJlIHdvcnRoIGl0XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHByZUdyb3VwZWRGbGF0Um93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICBpZiAoIXJvdy5nZXRDYW5TZWxlY3QoKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dTZWxlY3Rpb25bcm93LmlkXSA9IHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJlR3JvdXBlZEZsYXRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSByb3dTZWxlY3Rpb25bcm93LmlkXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93U2VsZWN0aW9uO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0YWJsZS50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkID0gdmFsdWUgPT4gdGFibGUuc2V0Um93U2VsZWN0aW9uKG9sZCA9PiB7XG4gICAgICBjb25zdCByZXNvbHZlZFZhbHVlID0gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogIXRhYmxlLmdldElzQWxsUGFnZVJvd3NTZWxlY3RlZCgpO1xuICAgICAgY29uc3Qgcm93U2VsZWN0aW9uID0ge1xuICAgICAgICAuLi5vbGRcbiAgICAgIH07XG4gICAgICB0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICBtdXRhdGVSb3dJc1NlbGVjdGVkKHJvd1NlbGVjdGlvbiwgcm93LmlkLCByZXNvbHZlZFZhbHVlLCB0cnVlLCB0YWJsZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByb3dTZWxlY3Rpb247XG4gICAgfSk7XG5cbiAgICAvLyBhZGRSb3dTZWxlY3Rpb25SYW5nZTogcm93SWQgPT4ge1xuICAgIC8vICAgY29uc3Qge1xuICAgIC8vICAgICByb3dzLFxuICAgIC8vICAgICByb3dzQnlJZCxcbiAgICAvLyAgICAgb3B0aW9uczogeyBzZWxlY3RHcm91cGluZ1Jvd3MsIHNlbGVjdFN1YlJvd3MgfSxcbiAgICAvLyAgIH0gPSB0YWJsZVxuXG4gICAgLy8gICBjb25zdCBmaW5kU2VsZWN0ZWRSb3cgPSAocm93czogUm93W10pID0+IHtcbiAgICAvLyAgICAgbGV0IGZvdW5kXG4gICAgLy8gICAgIHJvd3MuZmluZChkID0+IHtcbiAgICAvLyAgICAgICBpZiAoZC5nZXRJc1NlbGVjdGVkKCkpIHtcbiAgICAvLyAgICAgICAgIGZvdW5kID0gZFxuICAgIC8vICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgICAgY29uc3Qgc3ViRm91bmQgPSBmaW5kU2VsZWN0ZWRSb3coZC5zdWJSb3dzIHx8IFtdKVxuICAgIC8vICAgICAgIGlmIChzdWJGb3VuZCkge1xuICAgIC8vICAgICAgICAgZm91bmQgPSBzdWJGb3VuZFxuICAgIC8vICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgICAgcmV0dXJuIGZhbHNlXG4gICAgLy8gICAgIH0pXG4gICAgLy8gICAgIHJldHVybiBmb3VuZFxuICAgIC8vICAgfVxuXG4gICAgLy8gICBjb25zdCBmaXJzdFJvdyA9IGZpbmRTZWxlY3RlZFJvdyhyb3dzKSB8fCByb3dzWzBdXG4gICAgLy8gICBjb25zdCBsYXN0Um93ID0gcm93c0J5SWRbcm93SWRdXG5cbiAgICAvLyAgIGxldCBpbmNsdWRlID0gZmFsc2VcbiAgICAvLyAgIGNvbnN0IHNlbGVjdGVkUm93SWRzID0ge31cblxuICAgIC8vICAgY29uc3QgYWRkUm93ID0gKHJvdzogUm93KSA9PiB7XG4gICAgLy8gICAgIG11dGF0ZVJvd0lzU2VsZWN0ZWQoc2VsZWN0ZWRSb3dJZHMsIHJvdy5pZCwgdHJ1ZSwge1xuICAgIC8vICAgICAgIHJvd3NCeUlkLFxuICAgIC8vICAgICAgIHNlbGVjdEdyb3VwaW5nUm93czogc2VsZWN0R3JvdXBpbmdSb3dzISxcbiAgICAvLyAgICAgICBzZWxlY3RTdWJSb3dzOiBzZWxlY3RTdWJSb3dzISxcbiAgICAvLyAgICAgfSlcbiAgICAvLyAgIH1cblxuICAgIC8vICAgdGFibGUucm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgLy8gICAgIGNvbnN0IGlzRmlyc3RSb3cgPSByb3cuaWQgPT09IGZpcnN0Um93LmlkXG4gICAgLy8gICAgIGNvbnN0IGlzTGFzdFJvdyA9IHJvdy5pZCA9PT0gbGFzdFJvdy5pZFxuXG4gICAgLy8gICAgIGlmIChpc0ZpcnN0Um93IHx8IGlzTGFzdFJvdykge1xuICAgIC8vICAgICAgIGlmICghaW5jbHVkZSkge1xuICAgIC8vICAgICAgICAgaW5jbHVkZSA9IHRydWVcbiAgICAvLyAgICAgICB9IGVsc2UgaWYgKGluY2x1ZGUpIHtcbiAgICAvLyAgICAgICAgIGFkZFJvdyhyb3cpXG4gICAgLy8gICAgICAgICBpbmNsdWRlID0gZmFsc2VcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgIH1cblxuICAgIC8vICAgICBpZiAoaW5jbHVkZSkge1xuICAgIC8vICAgICAgIGFkZFJvdyhyb3cpXG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH0pXG5cbiAgICAvLyAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbihzZWxlY3RlZFJvd0lkcylcbiAgICAvLyB9LFxuICAgIHRhYmxlLmdldFByZVNlbGVjdGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRTZWxlY3RlZFJvd01vZGVsID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24sIHRhYmxlLmdldENvcmVSb3dNb2RlbCgpXSwgKHJvd1NlbGVjdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICAgIGlmICghT2JqZWN0LmtleXMocm93U2VsZWN0aW9uKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb3dzOiBbXSxcbiAgICAgICAgICBmbGF0Um93czogW10sXG4gICAgICAgICAgcm93c0J5SWQ6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0U2VsZWN0ZWRSb3dNb2RlbCcpKTtcbiAgICB0YWJsZS5nZXRGaWx0ZXJlZFNlbGVjdGVkUm93TW9kZWwgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbiwgdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpXSwgKHJvd1NlbGVjdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICAgIGlmICghT2JqZWN0LmtleXMocm93U2VsZWN0aW9uKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb3dzOiBbXSxcbiAgICAgICAgICBmbGF0Um93czogW10sXG4gICAgICAgICAgcm93c0J5SWQ6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0RmlsdGVyZWRTZWxlY3RlZFJvd01vZGVsJykpO1xuICAgIHRhYmxlLmdldEdyb3VwZWRTZWxlY3RlZFJvd01vZGVsID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24sIHRhYmxlLmdldFNvcnRlZFJvd01vZGVsKCldLCAocm93U2VsZWN0aW9uLCByb3dNb2RlbCkgPT4ge1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyhyb3dTZWxlY3Rpb24pLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvd3M6IFtdLFxuICAgICAgICAgIGZsYXRSb3dzOiBbXSxcbiAgICAgICAgICByb3dzQnlJZDoge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RSb3dzRm4odGFibGUsIHJvd01vZGVsKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRHcm91cGVkU2VsZWN0ZWRSb3dNb2RlbCcpKTtcblxuICAgIC8vL1xuXG4gICAgLy8gZ2V0R3JvdXBpbmdSb3dDYW5TZWxlY3Q6IHJvd0lkID0+IHtcbiAgICAvLyAgIGNvbnN0IHJvdyA9IHRhYmxlLmdldFJvdyhyb3dJZClcblxuICAgIC8vICAgaWYgKCFyb3cpIHtcbiAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKClcbiAgICAvLyAgIH1cblxuICAgIC8vICAgaWYgKHR5cGVvZiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gICAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uKHJvdylcbiAgICAvLyAgIH1cblxuICAgIC8vICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb24gPz8gZmFsc2VcbiAgICAvLyB9LFxuXG4gICAgdGFibGUuZ2V0SXNBbGxSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwcmVHcm91cGVkRmxhdFJvd3MgPSB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCkuZmxhdFJvd3M7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvblxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XG4gICAgICBsZXQgaXNBbGxSb3dzU2VsZWN0ZWQgPSBCb29sZWFuKHByZUdyb3VwZWRGbGF0Um93cy5sZW5ndGggJiYgT2JqZWN0LmtleXMocm93U2VsZWN0aW9uKS5sZW5ndGgpO1xuICAgICAgaWYgKGlzQWxsUm93c1NlbGVjdGVkKSB7XG4gICAgICAgIGlmIChwcmVHcm91cGVkRmxhdFJvd3Muc29tZShyb3cgPT4gcm93LmdldENhblNlbGVjdCgpICYmICFyb3dTZWxlY3Rpb25bcm93LmlkXSkpIHtcbiAgICAgICAgICBpc0FsbFJvd3NTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBbGxSb3dzU2VsZWN0ZWQ7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwYWdpbmF0aW9uRmxhdFJvd3MgPSB0YWJsZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwoKS5mbGF0Um93cy5maWx0ZXIocm93ID0+IHJvdy5nZXRDYW5TZWxlY3QoKSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvblxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XG4gICAgICBsZXQgaXNBbGxQYWdlUm93c1NlbGVjdGVkID0gISFwYWdpbmF0aW9uRmxhdFJvd3MubGVuZ3RoO1xuICAgICAgaWYgKGlzQWxsUGFnZVJvd3NTZWxlY3RlZCAmJiBwYWdpbmF0aW9uRmxhdFJvd3Muc29tZShyb3cgPT4gIXJvd1NlbGVjdGlvbltyb3cuaWRdKSkge1xuICAgICAgICBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQ7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJHJvd1NlO1xuICAgICAgY29uc3QgdG90YWxTZWxlY3RlZCA9IE9iamVjdC5rZXlzKChfdGFibGUkZ2V0U3RhdGUkcm93U2UgPSB0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRyb3dTZSA6IHt9KS5sZW5ndGg7XG4gICAgICByZXR1cm4gdG90YWxTZWxlY3RlZCA+IDAgJiYgdG90YWxTZWxlY3RlZCA8IHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKS5mbGF0Um93cy5sZW5ndGg7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVQYWdlUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgcGFnaW5hdGlvbkZsYXRSb3dzID0gdGFibGUuZ2V0UGFnaW5hdGlvblJvd01vZGVsKCkuZmxhdFJvd3M7XG4gICAgICByZXR1cm4gdGFibGUuZ2V0SXNBbGxQYWdlUm93c1NlbGVjdGVkKCkgPyBmYWxzZSA6IHBhZ2luYXRpb25GbGF0Um93cy5maWx0ZXIocm93ID0+IHJvdy5nZXRDYW5TZWxlY3QoKSkuc29tZShkID0+IGQuZ2V0SXNTZWxlY3RlZCgpIHx8IGQuZ2V0SXNTb21lU2VsZWN0ZWQoKSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRUb2dnbGVBbGxSb3dzU2VsZWN0ZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICB0YWJsZS50b2dnbGVBbGxSb3dzU2VsZWN0ZWQoZS50YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9O1xuICAgIH07XG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIHRhYmxlLnRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWQoZS50YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9O1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cudG9nZ2xlU2VsZWN0ZWQgPSAodmFsdWUsIG9wdHMpID0+IHtcbiAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSByb3cuZ2V0SXNTZWxlY3RlZCgpO1xuICAgICAgdGFibGUuc2V0Um93U2VsZWN0aW9uKG9sZCA9PiB7XG4gICAgICAgIHZhciBfb3B0cyRzZWxlY3RDaGlsZHJlbjtcbiAgICAgICAgdmFsdWUgPSB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiAhaXNTZWxlY3RlZDtcbiAgICAgICAgaWYgKHJvdy5nZXRDYW5TZWxlY3QoKSAmJiBpc1NlbGVjdGVkID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRSb3dJZHMgPSB7XG4gICAgICAgICAgLi4ub2xkXG4gICAgICAgIH07XG4gICAgICAgIG11dGF0ZVJvd0lzU2VsZWN0ZWQoc2VsZWN0ZWRSb3dJZHMsIHJvdy5pZCwgdmFsdWUsIChfb3B0cyRzZWxlY3RDaGlsZHJlbiA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuc2VsZWN0Q2hpbGRyZW4pICE9IG51bGwgPyBfb3B0cyRzZWxlY3RDaGlsZHJlbiA6IHRydWUsIHRhYmxlKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkUm93SWRzO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByb3cuZ2V0SXNTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm93U2VsZWN0aW9uXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBpc1Jvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKTtcbiAgICB9O1xuICAgIHJvdy5nZXRJc1NvbWVTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm93U2VsZWN0aW9uXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBpc1N1YlJvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKSA9PT0gJ3NvbWUnO1xuICAgIH07XG4gICAgcm93LmdldElzQWxsU3ViUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb25cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgICAgcmV0dXJuIGlzU3ViUm93U2VsZWN0ZWQocm93LCByb3dTZWxlY3Rpb24pID09PSAnYWxsJztcbiAgICB9O1xuICAgIHJvdy5nZXRDYW5TZWxlY3QgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZW5hYmxlO1xuICAgICAgaWYgKHR5cGVvZiB0YWJsZS5vcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24ocm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlO1xuICAgIH07XG4gICAgcm93LmdldENhblNlbGVjdFN1YlJvd3MgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMjtcbiAgICAgIGlmICh0eXBlb2YgdGFibGUub3B0aW9ucy5lbmFibGVTdWJSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlU3ViUm93U2VsZWN0aW9uKHJvdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGVuYWJsZTIgPSB0YWJsZS5vcHRpb25zLmVuYWJsZVN1YlJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTIgOiB0cnVlO1xuICAgIH07XG4gICAgcm93LmdldENhbk11bHRpU2VsZWN0ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGVuYWJsZTM7XG4gICAgICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24ocm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUzIDogdHJ1ZTtcbiAgICB9O1xuICAgIHJvdy5nZXRUb2dnbGVTZWxlY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYW5TZWxlY3QgPSByb3cuZ2V0Q2FuU2VsZWN0KCk7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIHZhciBfdGFyZ2V0O1xuICAgICAgICBpZiAoIWNhblNlbGVjdCkgcmV0dXJuO1xuICAgICAgICByb3cudG9nZ2xlU2VsZWN0ZWQoKF90YXJnZXQgPSBlLnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn07XG5jb25zdCBtdXRhdGVSb3dJc1NlbGVjdGVkID0gKHNlbGVjdGVkUm93SWRzLCBpZCwgdmFsdWUsIGluY2x1ZGVDaGlsZHJlbiwgdGFibGUpID0+IHtcbiAgdmFyIF9yb3ckc3ViUm93cztcbiAgY29uc3Qgcm93ID0gdGFibGUuZ2V0Um93KGlkLCB0cnVlKTtcblxuICAvLyBjb25zdCBpc0dyb3VwZWQgPSByb3cuZ2V0SXNHcm91cGVkKClcblxuICAvLyBpZiAoIC8vIFRPRE86IGVuZm9yY2UgZ3JvdXBpbmcgcm93IHNlbGVjdGlvbiBydWxlc1xuICAvLyAgICFpc0dyb3VwZWQgfHxcbiAgLy8gICAoaXNHcm91cGVkICYmIHRhYmxlLm9wdGlvbnMuZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb24pXG4gIC8vICkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIXJvdy5nZXRDYW5NdWx0aVNlbGVjdCgpKSB7XG4gICAgICBPYmplY3Qua2V5cyhzZWxlY3RlZFJvd0lkcykuZm9yRWFjaChrZXkgPT4gZGVsZXRlIHNlbGVjdGVkUm93SWRzW2tleV0pO1xuICAgIH1cbiAgICBpZiAocm93LmdldENhblNlbGVjdCgpKSB7XG4gICAgICBzZWxlY3RlZFJvd0lkc1tpZF0gPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgc2VsZWN0ZWRSb3dJZHNbaWRdO1xuICB9XG4gIC8vIH1cblxuICBpZiAoaW5jbHVkZUNoaWxkcmVuICYmIChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoICYmIHJvdy5nZXRDYW5TZWxlY3RTdWJSb3dzKCkpIHtcbiAgICByb3cuc3ViUm93cy5mb3JFYWNoKHJvdyA9PiBtdXRhdGVSb3dJc1NlbGVjdGVkKHNlbGVjdGVkUm93SWRzLCByb3cuaWQsIHZhbHVlLCBpbmNsdWRlQ2hpbGRyZW4sIHRhYmxlKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBzZWxlY3RSb3dzRm4odGFibGUsIHJvd01vZGVsKSB7XG4gIGNvbnN0IHJvd1NlbGVjdGlvbiA9IHRhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uO1xuICBjb25zdCBuZXdTZWxlY3RlZEZsYXRSb3dzID0gW107XG4gIGNvbnN0IG5ld1NlbGVjdGVkUm93c0J5SWQgPSB7fTtcblxuICAvLyBGaWx0ZXJzIHRvcCBsZXZlbCBhbmQgbmVzdGVkIHJvd3NcbiAgY29uc3QgcmVjdXJzZVJvd3MgPSBmdW5jdGlvbiAocm93cywgZGVwdGgpIHtcbiAgICByZXR1cm4gcm93cy5tYXAocm93ID0+IHtcbiAgICAgIHZhciBfcm93JHN1YlJvd3MyO1xuICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IGlzUm93U2VsZWN0ZWQocm93LCByb3dTZWxlY3Rpb24pO1xuICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgbmV3U2VsZWN0ZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIG5ld1NlbGVjdGVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgIH1cbiAgICAgIGlmICgoX3JvdyRzdWJSb3dzMiA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93czIubGVuZ3RoKSB7XG4gICAgICAgIHJvdyA9IHtcbiAgICAgICAgICAuLi5yb3csXG4gICAgICAgICAgc3ViUm93czogcmVjdXJzZVJvd3Mocm93LnN1YlJvd3MpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gcm93O1xuICAgICAgfVxuICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICByb3dzOiByZWN1cnNlUm93cyhyb3dNb2RlbC5yb3dzKSxcbiAgICBmbGF0Um93czogbmV3U2VsZWN0ZWRGbGF0Um93cyxcbiAgICByb3dzQnlJZDogbmV3U2VsZWN0ZWRSb3dzQnlJZFxuICB9O1xufVxuZnVuY3Rpb24gaXNSb3dTZWxlY3RlZChyb3csIHNlbGVjdGlvbikge1xuICB2YXIgX3NlbGVjdGlvbiRyb3ckaWQ7XG4gIHJldHVybiAoX3NlbGVjdGlvbiRyb3ckaWQgPSBzZWxlY3Rpb25bcm93LmlkXSkgIT0gbnVsbCA/IF9zZWxlY3Rpb24kcm93JGlkIDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc1N1YlJvd1NlbGVjdGVkKHJvdywgc2VsZWN0aW9uLCB0YWJsZSkge1xuICB2YXIgX3JvdyRzdWJSb3dzMztcbiAgaWYgKCEoKF9yb3ckc3ViUm93czMgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MzLmxlbmd0aCkpIHJldHVybiBmYWxzZTtcbiAgbGV0IGFsbENoaWxkcmVuU2VsZWN0ZWQgPSB0cnVlO1xuICBsZXQgc29tZVNlbGVjdGVkID0gZmFsc2U7XG4gIHJvdy5zdWJSb3dzLmZvckVhY2goc3ViUm93ID0+IHtcbiAgICAvLyBCYWlsIG91dCBlYXJseSBpZiB3ZSBrbm93IGJvdGggb2YgdGhlc2VcbiAgICBpZiAoc29tZVNlbGVjdGVkICYmICFhbGxDaGlsZHJlblNlbGVjdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdWJSb3cuZ2V0Q2FuU2VsZWN0KCkpIHtcbiAgICAgIGlmIChpc1Jvd1NlbGVjdGVkKHN1YlJvdywgc2VsZWN0aW9uKSkge1xuICAgICAgICBzb21lU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxsQ2hpbGRyZW5TZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIHJvdyBzZWxlY3Rpb24gb2YgbmVzdGVkIHN1YnJvd3NcbiAgICBpZiAoc3ViUm93LnN1YlJvd3MgJiYgc3ViUm93LnN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdWJSb3dDaGlsZHJlblNlbGVjdGVkID0gaXNTdWJSb3dTZWxlY3RlZChzdWJSb3csIHNlbGVjdGlvbik7XG4gICAgICBpZiAoc3ViUm93Q2hpbGRyZW5TZWxlY3RlZCA9PT0gJ2FsbCcpIHtcbiAgICAgICAgc29tZVNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3ViUm93Q2hpbGRyZW5TZWxlY3RlZCA9PT0gJ3NvbWUnKSB7XG4gICAgICAgIHNvbWVTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYWxsQ2hpbGRyZW5TZWxlY3RlZCA/ICdhbGwnIDogc29tZVNlbGVjdGVkID8gJ3NvbWUnIDogZmFsc2U7XG59XG5cbmNvbnN0IHJlU3BsaXRBbHBoYU51bWVyaWMgPSAvKFswLTldKykvZ207XG5jb25zdCBhbHBoYW51bWVyaWMgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgcmV0dXJuIGNvbXBhcmVBbHBoYW51bWVyaWModG9TdHJpbmcocm93QS5nZXRWYWx1ZShjb2x1bW5JZCkpLnRvTG93ZXJDYXNlKCksIHRvU3RyaW5nKHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKS50b0xvd2VyQ2FzZSgpKTtcbn07XG5jb25zdCBhbHBoYW51bWVyaWNDYXNlU2Vuc2l0aXZlID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQWxwaGFudW1lcmljKHRvU3RyaW5nKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpKSwgdG9TdHJpbmcocm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpKTtcbn07XG5cbi8vIFRoZSB0ZXh0IGZpbHRlciBpcyBtb3JlIGJhc2ljIChsZXNzIG51bWVyaWMgc3VwcG9ydClcbi8vIGJ1dCBpcyBtdWNoIGZhc3RlclxuY29uc3QgdGV4dCA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUJhc2ljKHRvU3RyaW5nKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpKS50b0xvd2VyQ2FzZSgpLCB0b1N0cmluZyhyb3dCLmdldFZhbHVlKGNvbHVtbklkKSkudG9Mb3dlckNhc2UoKSk7XG59O1xuXG4vLyBUaGUgdGV4dCBmaWx0ZXIgaXMgbW9yZSBiYXNpYyAobGVzcyBudW1lcmljIHN1cHBvcnQpXG4vLyBidXQgaXMgbXVjaCBmYXN0ZXJcbmNvbnN0IHRleHRDYXNlU2Vuc2l0aXZlID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQmFzaWModG9TdHJpbmcocm93QS5nZXRWYWx1ZShjb2x1bW5JZCkpLCB0b1N0cmluZyhyb3dCLmdldFZhbHVlKGNvbHVtbklkKSkpO1xufTtcbmNvbnN0IGRhdGV0aW1lID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIGNvbnN0IGEgPSByb3dBLmdldFZhbHVlKGNvbHVtbklkKTtcbiAgY29uc3QgYiA9IHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpO1xuXG4gIC8vIENhbiBoYW5kbGUgbnVsbGlzaCB2YWx1ZXNcbiAgLy8gVXNlID4gYW5kIDwgYmVjYXVzZSA9PSAoYW5kID09PSkgZG9lc24ndCB3b3JrIHdpdGhcbiAgLy8gRGF0ZSBvYmplY3RzICh3b3VsZCByZXF1aXJlIGNhbGxpbmcgZ2V0VGltZSgpKS5cbiAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xufTtcbmNvbnN0IGJhc2ljID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQmFzaWMocm93QS5nZXRWYWx1ZShjb2x1bW5JZCksIHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKTtcbn07XG5cbi8vIFV0aWxzXG5cbmZ1bmN0aW9uIGNvbXBhcmVCYXNpYyhhLCBiKSB7XG4gIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xufVxuZnVuY3Rpb24gdG9TdHJpbmcoYSkge1xuICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKGlzTmFOKGEpIHx8IGEgPT09IEluZmluaXR5IHx8IGEgPT09IC1JbmZpbml0eSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGEpO1xuICB9XG4gIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYTtcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8vIE1peGVkIHNvcnRpbmcgaXMgc2xvdywgYnV0IHZlcnkgaW5jbHVzaXZlIG9mIG1hbnkgZWRnZSBjYXNlcy5cbi8vIEl0IGhhbmRsZXMgbnVtYmVycywgbWl4ZWQgYWxwaGFudW1lcmljIGNvbWJpbmF0aW9ucywgYW5kIGV2ZW5cbi8vIG51bGwsIHVuZGVmaW5lZCwgYW5kIEluZmluaXR5XG5mdW5jdGlvbiBjb21wYXJlQWxwaGFudW1lcmljKGFTdHIsIGJTdHIpIHtcbiAgLy8gU3BsaXQgb24gbnVtYmVyIGdyb3VwcywgYnV0IGtlZXAgdGhlIGRlbGltaXRlclxuICAvLyBUaGVuIHJlbW92ZSBmYWxzZXkgc3BsaXQgdmFsdWVzXG4gIGNvbnN0IGEgPSBhU3RyLnNwbGl0KHJlU3BsaXRBbHBoYU51bWVyaWMpLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3QgYiA9IGJTdHIuc3BsaXQocmVTcGxpdEFscGhhTnVtZXJpYykuZmlsdGVyKEJvb2xlYW4pO1xuXG4gIC8vIFdoaWxlXG4gIHdoaWxlIChhLmxlbmd0aCAmJiBiLmxlbmd0aCkge1xuICAgIGNvbnN0IGFhID0gYS5zaGlmdCgpO1xuICAgIGNvbnN0IGJiID0gYi5zaGlmdCgpO1xuICAgIGNvbnN0IGFuID0gcGFyc2VJbnQoYWEsIDEwKTtcbiAgICBjb25zdCBibiA9IHBhcnNlSW50KGJiLCAxMCk7XG4gICAgY29uc3QgY29tYm8gPSBbYW4sIGJuXS5zb3J0KCk7XG5cbiAgICAvLyBCb3RoIGFyZSBzdHJpbmdcbiAgICBpZiAoaXNOYU4oY29tYm9bMF0pKSB7XG4gICAgICBpZiAoYWEgPiBiYikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmIChiYiA+IGFhKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIE9uZSBpcyBhIHN0cmluZywgb25lIGlzIGEgbnVtYmVyXG4gICAgaWYgKGlzTmFOKGNvbWJvWzFdKSkge1xuICAgICAgcmV0dXJuIGlzTmFOKGFuKSA/IC0xIDogMTtcbiAgICB9XG5cbiAgICAvLyBCb3RoIGFyZSBudW1iZXJzXG4gICAgaWYgKGFuID4gYm4pIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoYm4gPiBhbikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbn1cblxuLy8gRXhwb3J0c1xuXG5jb25zdCBzb3J0aW5nRm5zID0ge1xuICBhbHBoYW51bWVyaWMsXG4gIGFscGhhbnVtZXJpY0Nhc2VTZW5zaXRpdmUsXG4gIHRleHQsXG4gIHRleHRDYXNlU2Vuc2l0aXZlLFxuICBkYXRldGltZSxcbiAgYmFzaWNcbn07XG5cbi8vXG5cbmNvbnN0IFNvcnRpbmcgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzb3J0aW5nOiBbXSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzb3J0aW5nRm46ICdhdXRvJyxcbiAgICAgIHNvcnRVbmRlZmluZWQ6IDFcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvblNvcnRpbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ3NvcnRpbmcnLCB0YWJsZSksXG4gICAgICBpc011bHRpU29ydEV2ZW50OiBlID0+IHtcbiAgICAgICAgcmV0dXJuIGUuc2hpZnRLZXk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi5nZXRBdXRvU29ydGluZ0ZuID0gKCkgPT4ge1xuICAgICAgY29uc3QgZmlyc3RSb3dzID0gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzLnNsaWNlKDEwKTtcbiAgICAgIGxldCBpc1N0cmluZyA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCByb3cgb2YgZmlyc3RSb3dzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcm93ID09IG51bGwgPyB2b2lkIDAgOiByb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgICAgICAgIHJldHVybiBzb3J0aW5nRm5zLmRhdGV0aW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaXNTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgIGlmICh2YWx1ZS5zcGxpdChyZVNwbGl0QWxwaGFOdW1lcmljKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydGluZ0Zucy5hbHBoYW51bWVyaWM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRpbmdGbnMudGV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzb3J0aW5nRm5zLmJhc2ljO1xuICAgIH07XG4gICAgY29sdW1uLmdldEF1dG9Tb3J0RGlyID0gKCkgPT4ge1xuICAgICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCkuZmxhdFJvd3NbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IGZpcnN0Um93ID09IG51bGwgPyB2b2lkIDAgOiBmaXJzdFJvdy5nZXRWYWx1ZShjb2x1bW4uaWQpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuICdhc2MnO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdkZXNjJztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRTb3J0aW5nRm4gPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkc29ydGluLCBfdGFibGUkb3B0aW9ucyRzb3J0aW4yO1xuICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbikgPyBjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbiA6IGNvbHVtbi5jb2x1bW5EZWYuc29ydGluZ0ZuID09PSAnYXV0bycgPyBjb2x1bW4uZ2V0QXV0b1NvcnRpbmdGbigpIDogKF90YWJsZSRvcHRpb25zJHNvcnRpbiA9IChfdGFibGUkb3B0aW9ucyRzb3J0aW4yID0gdGFibGUub3B0aW9ucy5zb3J0aW5nRm5zKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJG9wdGlvbnMkc29ydGluMltjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbl0pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRzb3J0aW4gOiBzb3J0aW5nRm5zW2NvbHVtbi5jb2x1bW5EZWYuc29ydGluZ0ZuXTtcbiAgICB9O1xuICAgIGNvbHVtbi50b2dnbGVTb3J0aW5nID0gKGRlc2MsIG11bHRpKSA9PiB7XG4gICAgICAvLyBpZiAoY29sdW1uLmNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAvLyAgIGNvbHVtbi5jb2x1bW5zLmZvckVhY2goKGMsIGkpID0+IHtcbiAgICAgIC8vICAgICBpZiAoYy5pZCkge1xuICAgICAgLy8gICAgICAgdGFibGUudG9nZ2xlQ29sdW1uU29ydGluZyhjLmlkLCB1bmRlZmluZWQsIG11bHRpIHx8ICEhaSlcbiAgICAgIC8vICAgICB9XG4gICAgICAvLyAgIH0pXG4gICAgICAvLyAgIHJldHVyblxuICAgICAgLy8gfVxuXG4gICAgICAvLyB0aGlzIG5lZWRzIHRvIGJlIG91dHNpZGUgb2YgdGFibGUuc2V0U29ydGluZyB0byBiZSBpbiBzeW5jIHdpdGggcmVyZW5kZXJcbiAgICAgIGNvbnN0IG5leHRTb3J0aW5nT3JkZXIgPSBjb2x1bW4uZ2V0TmV4dFNvcnRpbmdPcmRlcigpO1xuICAgICAgY29uc3QgaGFzTWFudWFsVmFsdWUgPSB0eXBlb2YgZGVzYyAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVzYyAhPT0gbnVsbDtcbiAgICAgIHRhYmxlLnNldFNvcnRpbmcob2xkID0+IHtcbiAgICAgICAgLy8gRmluZCBhbnkgZXhpc3Rpbmcgc29ydGluZyBmb3IgdGhpcyBjb2x1bW5cbiAgICAgICAgY29uc3QgZXhpc3RpbmdTb3J0aW5nID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpO1xuICAgICAgICBsZXQgbmV3U29ydGluZyA9IFtdO1xuXG4gICAgICAgIC8vIFdoYXQgc2hvdWxkIHdlIGRvIHdpdGggdGhpcyBzb3J0IGFjdGlvbj9cbiAgICAgICAgbGV0IHNvcnRBY3Rpb247XG4gICAgICAgIGxldCBuZXh0RGVzYyA9IGhhc01hbnVhbFZhbHVlID8gZGVzYyA6IG5leHRTb3J0aW5nT3JkZXIgPT09ICdkZXNjJztcblxuICAgICAgICAvLyBNdWx0aS1tb2RlXG4gICAgICAgIGlmIChvbGQgIT0gbnVsbCAmJiBvbGQubGVuZ3RoICYmIGNvbHVtbi5nZXRDYW5NdWx0aVNvcnQoKSAmJiBtdWx0aSkge1xuICAgICAgICAgIGlmIChleGlzdGluZ1NvcnRpbmcpIHtcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAndG9nZ2xlJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICdhZGQnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb3JtYWwgbW9kZVxuICAgICAgICAgIGlmIChvbGQgIT0gbnVsbCAmJiBvbGQubGVuZ3RoICYmIGV4aXN0aW5nSW5kZXggIT09IG9sZC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3JlcGxhY2UnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdTb3J0aW5nKSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3RvZ2dsZSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAncmVwbGFjZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIHRvZ2dsZSBzdGF0ZXMgdGhhdCB3aWxsIHJlbW92ZSB0aGUgc29ydGluZ1xuICAgICAgICBpZiAoc29ydEFjdGlvbiA9PT0gJ3RvZ2dsZScpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBhcmUgXCJhY3R1YWxseVwiIHRvZ2dsaW5nIChub3QgYSBtYW51YWwgc2V0IHZhbHVlKSwgc2hvdWxkIHdlIHJlbW92ZSB0aGUgc29ydGluZz9cbiAgICAgICAgICBpZiAoIWhhc01hbnVhbFZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJcyBvdXIgaW50ZW50aW9uIHRvIHJlbW92ZT9cbiAgICAgICAgICAgIGlmICghbmV4dFNvcnRpbmdPcmRlcikge1xuICAgICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3JlbW92ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzb3J0QWN0aW9uID09PSAnYWRkJykge1xuICAgICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRtYXhNdWw7XG4gICAgICAgICAgbmV3U29ydGluZyA9IFsuLi5vbGQsIHtcbiAgICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXG4gICAgICAgICAgICBkZXNjOiBuZXh0RGVzY1xuICAgICAgICAgIH1dO1xuICAgICAgICAgIC8vIFRha2UgbGF0ZXN0IG4gY29sdW1uc1xuICAgICAgICAgIG5ld1NvcnRpbmcuc3BsaWNlKDAsIG5ld1NvcnRpbmcubGVuZ3RoIC0gKChfdGFibGUkb3B0aW9ucyRtYXhNdWwgPSB0YWJsZS5vcHRpb25zLm1heE11bHRpU29ydENvbENvdW50KSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkbWF4TXVsIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3J0QWN0aW9uID09PSAndG9nZ2xlJykge1xuICAgICAgICAgIC8vIFRoaXMgZmxpcHMgKG9yIHNldHMpIHRoZVxuICAgICAgICAgIG5ld1NvcnRpbmcgPSBvbGQubWFwKGQgPT4ge1xuICAgICAgICAgICAgaWYgKGQuaWQgPT09IGNvbHVtbi5pZCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmQsXG4gICAgICAgICAgICAgICAgZGVzYzogbmV4dERlc2NcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHNvcnRBY3Rpb24gPT09ICdyZW1vdmUnKSB7XG4gICAgICAgICAgbmV3U29ydGluZyA9IG9sZC5maWx0ZXIoZCA9PiBkLmlkICE9PSBjb2x1bW4uaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1NvcnRpbmcgPSBbe1xuICAgICAgICAgICAgaWQ6IGNvbHVtbi5pZCxcbiAgICAgICAgICAgIGRlc2M6IG5leHREZXNjXG4gICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1NvcnRpbmc7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRGaXJzdFNvcnREaXIgPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZiwgX2NvbHVtbiRjb2x1bW5EZWYkc29yO1xuICAgICAgY29uc3Qgc29ydERlc2NGaXJzdCA9IChfcmVmID0gKF9jb2x1bW4kY29sdW1uRGVmJHNvciA9IGNvbHVtbi5jb2x1bW5EZWYuc29ydERlc2NGaXJzdCkgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJHNvciA6IHRhYmxlLm9wdGlvbnMuc29ydERlc2NGaXJzdCkgIT0gbnVsbCA/IF9yZWYgOiBjb2x1bW4uZ2V0QXV0b1NvcnREaXIoKSA9PT0gJ2Rlc2MnO1xuICAgICAgcmV0dXJuIHNvcnREZXNjRmlyc3QgPyAnZGVzYycgOiAnYXNjJztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXROZXh0U29ydGluZ09yZGVyID0gbXVsdGkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGVuYWJsZSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMjtcbiAgICAgIGNvbnN0IGZpcnN0U29ydERpcmVjdGlvbiA9IGNvbHVtbi5nZXRGaXJzdFNvcnREaXIoKTtcbiAgICAgIGNvbnN0IGlzU29ydGVkID0gY29sdW1uLmdldElzU29ydGVkKCk7XG4gICAgICBpZiAoIWlzU29ydGVkKSB7XG4gICAgICAgIHJldHVybiBmaXJzdFNvcnREaXJlY3Rpb247XG4gICAgICB9XG4gICAgICBpZiAoaXNTb3J0ZWQgIT09IGZpcnN0U29ydERpcmVjdGlvbiAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlU29ydGluZ1JlbW92YWwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlKSAmJiAoXG4gICAgICAvLyBJZiBlbmFibGVTb3J0UmVtb3ZlLCBlbmFibGUgaW4gZ2VuZXJhbFxuICAgICAgbXVsdGkgPyAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlSZW1vdmUpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUyIDogdHJ1ZSA6IHRydWUpIC8vIElmIG11bHRpLCBkb24ndCBhbGxvdyBpZiBlbmFibGVNdWx0aVJlbW92ZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU29ydGVkID09PSAnZGVzYycgPyAnYXNjJyA6ICdkZXNjJztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5Tb3J0ID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJGVuYSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMztcbiAgICAgIHJldHVybiAoKF9jb2x1bW4kY29sdW1uRGVmJGVuYSA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlU29ydGluZykgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlU29ydGluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTMgOiB0cnVlKSAmJiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhbk11bHRpU29ydCA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmMiwgX2NvbHVtbiRjb2x1bW5EZWYkZW5hMjtcbiAgICAgIHJldHVybiAoX3JlZjIgPSAoX2NvbHVtbiRjb2x1bW5EZWYkZW5hMiA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlTXVsdGlTb3J0KSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hMiA6IHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlTb3J0KSAhPSBudWxsID8gX3JlZjIgOiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzU29ydGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRzb3J0aTtcbiAgICAgIGNvbnN0IGNvbHVtblNvcnQgPSAoX3RhYmxlJGdldFN0YXRlJHNvcnRpID0gdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJHNvcnRpLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpO1xuICAgICAgcmV0dXJuICFjb2x1bW5Tb3J0ID8gZmFsc2UgOiBjb2x1bW5Tb3J0LmRlc2MgPyAnZGVzYycgOiAnYXNjJztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRTb3J0SW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJHNvcnRpMiwgX3RhYmxlJGdldFN0YXRlJHNvcnRpMztcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJHNvcnRpMiA9IChfdGFibGUkZ2V0U3RhdGUkc29ydGkzID0gdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJHNvcnRpMy5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpKSAhPSBudWxsID8gX3RhYmxlJGdldFN0YXRlJHNvcnRpMiA6IC0xO1xuICAgIH07XG4gICAgY29sdW1uLmNsZWFyU29ydGluZyA9ICgpID0+IHtcbiAgICAgIC8vY2xlYXIgc29ydGluZyBmb3IganVzdCAxIGNvbHVtblxuICAgICAgdGFibGUuc2V0U29ydGluZyhvbGQgPT4gb2xkICE9IG51bGwgJiYgb2xkLmxlbmd0aCA/IG9sZC5maWx0ZXIoZCA9PiBkLmlkICE9PSBjb2x1bW4uaWQpIDogW10pO1xuICAgIH07XG4gICAgY29sdW1uLmdldFRvZ2dsZVNvcnRpbmdIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FuU29ydCA9IGNvbHVtbi5nZXRDYW5Tb3J0KCk7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIGlmICghY2FuU29ydCkgcmV0dXJuO1xuICAgICAgICBlLnBlcnNpc3QgPT0gbnVsbCB8fCBlLnBlcnNpc3QoKTtcbiAgICAgICAgY29sdW1uLnRvZ2dsZVNvcnRpbmcgPT0gbnVsbCB8fCBjb2x1bW4udG9nZ2xlU29ydGluZyh1bmRlZmluZWQsIGNvbHVtbi5nZXRDYW5NdWx0aVNvcnQoKSA/IHRhYmxlLm9wdGlvbnMuaXNNdWx0aVNvcnRFdmVudCA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5pc011bHRpU29ydEV2ZW50KGUpIDogZmFsc2UpO1xuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldFNvcnRpbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Tb3J0aW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uU29ydGluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldFNvcnRpbmcgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcywgX3RhYmxlJGluaXRpYWxTdGF0ZTtcbiAgICAgIHRhYmxlLnNldFNvcnRpbmcoZGVmYXVsdFN0YXRlID8gW10gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRzID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLnNvcnRpbmcpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHMgOiBbXSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVTb3J0ZWRSb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldEdyb3VwZWRSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldFNvcnRlZFJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0U29ydGVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRTb3J0ZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0U29ydGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldFNvcnRlZFJvd01vZGVsKHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbFNvcnRpbmcgfHwgIXRhYmxlLl9nZXRTb3J0ZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlU29ydGVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0U29ydGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICB9XG59O1xuXG4vL1xuXG5jb25zdCBWaXNpYmlsaXR5ID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uVmlzaWJpbGl0eToge30sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ29sdW1uVmlzaWJpbGl0eUNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uVmlzaWJpbGl0eScsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4udG9nZ2xlVmlzaWJpbGl0eSA9IHZhbHVlID0+IHtcbiAgICAgIGlmIChjb2x1bW4uZ2V0Q2FuSGlkZSgpKSB7XG4gICAgICAgIHRhYmxlLnNldENvbHVtblZpc2liaWxpdHkob2xkID0+ICh7XG4gICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgIFtjb2x1bW4uaWRdOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiAhY29sdW1uLmdldElzVmlzaWJsZSgpXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbHVtbi5nZXRJc1Zpc2libGUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZiwgX3RhYmxlJGdldFN0YXRlJGNvbHVtO1xuICAgICAgY29uc3QgY2hpbGRDb2x1bW5zID0gY29sdW1uLmNvbHVtbnM7XG4gICAgICByZXR1cm4gKF9yZWYgPSBjaGlsZENvbHVtbnMubGVuZ3RoID8gY2hpbGRDb2x1bW5zLnNvbWUoYyA9PiBjLmdldElzVmlzaWJsZSgpKSA6IChfdGFibGUkZ2V0U3RhdGUkY29sdW0gPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblZpc2liaWxpdHkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkY29sdW1bY29sdW1uLmlkXSkgIT0gbnVsbCA/IF9yZWYgOiB0cnVlO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhbkhpZGUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUhpZGluZykgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVIaWRpbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRUb2dnbGVWaXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgY29sdW1uLnRvZ2dsZVZpc2liaWxpdHkgPT0gbnVsbCB8fCBjb2x1bW4udG9nZ2xlVmlzaWJpbGl0eShlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAocm93LCB0YWJsZSkgPT4ge1xuICAgIHJvdy5fZ2V0QWxsVmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93LmdldEFsbENlbGxzKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uVmlzaWJpbGl0eV0sIGNlbGxzID0+IHtcbiAgICAgIHJldHVybiBjZWxscy5maWx0ZXIoY2VsbCA9PiBjZWxsLmNvbHVtbi5nZXRJc1Zpc2libGUoKSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdfZ2V0QWxsVmlzaWJsZUNlbGxzJykpO1xuICAgIHJvdy5nZXRWaXNpYmxlQ2VsbHMgPSBtZW1vKCgpID0+IFtyb3cuZ2V0TGVmdFZpc2libGVDZWxscygpLCByb3cuZ2V0Q2VudGVyVmlzaWJsZUNlbGxzKCksIHJvdy5nZXRSaWdodFZpc2libGVDZWxscygpXSwgKGxlZnQsIGNlbnRlciwgcmlnaHQpID0+IFsuLi5sZWZ0LCAuLi5jZW50ZXIsIC4uLnJpZ2h0XSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRWaXNpYmxlQ2VsbHMnKSk7XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgY29uc3QgbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kID0gKGtleSwgZ2V0Q29sdW1ucykgPT4ge1xuICAgICAgcmV0dXJuIG1lbW8oKCkgPT4gW2dldENvbHVtbnMoKSwgZ2V0Q29sdW1ucygpLmZpbHRlcihkID0+IGQuZ2V0SXNWaXNpYmxlKCkpLm1hcChkID0+IGQuaWQpLmpvaW4oJ18nKV0sIGNvbHVtbnMgPT4ge1xuICAgICAgICByZXR1cm4gY29sdW1ucy5maWx0ZXIoZCA9PiBkLmdldElzVmlzaWJsZSA9PSBudWxsID8gdm9pZCAwIDogZC5nZXRJc1Zpc2libGUoKSk7XG4gICAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywga2V5KSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRWaXNpYmxlRmxhdENvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoJ2dldFZpc2libGVGbGF0Q29sdW1ucycsICgpID0+IHRhYmxlLmdldEFsbEZsYXRDb2x1bW5zKCkpO1xuICAgIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0VmlzaWJsZUxlYWZDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKSk7XG4gICAgdGFibGUuZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucycsICgpID0+IHRhYmxlLmdldExlZnRMZWFmQ29sdW1ucygpKTtcbiAgICB0YWJsZS5nZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0UmlnaHRWaXNpYmxlTGVhZkNvbHVtbnMnLCAoKSA9PiB0YWJsZS5nZXRSaWdodExlYWZDb2x1bW5zKCkpO1xuICAgIHRhYmxlLmdldENlbnRlclZpc2libGVMZWFmQ29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0Q2VudGVyVmlzaWJsZUxlYWZDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0Q2VudGVyTGVhZkNvbHVtbnMoKSk7XG4gICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eSA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtblZpc2liaWxpdHlDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Q29sdW1uVmlzaWJpbGl0eSA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjO1xuICAgICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eShkZWZhdWx0U3RhdGUgPyB7fSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMgPSB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uVmlzaWJpbGl0eSkgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYyA6IHt9KTtcbiAgICB9O1xuICAgIHRhYmxlLnRvZ2dsZUFsbENvbHVtbnNWaXNpYmxlID0gdmFsdWUgPT4ge1xuICAgICAgdmFyIF92YWx1ZTtcbiAgICAgIHZhbHVlID0gKF92YWx1ZSA9IHZhbHVlKSAhPSBudWxsID8gX3ZhbHVlIDogIXRhYmxlLmdldElzQWxsQ29sdW1uc1Zpc2libGUoKTtcbiAgICAgIHRhYmxlLnNldENvbHVtblZpc2liaWxpdHkodGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5yZWR1Y2UoKG9iaiwgY29sdW1uKSA9PiAoe1xuICAgICAgICAuLi5vYmosXG4gICAgICAgIFtjb2x1bW4uaWRdOiAhdmFsdWUgPyAhKGNvbHVtbi5nZXRDYW5IaWRlICE9IG51bGwgJiYgY29sdW1uLmdldENhbkhpZGUoKSkgOiB2YWx1ZVxuICAgICAgfSksIHt9KSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc0FsbENvbHVtbnNWaXNpYmxlID0gKCkgPT4gIXRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCkuc29tZShjb2x1bW4gPT4gIShjb2x1bW4uZ2V0SXNWaXNpYmxlICE9IG51bGwgJiYgY29sdW1uLmdldElzVmlzaWJsZSgpKSk7XG4gICAgdGFibGUuZ2V0SXNTb21lQ29sdW1uc1Zpc2libGUgPSAoKSA9PiB0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLnNvbWUoY29sdW1uID0+IGNvbHVtbi5nZXRJc1Zpc2libGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbHVtbi5nZXRJc1Zpc2libGUoKSk7XG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsQ29sdW1uc1Zpc2liaWxpdHlIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICB2YXIgX3RhcmdldDtcbiAgICAgICAgdGFibGUudG9nZ2xlQWxsQ29sdW1uc1Zpc2libGUoKF90YXJnZXQgPSBlLnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBfZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKHRhYmxlLCBwb3NpdGlvbikge1xuICByZXR1cm4gIXBvc2l0aW9uID8gdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCkgOiBwb3NpdGlvbiA9PT0gJ2NlbnRlcicgPyB0YWJsZS5nZXRDZW50ZXJWaXNpYmxlTGVhZkNvbHVtbnMoKSA6IHBvc2l0aW9uID09PSAnbGVmdCcgPyB0YWJsZS5nZXRMZWZ0VmlzaWJsZUxlYWZDb2x1bW5zKCkgOiB0YWJsZS5nZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucygpO1xufVxuXG5jb25zdCBmZWF0dXJlcyA9IFtIZWFkZXJzLCBWaXNpYmlsaXR5LCBPcmRlcmluZywgUGlubmluZywgRmlsdGVycywgU29ydGluZywgR3JvdXBpbmcsIEV4cGFuZGluZywgUGFnaW5hdGlvbiwgUm93U2VsZWN0aW9uLCBDb2x1bW5TaXppbmddO1xuXG4vL1xuXG5mdW5jdGlvbiBjcmVhdGVUYWJsZShvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRpbml0aWFsU3RhdGU7XG4gIGlmIChvcHRpb25zLmRlYnVnQWxsIHx8IG9wdGlvbnMuZGVidWdUYWJsZSkge1xuICAgIGNvbnNvbGUuaW5mbygnQ3JlYXRpbmcgVGFibGUgSW5zdGFuY2UuLi4nKTtcbiAgfVxuICBsZXQgdGFibGUgPSB7XG4gICAgX2ZlYXR1cmVzOiBmZWF0dXJlc1xuICB9O1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHRhYmxlLl9mZWF0dXJlcy5yZWR1Y2UoKG9iaiwgZmVhdHVyZSkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgZmVhdHVyZS5nZXREZWZhdWx0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogZmVhdHVyZS5nZXREZWZhdWx0T3B0aW9ucyh0YWJsZSkpO1xuICB9LCB7fSk7XG4gIGNvbnN0IG1lcmdlT3B0aW9ucyA9IG9wdGlvbnMgPT4ge1xuICAgIGlmICh0YWJsZS5vcHRpb25zLm1lcmdlT3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMubWVyZ2VPcHRpb25zKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gIH07XG4gIGNvbnN0IGNvcmVJbml0aWFsU3RhdGUgPSB7fTtcbiAgbGV0IGluaXRpYWxTdGF0ZSA9IHtcbiAgICAuLi5jb3JlSW5pdGlhbFN0YXRlLFxuICAgIC4uLigoX29wdGlvbnMkaW5pdGlhbFN0YXRlID0gb3B0aW9ucy5pbml0aWFsU3RhdGUpICE9IG51bGwgPyBfb3B0aW9ucyRpbml0aWFsU3RhdGUgOiB7fSlcbiAgfTtcbiAgdGFibGUuX2ZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgdmFyIF9mZWF0dXJlJGdldEluaXRpYWxTdDtcbiAgICBpbml0aWFsU3RhdGUgPSAoX2ZlYXR1cmUkZ2V0SW5pdGlhbFN0ID0gZmVhdHVyZS5nZXRJbml0aWFsU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZlYXR1cmUuZ2V0SW5pdGlhbFN0YXRlKGluaXRpYWxTdGF0ZSkpICE9IG51bGwgPyBfZmVhdHVyZSRnZXRJbml0aWFsU3QgOiBpbml0aWFsU3RhdGU7XG4gIH0pO1xuICBjb25zdCBxdWV1ZWQgPSBbXTtcbiAgbGV0IHF1ZXVlZFRpbWVvdXQgPSBmYWxzZTtcbiAgY29uc3QgY29yZUluc3RhbmNlID0ge1xuICAgIF9mZWF0dXJlczogZmVhdHVyZXMsXG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSxcbiAgICBpbml0aWFsU3RhdGUsXG4gICAgX3F1ZXVlOiBjYiA9PiB7XG4gICAgICBxdWV1ZWQucHVzaChjYik7XG4gICAgICBpZiAoIXF1ZXVlZFRpbWVvdXQpIHtcbiAgICAgICAgcXVldWVkVGltZW91dCA9IHRydWU7XG5cbiAgICAgICAgLy8gU2NoZWR1bGUgYSBtaWNyb3Rhc2sgdG8gcnVuIHRoZSBxdWV1ZWQgY2FsbGJhY2tzIGFmdGVyXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgKHJlbmRlciwgZXRjKSBoYXMgZmluaXNoZWQuXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHdoaWxlIChxdWV1ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBxdWV1ZWQuc2hpZnQoKSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxdWV1ZWRUaW1lb3V0ID0gZmFsc2U7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZXNldDogKCkgPT4ge1xuICAgICAgdGFibGUuc2V0U3RhdGUodGFibGUuaW5pdGlhbFN0YXRlKTtcbiAgICB9LFxuICAgIHNldE9wdGlvbnM6IHVwZGF0ZXIgPT4ge1xuICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgdGFibGUub3B0aW9ucyk7XG4gICAgICB0YWJsZS5vcHRpb25zID0gbWVyZ2VPcHRpb25zKG5ld09wdGlvbnMpO1xuICAgIH0sXG4gICAgZ2V0U3RhdGU6ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLnN0YXRlO1xuICAgIH0sXG4gICAgc2V0U3RhdGU6IHVwZGF0ZXIgPT4ge1xuICAgICAgdGFibGUub3B0aW9ucy5vblN0YXRlQ2hhbmdlID09IG51bGwgfHwgdGFibGUub3B0aW9ucy5vblN0YXRlQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIH0sXG4gICAgX2dldFJvd0lkOiAocm93LCBpbmRleCwgcGFyZW50KSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZ2V0Um93O1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRnZXRSb3cgPSB0YWJsZS5vcHRpb25zLmdldFJvd0lkID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmdldFJvd0lkKHJvdywgaW5kZXgsIHBhcmVudCkpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRnZXRSb3cgOiBgJHtwYXJlbnQgPyBbcGFyZW50LmlkLCBpbmRleF0uam9pbignLicpIDogaW5kZXh9YDtcbiAgICB9LFxuICAgIGdldENvcmVSb3dNb2RlbDogKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0Q29yZVJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRDb3JlUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldENvcmVSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldENvcmVSb3dNb2RlbCgpO1xuICAgIH0sXG4gICAgLy8gVGhlIGZpbmFsIGNhbGxzIHN0YXJ0IGF0IHRoZSBib3R0b20gb2YgdGhlIG1vZGVsLFxuICAgIC8vIGV4cGFuZGVkIHJvd3MsIHdoaWNoIHRoZW4gd29yayB0aGVpciB3YXkgdXBcblxuICAgIGdldFJvd01vZGVsOiAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuZ2V0UGFnaW5hdGlvblJvd01vZGVsKCk7XG4gICAgfSxcbiAgICAvL2luIG5leHQgdmVyc2lvbiwgd2Ugc2hvdWxkIGp1c3QgcGFzcyBpbiB0aGUgcm93IG1vZGVsIGFzIHRoZSBvcHRpb25hbCAybmQgYXJnXG4gICAgZ2V0Um93OiAoaWQsIHNlYXJjaEFsbCkgPT4ge1xuICAgICAgbGV0IHJvdyA9IChzZWFyY2hBbGwgPyB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKSA6IHRhYmxlLmdldFJvd01vZGVsKCkpLnJvd3NCeUlkW2lkXTtcbiAgICAgIGlmICghcm93KSB7XG4gICAgICAgIHJvdyA9IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpLnJvd3NCeUlkW2lkXTtcbiAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBnZXRSb3cgY291bGQgbm90IGZpbmQgcm93IHdpdGggSUQ6ICR7aWR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93O1xuICAgIH0sXG4gICAgX2dldERlZmF1bHRDb2x1bW5EZWY6IG1lbW8oKCkgPT4gW3RhYmxlLm9wdGlvbnMuZGVmYXVsdENvbHVtbl0sIGRlZmF1bHRDb2x1bW4gPT4ge1xuICAgICAgdmFyIF9kZWZhdWx0Q29sdW1uO1xuICAgICAgZGVmYXVsdENvbHVtbiA9IChfZGVmYXVsdENvbHVtbiA9IGRlZmF1bHRDb2x1bW4pICE9IG51bGwgPyBfZGVmYXVsdENvbHVtbiA6IHt9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZGVyOiBwcm9wcyA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzb2x2ZWRDb2x1bW5EZWYgPSBwcm9wcy5oZWFkZXIuY29sdW1uLmNvbHVtbkRlZjtcbiAgICAgICAgICBpZiAocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvcktleTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yRm4pIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZENvbHVtbkRlZi5pZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGZvb3RlcjogcHJvcHMgPT4gcHJvcHMuaGVhZGVyLmNvbHVtbi5pZCxcbiAgICAgICAgY2VsbDogcHJvcHMgPT4ge1xuICAgICAgICAgIHZhciBfcHJvcHMkcmVuZGVyVmFsdWUkdG8sIF9wcm9wcyRyZW5kZXJWYWx1ZTtcbiAgICAgICAgICByZXR1cm4gKF9wcm9wcyRyZW5kZXJWYWx1ZSR0byA9IChfcHJvcHMkcmVuZGVyVmFsdWUgPSBwcm9wcy5yZW5kZXJWYWx1ZSgpKSA9PSBudWxsIHx8IF9wcm9wcyRyZW5kZXJWYWx1ZS50b1N0cmluZyA9PSBudWxsID8gdm9pZCAwIDogX3Byb3BzJHJlbmRlclZhbHVlLnRvU3RyaW5nKCkpICE9IG51bGwgPyBfcHJvcHMkcmVuZGVyVmFsdWUkdG8gOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAuLi50YWJsZS5fZmVhdHVyZXMucmVkdWNlKChvYmosIGZlYXR1cmUpID0+IHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvYmosIGZlYXR1cmUuZ2V0RGVmYXVsdENvbHVtbkRlZiA9PSBudWxsID8gdm9pZCAwIDogZmVhdHVyZS5nZXREZWZhdWx0Q29sdW1uRGVmKCkpO1xuICAgICAgICB9LCB7fSksXG4gICAgICAgIC4uLmRlZmF1bHRDb2x1bW5cbiAgICAgIH07XG4gICAgfSwgZ2V0TWVtb09wdGlvbnMob3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdfZ2V0RGVmYXVsdENvbHVtbkRlZicpKSxcbiAgICBfZ2V0Q29sdW1uRGVmczogKCkgPT4gdGFibGUub3B0aW9ucy5jb2x1bW5zLFxuICAgIGdldEFsbENvbHVtbnM6IG1lbW8oKCkgPT4gW3RhYmxlLl9nZXRDb2x1bW5EZWZzKCldLCBjb2x1bW5EZWZzID0+IHtcbiAgICAgIGNvbnN0IHJlY3Vyc2VDb2x1bW5zID0gZnVuY3Rpb24gKGNvbHVtbkRlZnMsIHBhcmVudCwgZGVwdGgpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgICBkZXB0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbHVtbkRlZnMubWFwKGNvbHVtbkRlZiA9PiB7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gY3JlYXRlQ29sdW1uKHRhYmxlLCBjb2x1bW5EZWYsIGRlcHRoLCBwYXJlbnQpO1xuICAgICAgICAgIGNvbnN0IGdyb3VwaW5nQ29sdW1uRGVmID0gY29sdW1uRGVmO1xuICAgICAgICAgIGNvbHVtbi5jb2x1bW5zID0gZ3JvdXBpbmdDb2x1bW5EZWYuY29sdW1ucyA/IHJlY3Vyc2VDb2x1bW5zKGdyb3VwaW5nQ29sdW1uRGVmLmNvbHVtbnMsIGNvbHVtbiwgZGVwdGggKyAxKSA6IFtdO1xuICAgICAgICAgIHJldHVybiBjb2x1bW47XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZWN1cnNlQ29sdW1ucyhjb2x1bW5EZWZzKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyhvcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldEFsbENvbHVtbnMnKSksXG4gICAgZ2V0QWxsRmxhdENvbHVtbnM6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKV0sIGFsbENvbHVtbnMgPT4ge1xuICAgICAgcmV0dXJuIGFsbENvbHVtbnMuZmxhdE1hcChjb2x1bW4gPT4ge1xuICAgICAgICByZXR1cm4gY29sdW1uLmdldEZsYXRDb2x1bW5zKCk7XG4gICAgICB9KTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyhvcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldEFsbEZsYXRDb2x1bW5zJykpLFxuICAgIF9nZXRBbGxGbGF0Q29sdW1uc0J5SWQ6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbEZsYXRDb2x1bW5zKCldLCBmbGF0Q29sdW1ucyA9PiB7XG4gICAgICByZXR1cm4gZmxhdENvbHVtbnMucmVkdWNlKChhY2MsIGNvbHVtbikgPT4ge1xuICAgICAgICBhY2NbY29sdW1uLmlkXSA9IGNvbHVtbjtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyhvcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldEFsbEZsYXRDb2x1bW5zQnlJZCcpKSxcbiAgICBnZXRBbGxMZWFmQ29sdW1uczogbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpLCB0YWJsZS5fZ2V0T3JkZXJDb2x1bW5zRm4oKV0sIChhbGxDb2x1bW5zLCBvcmRlckNvbHVtbnMpID0+IHtcbiAgICAgIGxldCBsZWFmQ29sdW1ucyA9IGFsbENvbHVtbnMuZmxhdE1hcChjb2x1bW4gPT4gY29sdW1uLmdldExlYWZDb2x1bW5zKCkpO1xuICAgICAgcmV0dXJuIG9yZGVyQ29sdW1ucyhsZWFmQ29sdW1ucyk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnMob3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRBbGxMZWFmQ29sdW1ucycpKSxcbiAgICBnZXRDb2x1bW46IGNvbHVtbklkID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLl9nZXRBbGxGbGF0Q29sdW1uc0J5SWQoKVtjb2x1bW5JZF07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29sdW1uKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtUYWJsZV0gQ29sdW1uIHdpdGggaWQgJyR7Y29sdW1uSWR9JyBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2x1bW47XG4gICAgfVxuICB9O1xuICBPYmplY3QuYXNzaWduKHRhYmxlLCBjb3JlSW5zdGFuY2UpO1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGFibGUuX2ZlYXR1cmVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0YWJsZS5fZmVhdHVyZXNbaW5kZXhdO1xuICAgIGZlYXR1cmUgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZVRhYmxlID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVUYWJsZSh0YWJsZSk7XG4gIH1cbiAgcmV0dXJuIHRhYmxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDZWxsKHRhYmxlLCByb3csIGNvbHVtbiwgY29sdW1uSWQpIHtcbiAgY29uc3QgZ2V0UmVuZGVyVmFsdWUgPSAoKSA9PiB7XG4gICAgdmFyIF9jZWxsJGdldFZhbHVlO1xuICAgIHJldHVybiAoX2NlbGwkZ2V0VmFsdWUgPSBjZWxsLmdldFZhbHVlKCkpICE9IG51bGwgPyBfY2VsbCRnZXRWYWx1ZSA6IHRhYmxlLm9wdGlvbnMucmVuZGVyRmFsbGJhY2tWYWx1ZTtcbiAgfTtcbiAgY29uc3QgY2VsbCA9IHtcbiAgICBpZDogYCR7cm93LmlkfV8ke2NvbHVtbi5pZH1gLFxuICAgIHJvdyxcbiAgICBjb2x1bW4sXG4gICAgZ2V0VmFsdWU6ICgpID0+IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCksXG4gICAgcmVuZGVyVmFsdWU6IGdldFJlbmRlclZhbHVlLFxuICAgIGdldENvbnRleHQ6IG1lbW8oKCkgPT4gW3RhYmxlLCBjb2x1bW4sIHJvdywgY2VsbF0sICh0YWJsZSwgY29sdW1uLCByb3csIGNlbGwpID0+ICh7XG4gICAgICB0YWJsZSxcbiAgICAgIGNvbHVtbixcbiAgICAgIHJvdyxcbiAgICAgIGNlbGw6IGNlbGwsXG4gICAgICBnZXRWYWx1ZTogY2VsbC5nZXRWYWx1ZSxcbiAgICAgIHJlbmRlclZhbHVlOiBjZWxsLnJlbmRlclZhbHVlXG4gICAgfSksIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NlbGxzJywgJ2NlbGwuZ2V0Q29udGV4dCcpKVxuICB9O1xuICB0YWJsZS5fZmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICBmZWF0dXJlLmNyZWF0ZUNlbGwgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZUNlbGwoY2VsbCwgY29sdW1uLCByb3csIHRhYmxlKTtcbiAgfSwge30pO1xuICByZXR1cm4gY2VsbDtcbn1cblxuY29uc3QgY3JlYXRlUm93ID0gKHRhYmxlLCBpZCwgb3JpZ2luYWwsIHJvd0luZGV4LCBkZXB0aCwgc3ViUm93cywgcGFyZW50SWQpID0+IHtcbiAgbGV0IHJvdyA9IHtcbiAgICBpZCxcbiAgICBpbmRleDogcm93SW5kZXgsXG4gICAgb3JpZ2luYWwsXG4gICAgZGVwdGgsXG4gICAgcGFyZW50SWQsXG4gICAgX3ZhbHVlc0NhY2hlOiB7fSxcbiAgICBfdW5pcXVlVmFsdWVzQ2FjaGU6IHt9LFxuICAgIGdldFZhbHVlOiBjb2x1bW5JZCA9PiB7XG4gICAgICBpZiAocm93Ll92YWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKTtcbiAgICAgIGlmICghKGNvbHVtbiAhPSBudWxsICYmIGNvbHVtbi5hY2Nlc3NvckZuKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBjb2x1bW4uYWNjZXNzb3JGbihyb3cub3JpZ2luYWwsIHJvd0luZGV4KTtcbiAgICAgIHJldHVybiByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICB9LFxuICAgIGdldFVuaXF1ZVZhbHVlczogY29sdW1uSWQgPT4ge1xuICAgICAgaWYgKHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGUuaGFzT3duUHJvcGVydHkoY29sdW1uSWQpKSB7XG4gICAgICAgIHJldHVybiByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCk7XG4gICAgICBpZiAoIShjb2x1bW4gIT0gbnVsbCAmJiBjb2x1bW4uYWNjZXNzb3JGbikpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICghY29sdW1uLmNvbHVtbkRlZi5nZXRVbmlxdWVWYWx1ZXMpIHtcbiAgICAgICAgcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBbcm93LmdldFZhbHVlKGNvbHVtbklkKV07XG4gICAgICAgIHJldHVybiByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgIH1cbiAgICAgIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gY29sdW1uLmNvbHVtbkRlZi5nZXRVbmlxdWVWYWx1ZXMocm93Lm9yaWdpbmFsLCByb3dJbmRleCk7XG4gICAgICByZXR1cm4gcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgfSxcbiAgICByZW5kZXJWYWx1ZTogY29sdW1uSWQgPT4ge1xuICAgICAgdmFyIF9yb3ckZ2V0VmFsdWU7XG4gICAgICByZXR1cm4gKF9yb3ckZ2V0VmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSAhPSBudWxsID8gX3JvdyRnZXRWYWx1ZSA6IHRhYmxlLm9wdGlvbnMucmVuZGVyRmFsbGJhY2tWYWx1ZTtcbiAgICB9LFxuICAgIHN1YlJvd3M6IHN1YlJvd3MgIT0gbnVsbCA/IHN1YlJvd3MgOiBbXSxcbiAgICBnZXRMZWFmUm93czogKCkgPT4gZmxhdHRlbkJ5KHJvdy5zdWJSb3dzLCBkID0+IGQuc3ViUm93cyksXG4gICAgZ2V0UGFyZW50Um93OiAoKSA9PiByb3cucGFyZW50SWQgPyB0YWJsZS5nZXRSb3cocm93LnBhcmVudElkLCB0cnVlKSA6IHVuZGVmaW5lZCxcbiAgICBnZXRQYXJlbnRSb3dzOiAoKSA9PiB7XG4gICAgICBsZXQgcGFyZW50Um93cyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnRSb3cgPSByb3c7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBwYXJlbnRSb3cgPSBjdXJyZW50Um93LmdldFBhcmVudFJvdygpO1xuICAgICAgICBpZiAoIXBhcmVudFJvdykgYnJlYWs7XG4gICAgICAgIHBhcmVudFJvd3MucHVzaChwYXJlbnRSb3cpO1xuICAgICAgICBjdXJyZW50Um93ID0gcGFyZW50Um93O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudFJvd3MucmV2ZXJzZSgpO1xuICAgIH0sXG4gICAgZ2V0QWxsQ2VsbHM6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbExlYWZDb2x1bW5zKCldLCBsZWFmQ29sdW1ucyA9PiB7XG4gICAgICByZXR1cm4gbGVhZkNvbHVtbnMubWFwKGNvbHVtbiA9PiB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDZWxsKHRhYmxlLCByb3csIGNvbHVtbiwgY29sdW1uLmlkKTtcbiAgICAgIH0pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0QWxsQ2VsbHMnKSksXG4gICAgX2dldEFsbENlbGxzQnlDb2x1bW5JZDogbWVtbygoKSA9PiBbcm93LmdldEFsbENlbGxzKCldLCBhbGxDZWxscyA9PiB7XG4gICAgICByZXR1cm4gYWxsQ2VsbHMucmVkdWNlKChhY2MsIGNlbGwpID0+IHtcbiAgICAgICAgYWNjW2NlbGwuY29sdW1uLmlkXSA9IGNlbGw7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRBbGxDZWxsc0J5Q29sdW1uSWQnKSlcbiAgfTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJsZS5fZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBmZWF0dXJlID0gdGFibGUuX2ZlYXR1cmVzW2ldO1xuICAgIGZlYXR1cmUgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZVJvdyA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlUm93KHJvdywgdGFibGUpO1xuICB9XG4gIHJldHVybiByb3c7XG59O1xuXG4vLyB0eXBlIFBlcnNvbiA9IHtcbi8vICAgZmlyc3ROYW1lOiBzdHJpbmdcbi8vICAgbGFzdE5hbWU6IHN0cmluZ1xuLy8gICBhZ2U6IG51bWJlclxuLy8gICB2aXNpdHM6IG51bWJlclxuLy8gICBzdGF0dXM6IHN0cmluZ1xuLy8gICBwcm9ncmVzczogbnVtYmVyXG4vLyAgIGNyZWF0ZWRBdDogRGF0ZVxuLy8gICBuZXN0ZWQ6IHtcbi8vICAgICBmb286IFtcbi8vICAgICAgIHtcbi8vICAgICAgICAgYmFyOiAnYmFyJ1xuLy8gICAgICAgfVxuLy8gICAgIF1cbi8vICAgICBiYXI6IHsgc3ViQmFyOiBib29sZWFuIH1bXVxuLy8gICAgIGJhejoge1xuLy8gICAgICAgZm9vOiAnZm9vJ1xuLy8gICAgICAgYmFyOiB7XG4vLyAgICAgICAgIGJhejogJ2Jheidcbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cblxuLy8gY29uc3QgdGVzdDogRGVlcEtleXM8UGVyc29uPiA9ICduZXN0ZWQuZm9vLjAuYmFyJ1xuLy8gY29uc3QgdGVzdDI6IERlZXBLZXlzPFBlcnNvbj4gPSAnbmVzdGVkLmJhcidcblxuLy8gY29uc3QgaGVscGVyID0gY3JlYXRlQ29sdW1uSGVscGVyPFBlcnNvbj4oKVxuXG4vLyBoZWxwZXIuYWNjZXNzb3IoJ25lc3RlZC5mb28nLCB7XG4vLyAgIGNlbGw6IGluZm8gPT4gaW5mby5nZXRWYWx1ZSgpLFxuLy8gfSlcblxuLy8gaGVscGVyLmFjY2Vzc29yKCduZXN0ZWQuZm9vLjAuYmFyJywge1xuLy8gICBjZWxsOiBpbmZvID0+IGluZm8uZ2V0VmFsdWUoKSxcbi8vIH0pXG5cbi8vIGhlbHBlci5hY2Nlc3NvcignbmVzdGVkLmJhcicsIHtcbi8vICAgY2VsbDogaW5mbyA9PiBpbmZvLmdldFZhbHVlKCksXG4vLyB9KVxuXG5mdW5jdGlvbiBjcmVhdGVDb2x1bW5IZWxwZXIoKSB7XG4gIHJldHVybiB7XG4gICAgYWNjZXNzb3I6IChhY2Nlc3NvciwgY29sdW1uKSA9PiB7XG4gICAgICByZXR1cm4gdHlwZW9mIGFjY2Vzc29yID09PSAnZnVuY3Rpb24nID8ge1xuICAgICAgICAuLi5jb2x1bW4sXG4gICAgICAgIGFjY2Vzc29yRm46IGFjY2Vzc29yXG4gICAgICB9IDoge1xuICAgICAgICAuLi5jb2x1bW4sXG4gICAgICAgIGFjY2Vzc29yS2V5OiBhY2Nlc3NvclxuICAgICAgfTtcbiAgICB9LFxuICAgIGRpc3BsYXk6IGNvbHVtbiA9PiBjb2x1bW4sXG4gICAgZ3JvdXA6IGNvbHVtbiA9PiBjb2x1bW5cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29yZVJvd01vZGVsKCkge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUub3B0aW9ucy5kYXRhXSwgZGF0YSA9PiB7XG4gICAgY29uc3Qgcm93TW9kZWwgPSB7XG4gICAgICByb3dzOiBbXSxcbiAgICAgIGZsYXRSb3dzOiBbXSxcbiAgICAgIHJvd3NCeUlkOiB7fVxuICAgIH07XG4gICAgY29uc3QgYWNjZXNzUm93cyA9IGZ1bmN0aW9uIChvcmlnaW5hbFJvd3MsIGRlcHRoLCBwYXJlbnRSb3cpIHtcbiAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlcHRoID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvd3MgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpZ2luYWxSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFRoaXMgY291bGQgYmUgYW4gZXhwZW5zaXZlIGNoZWNrIGF0IHNjYWxlLCBzbyB3ZSBzaG91bGQgbW92ZSBpdCBzb21ld2hlcmUgZWxzZSwgYnV0IHdoZXJlP1xuICAgICAgICAvLyBpZiAoIWlkKSB7XG4gICAgICAgIC8vICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gICAgIHRocm93IG5ldyBFcnJvcihgZ2V0Um93SWQgZXhwZWN0ZWQgYW4gSUQsIGJ1dCBnb3QgJHtpZH1gKVxuICAgICAgICAvLyAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIE1ha2UgdGhlIHJvd1xuICAgICAgICBjb25zdCByb3cgPSBjcmVhdGVSb3codGFibGUsIHRhYmxlLl9nZXRSb3dJZChvcmlnaW5hbFJvd3NbaV0sIGksIHBhcmVudFJvdyksIG9yaWdpbmFsUm93c1tpXSwgaSwgZGVwdGgsIHVuZGVmaW5lZCwgcGFyZW50Um93ID09IG51bGwgPyB2b2lkIDAgOiBwYXJlbnRSb3cuaWQpO1xuXG4gICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgZXZlcnkgcm93IGluIGEgZmxhdCBhcnJheVxuICAgICAgICByb3dNb2RlbC5mbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIC8vIEFsc28ga2VlcCB0cmFjayBvZiBldmVyeSByb3cgYnkgaXRzIElEXG4gICAgICAgIHJvd01vZGVsLnJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgIC8vIFB1c2ggdGFibGUgcm93IGludG8gcGFyZW50XG4gICAgICAgIHJvd3MucHVzaChyb3cpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgb3JpZ2luYWwgc3Vicm93c1xuICAgICAgICBpZiAodGFibGUub3B0aW9ucy5nZXRTdWJSb3dzKSB7XG4gICAgICAgICAgdmFyIF9yb3ckb3JpZ2luYWxTdWJSb3dzO1xuICAgICAgICAgIHJvdy5vcmlnaW5hbFN1YlJvd3MgPSB0YWJsZS5vcHRpb25zLmdldFN1YlJvd3Mob3JpZ2luYWxSb3dzW2ldLCBpKTtcblxuICAgICAgICAgIC8vIFRoZW4gcmVjdXJzaXZlbHkgYWNjZXNzIHRoZW1cbiAgICAgICAgICBpZiAoKF9yb3ckb3JpZ2luYWxTdWJSb3dzID0gcm93Lm9yaWdpbmFsU3ViUm93cykgIT0gbnVsbCAmJiBfcm93JG9yaWdpbmFsU3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJvdy5zdWJSb3dzID0gYWNjZXNzUm93cyhyb3cub3JpZ2luYWxTdWJSb3dzLCBkZXB0aCArIDEsIHJvdyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93cztcbiAgICB9O1xuICAgIHJvd01vZGVsLnJvd3MgPSBhY2Nlc3NSb3dzKGRhdGEpO1xuICAgIHJldHVybiByb3dNb2RlbDtcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0Um93TW9kZWwnLCAoKSA9PiB0YWJsZS5fYXV0b1Jlc2V0UGFnZUluZGV4KCkpKTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyUm93cyhyb3dzLCBmaWx0ZXJSb3dJbXBsLCB0YWJsZSkge1xuICBpZiAodGFibGUub3B0aW9ucy5maWx0ZXJGcm9tTGVhZlJvd3MpIHtcbiAgICByZXR1cm4gZmlsdGVyUm93TW9kZWxGcm9tTGVhZnMocm93cywgZmlsdGVyUm93SW1wbCwgdGFibGUpO1xuICB9XG4gIHJldHVybiBmaWx0ZXJSb3dNb2RlbEZyb21Sb290KHJvd3MsIGZpbHRlclJvd0ltcGwsIHRhYmxlKTtcbn1cbmZ1bmN0aW9uIGZpbHRlclJvd01vZGVsRnJvbUxlYWZzKHJvd3NUb0ZpbHRlciwgZmlsdGVyUm93LCB0YWJsZSkge1xuICB2YXIgX3RhYmxlJG9wdGlvbnMkbWF4TGVhO1xuICBjb25zdCBuZXdGaWx0ZXJlZEZsYXRSb3dzID0gW107XG4gIGNvbnN0IG5ld0ZpbHRlcmVkUm93c0J5SWQgPSB7fTtcbiAgY29uc3QgbWF4RGVwdGggPSAoX3RhYmxlJG9wdGlvbnMkbWF4TGVhID0gdGFibGUub3B0aW9ucy5tYXhMZWFmUm93RmlsdGVyRGVwdGgpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRtYXhMZWEgOiAxMDA7XG4gIGNvbnN0IHJlY3Vyc2VGaWx0ZXJSb3dzID0gZnVuY3Rpb24gKHJvd3NUb0ZpbHRlciwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgZGVwdGggPSAwO1xuICAgIH1cbiAgICBjb25zdCByb3dzID0gW107XG5cbiAgICAvLyBGaWx0ZXIgZnJvbSBjaGlsZHJlbiB1cCBmaXJzdFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93c1RvRmlsdGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX3JvdyRzdWJSb3dzO1xuICAgICAgbGV0IHJvdyA9IHJvd3NUb0ZpbHRlcltpXTtcbiAgICAgIGNvbnN0IG5ld1JvdyA9IGNyZWF0ZVJvdyh0YWJsZSwgcm93LmlkLCByb3cub3JpZ2luYWwsIHJvdy5pbmRleCwgcm93LmRlcHRoLCB1bmRlZmluZWQsIHJvdy5wYXJlbnRJZCk7XG4gICAgICBuZXdSb3cuY29sdW1uRmlsdGVycyA9IHJvdy5jb2x1bW5GaWx0ZXJzO1xuICAgICAgaWYgKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoICYmIGRlcHRoIDwgbWF4RGVwdGgpIHtcbiAgICAgICAgbmV3Um93LnN1YlJvd3MgPSByZWN1cnNlRmlsdGVyUm93cyhyb3cuc3ViUm93cywgZGVwdGggKyAxKTtcbiAgICAgICAgcm93ID0gbmV3Um93O1xuICAgICAgICBpZiAoZmlsdGVyUm93KHJvdykgJiYgIW5ld1Jvdy5zdWJSb3dzLmxlbmd0aCkge1xuICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIG5ld0ZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgICAgICBuZXdGaWx0ZXJlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyUm93KHJvdykgfHwgbmV3Um93LnN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3cgPSBuZXdSb3c7XG4gICAgICAgIGlmIChmaWx0ZXJSb3cocm93KSkge1xuICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIG5ld0ZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgICAgICBuZXdGaWx0ZXJlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcm93cztcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICByb3dzOiByZWN1cnNlRmlsdGVyUm93cyhyb3dzVG9GaWx0ZXIpLFxuICAgIGZsYXRSb3dzOiBuZXdGaWx0ZXJlZEZsYXRSb3dzLFxuICAgIHJvd3NCeUlkOiBuZXdGaWx0ZXJlZFJvd3NCeUlkXG4gIH07XG59XG5mdW5jdGlvbiBmaWx0ZXJSb3dNb2RlbEZyb21Sb290KHJvd3NUb0ZpbHRlciwgZmlsdGVyUm93LCB0YWJsZSkge1xuICB2YXIgX3RhYmxlJG9wdGlvbnMkbWF4TGVhMjtcbiAgY29uc3QgbmV3RmlsdGVyZWRGbGF0Um93cyA9IFtdO1xuICBjb25zdCBuZXdGaWx0ZXJlZFJvd3NCeUlkID0ge307XG4gIGNvbnN0IG1heERlcHRoID0gKF90YWJsZSRvcHRpb25zJG1heExlYTIgPSB0YWJsZS5vcHRpb25zLm1heExlYWZSb3dGaWx0ZXJEZXB0aCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJG1heExlYTIgOiAxMDA7XG5cbiAgLy8gRmlsdGVycyB0b3AgbGV2ZWwgYW5kIG5lc3RlZCByb3dzXG4gIGNvbnN0IHJlY3Vyc2VGaWx0ZXJSb3dzID0gZnVuY3Rpb24gKHJvd3NUb0ZpbHRlciwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgZGVwdGggPSAwO1xuICAgIH1cbiAgICAvLyBGaWx0ZXIgZnJvbSBwYXJlbnRzIGRvd253YXJkIGZpcnN0XG5cbiAgICBjb25zdCByb3dzID0gW107XG5cbiAgICAvLyBBcHBseSB0aGUgZmlsdGVyIHRvIGFueSBzdWJSb3dzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzVG9GaWx0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCByb3cgPSByb3dzVG9GaWx0ZXJbaV07XG4gICAgICBjb25zdCBwYXNzID0gZmlsdGVyUm93KHJvdyk7XG4gICAgICBpZiAocGFzcykge1xuICAgICAgICB2YXIgX3JvdyRzdWJSb3dzMjtcbiAgICAgICAgaWYgKChfcm93JHN1YlJvd3MyID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzMi5sZW5ndGggJiYgZGVwdGggPCBtYXhEZXB0aCkge1xuICAgICAgICAgIGNvbnN0IG5ld1JvdyA9IGNyZWF0ZVJvdyh0YWJsZSwgcm93LmlkLCByb3cub3JpZ2luYWwsIHJvdy5pbmRleCwgcm93LmRlcHRoLCB1bmRlZmluZWQsIHJvdy5wYXJlbnRJZCk7XG4gICAgICAgICAgbmV3Um93LnN1YlJvd3MgPSByZWN1cnNlRmlsdGVyUm93cyhyb3cuc3ViUm93cywgZGVwdGggKyAxKTtcbiAgICAgICAgICByb3cgPSBuZXdSb3c7XG4gICAgICAgIH1cbiAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICBuZXdGaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb3dzO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHJvd3M6IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvd3NUb0ZpbHRlciksXG4gICAgZmxhdFJvd3M6IG5ld0ZpbHRlcmVkRmxhdFJvd3MsXG4gICAgcm93c0J5SWQ6IG5ld0ZpbHRlcmVkUm93c0J5SWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsdGVyZWRSb3dNb2RlbCgpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzLCB0YWJsZS5nZXRTdGF0ZSgpLmdsb2JhbEZpbHRlcl0sIChyb3dNb2RlbCwgY29sdW1uRmlsdGVycywgZ2xvYmFsRmlsdGVyKSA9PiB7XG4gICAgaWYgKCFyb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCAhKGNvbHVtbkZpbHRlcnMgIT0gbnVsbCAmJiBjb2x1bW5GaWx0ZXJzLmxlbmd0aCkgJiYgIWdsb2JhbEZpbHRlcikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dNb2RlbC5mbGF0Um93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByb3dNb2RlbC5mbGF0Um93c1tpXS5jb2x1bW5GaWx0ZXJzID0ge307XG4gICAgICAgIHJvd01vZGVsLmZsYXRSb3dzW2ldLmNvbHVtbkZpbHRlcnNNZXRhID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkQ29sdW1uRmlsdGVycyA9IFtdO1xuICAgIGNvbnN0IHJlc29sdmVkR2xvYmFsRmlsdGVycyA9IFtdO1xuICAgIChjb2x1bW5GaWx0ZXJzICE9IG51bGwgPyBjb2x1bW5GaWx0ZXJzIDogW10pLmZvckVhY2goZCA9PiB7XG4gICAgICB2YXIgX2ZpbHRlckZuJHJlc29sdmVGaWx0O1xuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGQuaWQpO1xuICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZmlsdGVyRm4gPSBjb2x1bW4uZ2V0RmlsdGVyRm4oKTtcbiAgICAgIGlmICghZmlsdGVyRm4pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIGEgdmFsaWQgJ2NvbHVtbi5maWx0ZXJGbicgZm9yIGNvbHVtbiB3aXRoIHRoZSBJRDogJHtjb2x1bW4uaWR9LmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc29sdmVkQ29sdW1uRmlsdGVycy5wdXNoKHtcbiAgICAgICAgaWQ6IGQuaWQsXG4gICAgICAgIGZpbHRlckZuLFxuICAgICAgICByZXNvbHZlZFZhbHVlOiAoX2ZpbHRlckZuJHJlc29sdmVGaWx0ID0gZmlsdGVyRm4ucmVzb2x2ZUZpbHRlclZhbHVlID09IG51bGwgPyB2b2lkIDAgOiBmaWx0ZXJGbi5yZXNvbHZlRmlsdGVyVmFsdWUoZC52YWx1ZSkpICE9IG51bGwgPyBfZmlsdGVyRm4kcmVzb2x2ZUZpbHQgOiBkLnZhbHVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBmaWx0ZXJhYmxlSWRzID0gY29sdW1uRmlsdGVycy5tYXAoZCA9PiBkLmlkKTtcbiAgICBjb25zdCBnbG9iYWxGaWx0ZXJGbiA9IHRhYmxlLmdldEdsb2JhbEZpbHRlckZuKCk7XG4gICAgY29uc3QgZ2xvYmFsbHlGaWx0ZXJhYmxlQ29sdW1ucyA9IHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCkuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4uZ2V0Q2FuR2xvYmFsRmlsdGVyKCkpO1xuICAgIGlmIChnbG9iYWxGaWx0ZXIgJiYgZ2xvYmFsRmlsdGVyRm4gJiYgZ2xvYmFsbHlGaWx0ZXJhYmxlQ29sdW1ucy5sZW5ndGgpIHtcbiAgICAgIGZpbHRlcmFibGVJZHMucHVzaCgnX19nbG9iYWxfXycpO1xuICAgICAgZ2xvYmFsbHlGaWx0ZXJhYmxlQ29sdW1ucy5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgIHZhciBfZ2xvYmFsRmlsdGVyRm4kcmVzb2w7XG4gICAgICAgIHJlc29sdmVkR2xvYmFsRmlsdGVycy5wdXNoKHtcbiAgICAgICAgICBpZDogY29sdW1uLmlkLFxuICAgICAgICAgIGZpbHRlckZuOiBnbG9iYWxGaWx0ZXJGbixcbiAgICAgICAgICByZXNvbHZlZFZhbHVlOiAoX2dsb2JhbEZpbHRlckZuJHJlc29sID0gZ2xvYmFsRmlsdGVyRm4ucmVzb2x2ZUZpbHRlclZhbHVlID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWxGaWx0ZXJGbi5yZXNvbHZlRmlsdGVyVmFsdWUoZ2xvYmFsRmlsdGVyKSkgIT0gbnVsbCA/IF9nbG9iYWxGaWx0ZXJGbiRyZXNvbCA6IGdsb2JhbEZpbHRlclxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgY3VycmVudENvbHVtbkZpbHRlcjtcbiAgICBsZXQgY3VycmVudEdsb2JhbEZpbHRlcjtcblxuICAgIC8vIEZsYWcgdGhlIHByZWZpbHRlcmVkIHJvdyBtb2RlbCB3aXRoIGVhY2ggZmlsdGVyIHN0YXRlXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3dNb2RlbC5mbGF0Um93cy5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3Qgcm93ID0gcm93TW9kZWwuZmxhdFJvd3Nbal07XG4gICAgICByb3cuY29sdW1uRmlsdGVycyA9IHt9O1xuICAgICAgaWYgKHJlc29sdmVkQ29sdW1uRmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNvbHZlZENvbHVtbkZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjdXJyZW50Q29sdW1uRmlsdGVyID0gcmVzb2x2ZWRDb2x1bW5GaWx0ZXJzW2ldO1xuICAgICAgICAgIGNvbnN0IGlkID0gY3VycmVudENvbHVtbkZpbHRlci5pZDtcblxuICAgICAgICAgIC8vIFRhZyB0aGUgcm93IHdpdGggdGhlIGNvbHVtbiBmaWx0ZXIgc3RhdGVcbiAgICAgICAgICByb3cuY29sdW1uRmlsdGVyc1tpZF0gPSBjdXJyZW50Q29sdW1uRmlsdGVyLmZpbHRlckZuKHJvdywgaWQsIGN1cnJlbnRDb2x1bW5GaWx0ZXIucmVzb2x2ZWRWYWx1ZSwgZmlsdGVyTWV0YSA9PiB7XG4gICAgICAgICAgICByb3cuY29sdW1uRmlsdGVyc01ldGFbaWRdID0gZmlsdGVyTWV0YTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlc29sdmVkR2xvYmFsRmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNvbHZlZEdsb2JhbEZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjdXJyZW50R2xvYmFsRmlsdGVyID0gcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzW2ldO1xuICAgICAgICAgIGNvbnN0IGlkID0gY3VycmVudEdsb2JhbEZpbHRlci5pZDtcbiAgICAgICAgICAvLyBUYWcgdGhlIHJvdyB3aXRoIHRoZSBmaXJzdCB0cnV0aHkgZ2xvYmFsIGZpbHRlciBzdGF0ZVxuICAgICAgICAgIGlmIChjdXJyZW50R2xvYmFsRmlsdGVyLmZpbHRlckZuKHJvdywgaWQsIGN1cnJlbnRHbG9iYWxGaWx0ZXIucmVzb2x2ZWRWYWx1ZSwgZmlsdGVyTWV0YSA9PiB7XG4gICAgICAgICAgICByb3cuY29sdW1uRmlsdGVyc01ldGFbaWRdID0gZmlsdGVyTWV0YTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnMuX19nbG9iYWxfXyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdy5jb2x1bW5GaWx0ZXJzLl9fZ2xvYmFsX18gIT09IHRydWUpIHtcbiAgICAgICAgICByb3cuY29sdW1uRmlsdGVycy5fX2dsb2JhbF9fID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlsdGVyUm93c0ltcGwgPSByb3cgPT4ge1xuICAgICAgLy8gSG9yaXpvbnRhbGx5IGZpbHRlciByb3dzIHRocm91Z2ggZWFjaCBjb2x1bW5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyYWJsZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocm93LmNvbHVtbkZpbHRlcnNbZmlsdGVyYWJsZUlkc1tpXV0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLy8gRmlsdGVyIGZpbmFsIHJvd3MgdXNpbmcgYWxsIG9mIHRoZSBhY3RpdmUgZmlsdGVyc1xuICAgIHJldHVybiBmaWx0ZXJSb3dzKHJvd01vZGVsLnJvd3MsIGZpbHRlclJvd3NJbXBsLCB0YWJsZSk7XG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEZpbHRlcmVkUm93TW9kZWwnLCAoKSA9PiB0YWJsZS5fYXV0b1Jlc2V0UGFnZUluZGV4KCkpKTtcbn1cblxuZnVuY3Rpb24gZ2V0RmFjZXRlZFJvd01vZGVsKCkge1xuICByZXR1cm4gKHRhYmxlLCBjb2x1bW5JZCkgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtbkZpbHRlcnMsIHRhYmxlLmdldFN0YXRlKCkuZ2xvYmFsRmlsdGVyLCB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCldLCAocHJlUm93TW9kZWwsIGNvbHVtbkZpbHRlcnMsIGdsb2JhbEZpbHRlcikgPT4ge1xuICAgIGlmICghcHJlUm93TW9kZWwucm93cy5sZW5ndGggfHwgIShjb2x1bW5GaWx0ZXJzICE9IG51bGwgJiYgY29sdW1uRmlsdGVycy5sZW5ndGgpICYmICFnbG9iYWxGaWx0ZXIpIHtcbiAgICAgIHJldHVybiBwcmVSb3dNb2RlbDtcbiAgICB9XG4gICAgY29uc3QgZmlsdGVyYWJsZUlkcyA9IFsuLi5jb2x1bW5GaWx0ZXJzLm1hcChkID0+IGQuaWQpLmZpbHRlcihkID0+IGQgIT09IGNvbHVtbklkKSwgZ2xvYmFsRmlsdGVyID8gJ19fZ2xvYmFsX18nIDogdW5kZWZpbmVkXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgY29uc3QgZmlsdGVyUm93c0ltcGwgPSByb3cgPT4ge1xuICAgICAgLy8gSG9yaXpvbnRhbGx5IGZpbHRlciByb3dzIHRocm91Z2ggZWFjaCBjb2x1bW5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyYWJsZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocm93LmNvbHVtbkZpbHRlcnNbZmlsdGVyYWJsZUlkc1tpXV0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBmaWx0ZXJSb3dzKHByZVJvd01vZGVsLnJvd3MsIGZpbHRlclJvd3NJbXBsLCB0YWJsZSk7XG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEZhY2V0ZWRSb3dNb2RlbCcpKTtcbn1cblxuZnVuY3Rpb24gZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcygpIHtcbiAgcmV0dXJuICh0YWJsZSwgY29sdW1uSWQpID0+IG1lbW8oKCkgPT4ge1xuICAgIHZhciBfdGFibGUkZ2V0Q29sdW1uO1xuICAgIHJldHVybiBbKF90YWJsZSRnZXRDb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENvbHVtbi5nZXRGYWNldGVkUm93TW9kZWwoKV07XG4gIH0sIGZhY2V0ZWRSb3dNb2RlbCA9PiB7XG4gICAgaWYgKCFmYWNldGVkUm93TW9kZWwpIHJldHVybiBuZXcgTWFwKCk7XG4gICAgbGV0IGZhY2V0ZWRVbmlxdWVWYWx1ZXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93c1tpXS5nZXRVbmlxdWVWYWx1ZXMoY29sdW1uSWQpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbal07XG4gICAgICAgIGlmIChmYWNldGVkVW5pcXVlVmFsdWVzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICB2YXIgX2ZhY2V0ZWRVbmlxdWVWYWx1ZXMkO1xuICAgICAgICAgIGZhY2V0ZWRVbmlxdWVWYWx1ZXMuc2V0KHZhbHVlLCAoKF9mYWNldGVkVW5pcXVlVmFsdWVzJCA9IGZhY2V0ZWRVbmlxdWVWYWx1ZXMuZ2V0KHZhbHVlKSkgIT0gbnVsbCA/IF9mYWNldGVkVW5pcXVlVmFsdWVzJCA6IDApICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmFjZXRlZFVuaXF1ZVZhbHVlcy5zZXQodmFsdWUsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWNldGVkVW5pcXVlVmFsdWVzO1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsIGBnZXRGYWNldGVkVW5pcXVlVmFsdWVzXyR7Y29sdW1uSWR9YCkpO1xufVxuXG5mdW5jdGlvbiBnZXRGYWNldGVkTWluTWF4VmFsdWVzKCkge1xuICByZXR1cm4gKHRhYmxlLCBjb2x1bW5JZCkgPT4gbWVtbygoKSA9PiB7XG4gICAgdmFyIF90YWJsZSRnZXRDb2x1bW47XG4gICAgcmV0dXJuIFsoX3RhYmxlJGdldENvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q29sdW1uLmdldEZhY2V0ZWRSb3dNb2RlbCgpXTtcbiAgfSwgZmFjZXRlZFJvd01vZGVsID0+IHtcbiAgICB2YXIgX2ZhY2V0ZWRSb3dNb2RlbCRmbGF0O1xuICAgIGlmICghZmFjZXRlZFJvd01vZGVsKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGZpcnN0VmFsdWUgPSAoX2ZhY2V0ZWRSb3dNb2RlbCRmbGF0ID0gZmFjZXRlZFJvd01vZGVsLmZsYXRSb3dzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2ZhY2V0ZWRSb3dNb2RlbCRmbGF0LmdldFVuaXF1ZVZhbHVlcyhjb2x1bW5JZCk7XG4gICAgaWYgKHR5cGVvZiBmaXJzdFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IGZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSBbZmlyc3RWYWx1ZSwgZmlyc3RWYWx1ZV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93c1tpXS5nZXRVbmlxdWVWYWx1ZXMoY29sdW1uSWQpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbal07XG4gICAgICAgIGlmICh2YWx1ZSA8IGZhY2V0ZWRNaW5NYXhWYWx1ZXNbMF0pIHtcbiAgICAgICAgICBmYWNldGVkTWluTWF4VmFsdWVzWzBdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPiBmYWNldGVkTWluTWF4VmFsdWVzWzFdKSB7XG4gICAgICAgICAgZmFjZXRlZE1pbk1heFZhbHVlc1sxXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWNldGVkTWluTWF4VmFsdWVzO1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRGYWNldGVkTWluTWF4VmFsdWVzJykpO1xufVxuXG5mdW5jdGlvbiBnZXRTb3J0ZWRSb3dNb2RlbCgpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkuc29ydGluZywgdGFibGUuZ2V0UHJlU29ydGVkUm93TW9kZWwoKV0sIChzb3J0aW5nLCByb3dNb2RlbCkgPT4ge1xuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGggfHwgIShzb3J0aW5nICE9IG51bGwgJiYgc29ydGluZy5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuICAgIGNvbnN0IHNvcnRpbmdTdGF0ZSA9IHRhYmxlLmdldFN0YXRlKCkuc29ydGluZztcbiAgICBjb25zdCBzb3J0ZWRGbGF0Um93cyA9IFtdO1xuXG4gICAgLy8gRmlsdGVyIG91dCBzb3J0aW5ncyB0aGF0IGNvcnJlc3BvbmQgdG8gbm9uIGV4aXN0aW5nIGNvbHVtbnNcbiAgICBjb25zdCBhdmFpbGFibGVTb3J0aW5nID0gc29ydGluZ1N0YXRlLmZpbHRlcihzb3J0ID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0Q29sdW1uO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0Q29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKHNvcnQuaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENvbHVtbi5nZXRDYW5Tb3J0KCk7XG4gICAgfSk7XG4gICAgY29uc3QgY29sdW1uSW5mb0J5SWQgPSB7fTtcbiAgICBhdmFpbGFibGVTb3J0aW5nLmZvckVhY2goc29ydEVudHJ5ID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihzb3J0RW50cnkuaWQpO1xuICAgICAgaWYgKCFjb2x1bW4pIHJldHVybjtcbiAgICAgIGNvbHVtbkluZm9CeUlkW3NvcnRFbnRyeS5pZF0gPSB7XG4gICAgICAgIHNvcnRVbmRlZmluZWQ6IGNvbHVtbi5jb2x1bW5EZWYuc29ydFVuZGVmaW5lZCxcbiAgICAgICAgaW52ZXJ0U29ydGluZzogY29sdW1uLmNvbHVtbkRlZi5pbnZlcnRTb3J0aW5nLFxuICAgICAgICBzb3J0aW5nRm46IGNvbHVtbi5nZXRTb3J0aW5nRm4oKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBzb3J0RGF0YSA9IHJvd3MgPT4ge1xuICAgICAgLy8gVGhpcyB3aWxsIGFsc28gcGVyZm9ybSBhIHN0YWJsZSBzb3J0aW5nIHVzaW5nIHRoZSByb3cgaW5kZXhcbiAgICAgIC8vIGlmIG5lZWRlZC5cbiAgICAgIGNvbnN0IHNvcnRlZERhdGEgPSByb3dzLm1hcChyb3cgPT4gKHtcbiAgICAgICAgLi4ucm93XG4gICAgICB9KSk7XG4gICAgICBzb3J0ZWREYXRhLnNvcnQoKHJvd0EsIHJvd0IpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdmFpbGFibGVTb3J0aW5nLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIF9zb3J0RW50cnkkZGVzYztcbiAgICAgICAgICBjb25zdCBzb3J0RW50cnkgPSBhdmFpbGFibGVTb3J0aW5nW2ldO1xuICAgICAgICAgIGNvbnN0IGNvbHVtbkluZm8gPSBjb2x1bW5JbmZvQnlJZFtzb3J0RW50cnkuaWRdO1xuICAgICAgICAgIGNvbnN0IGlzRGVzYyA9IChfc29ydEVudHJ5JGRlc2MgPSBzb3J0RW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHNvcnRFbnRyeS5kZXNjKSAhPSBudWxsID8gX3NvcnRFbnRyeSRkZXNjIDogZmFsc2U7XG4gICAgICAgICAgbGV0IHNvcnRJbnQgPSAwO1xuXG4gICAgICAgICAgLy8gQWxsIHNvcnRpbmcgaW50cyBzaG91bGQgYWx3YXlzIHJldHVybiBpbiBhc2NlbmRpbmcgb3JkZXJcbiAgICAgICAgICBpZiAoY29sdW1uSW5mby5zb3J0VW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBhVmFsdWUgPSByb3dBLmdldFZhbHVlKHNvcnRFbnRyeS5pZCk7XG4gICAgICAgICAgICBjb25zdCBiVmFsdWUgPSByb3dCLmdldFZhbHVlKHNvcnRFbnRyeS5pZCk7XG4gICAgICAgICAgICBjb25zdCBhVW5kZWZpbmVkID0gYVZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBiVW5kZWZpbmVkID0gYlZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoYVVuZGVmaW5lZCB8fCBiVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHNvcnRJbnQgPSBhVW5kZWZpbmVkICYmIGJVbmRlZmluZWQgPyAwIDogYVVuZGVmaW5lZCA/IGNvbHVtbkluZm8uc29ydFVuZGVmaW5lZCA6IC1jb2x1bW5JbmZvLnNvcnRVbmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3J0SW50ID09PSAwKSB7XG4gICAgICAgICAgICBzb3J0SW50ID0gY29sdW1uSW5mby5zb3J0aW5nRm4ocm93QSwgcm93Qiwgc29ydEVudHJ5LmlkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBzb3J0aW5nIGlzIG5vbi16ZXJvLCB0YWtlIGNhcmUgb2YgZGVzYyBhbmQgaW52ZXJzaW9uXG4gICAgICAgICAgaWYgKHNvcnRJbnQgIT09IDApIHtcbiAgICAgICAgICAgIGlmIChpc0Rlc2MpIHtcbiAgICAgICAgICAgICAgc29ydEludCAqPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2x1bW5JbmZvLmludmVydFNvcnRpbmcpIHtcbiAgICAgICAgICAgICAgc29ydEludCAqPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3J0SW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93QS5pbmRleCAtIHJvd0IuaW5kZXg7XG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgdGhlcmUgYXJlIHN1Yi1yb3dzLCBzb3J0IHRoZW1cbiAgICAgIHNvcnRlZERhdGEuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICB2YXIgX3JvdyRzdWJSb3dzO1xuICAgICAgICBzb3J0ZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIGlmICgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCkge1xuICAgICAgICAgIHJvdy5zdWJSb3dzID0gc29ydERhdGEocm93LnN1YlJvd3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3J0ZWREYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvd3M6IHNvcnREYXRhKHJvd01vZGVsLnJvd3MpLFxuICAgICAgZmxhdFJvd3M6IHNvcnRlZEZsYXRSb3dzLFxuICAgICAgcm93c0J5SWQ6IHJvd01vZGVsLnJvd3NCeUlkXG4gICAgfTtcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0U29ydGVkUm93TW9kZWwnLCAoKSA9PiB0YWJsZS5fYXV0b1Jlc2V0UGFnZUluZGV4KCkpKTtcbn1cblxuZnVuY3Rpb24gZ2V0R3JvdXBlZFJvd01vZGVsKCkge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5ncm91cGluZywgdGFibGUuZ2V0UHJlR3JvdXBlZFJvd01vZGVsKCldLCAoZ3JvdXBpbmcsIHJvd01vZGVsKSA9PiB7XG4gICAgaWYgKCFyb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCAhZ3JvdXBpbmcubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIHRoZSBncm91cGluZyBsaXN0IGRvd24gdG8gY29sdW1ucyB0aGF0IGV4aXN0XG4gICAgY29uc3QgZXhpc3RpbmdHcm91cGluZyA9IGdyb3VwaW5nLmZpbHRlcihjb2x1bW5JZCA9PiB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpKTtcbiAgICBjb25zdCBncm91cGVkRmxhdFJvd3MgPSBbXTtcbiAgICBjb25zdCBncm91cGVkUm93c0J5SWQgPSB7fTtcbiAgICAvLyBjb25zdCBvbmx5R3JvdXBlZEZsYXRSb3dzOiBSb3dbXSA9IFtdO1xuICAgIC8vIGNvbnN0IG9ubHlHcm91cGVkUm93c0J5SWQ6IFJlY29yZDxSb3dJZCwgUm93PiA9IHt9O1xuICAgIC8vIGNvbnN0IG5vbkdyb3VwZWRGbGF0Um93czogUm93W10gPSBbXTtcbiAgICAvLyBjb25zdCBub25Hcm91cGVkUm93c0J5SWQ6IFJlY29yZDxSb3dJZCwgUm93PiA9IHt9O1xuXG4gICAgLy8gUmVjdXJzaXZlbHkgZ3JvdXAgdGhlIGRhdGFcbiAgICBjb25zdCBncm91cFVwUmVjdXJzaXZlbHkgPSBmdW5jdGlvbiAocm93cywgZGVwdGgsIHBhcmVudElkKSB7XG4gICAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgICBkZXB0aCA9IDA7XG4gICAgICB9XG4gICAgICAvLyBHcm91cGluZyBkZXB0aCBoYXMgYmVlbiBiZWVuIG1ldFxuICAgICAgLy8gU3RvcCBncm91cGluZyBhbmQgc2ltcGx5IHJld3JpdGUgdGhkIGRlcHRoIGFuZCByb3cgcmVsYXRpb25zaGlwc1xuICAgICAgaWYgKGRlcHRoID49IGV4aXN0aW5nR3JvdXBpbmcubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgICAgIHJvdy5kZXB0aCA9IGRlcHRoO1xuICAgICAgICAgIGdyb3VwZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgZ3JvdXBlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgICAgaWYgKHJvdy5zdWJSb3dzKSB7XG4gICAgICAgICAgICByb3cuc3ViUm93cyA9IGdyb3VwVXBSZWN1cnNpdmVseShyb3cuc3ViUm93cywgZGVwdGggKyAxLCByb3cuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbHVtbklkID0gZXhpc3RpbmdHcm91cGluZ1tkZXB0aF07XG5cbiAgICAgIC8vIEdyb3VwIHRoZSByb3dzIHRvZ2V0aGVyIGZvciB0aGlzIGxldmVsXG4gICAgICBjb25zdCByb3dHcm91cHNNYXAgPSBncm91cEJ5KHJvd3MsIGNvbHVtbklkKTtcblxuICAgICAgLy8gUGVmb3JtIGFnZ3JlZ2F0aW9ucyBmb3IgZWFjaCBncm91cFxuICAgICAgY29uc3QgYWdncmVnYXRlZEdyb3VwZWRSb3dzID0gQXJyYXkuZnJvbShyb3dHcm91cHNNYXAuZW50cmllcygpKS5tYXAoKF9yZWYsIGluZGV4KSA9PiB7XG4gICAgICAgIGxldCBbZ3JvdXBpbmdWYWx1ZSwgZ3JvdXBlZFJvd3NdID0gX3JlZjtcbiAgICAgICAgbGV0IGlkID0gYCR7Y29sdW1uSWR9OiR7Z3JvdXBpbmdWYWx1ZX1gO1xuICAgICAgICBpZCA9IHBhcmVudElkID8gYCR7cGFyZW50SWR9PiR7aWR9YCA6IGlkO1xuXG4gICAgICAgIC8vIEZpcnN0LCBSZWN1cnNlIHRvIGdyb3VwIHN1YiByb3dzIGJlZm9yZSBhZ2dyZWdhdGlvblxuICAgICAgICBjb25zdCBzdWJSb3dzID0gZ3JvdXBVcFJlY3Vyc2l2ZWx5KGdyb3VwZWRSb3dzLCBkZXB0aCArIDEsIGlkKTtcblxuICAgICAgICAvLyBGbGF0dGVuIHRoZSBsZWFmIHJvd3Mgb2YgdGhlIHJvd3MgaW4gdGhpcyBncm91cFxuICAgICAgICBjb25zdCBsZWFmUm93cyA9IGRlcHRoID8gZmxhdHRlbkJ5KGdyb3VwZWRSb3dzLCByb3cgPT4gcm93LnN1YlJvd3MpIDogZ3JvdXBlZFJvd3M7XG4gICAgICAgIGNvbnN0IHJvdyA9IGNyZWF0ZVJvdyh0YWJsZSwgaWQsIGxlYWZSb3dzWzBdLm9yaWdpbmFsLCBpbmRleCwgZGVwdGgsIHVuZGVmaW5lZCwgcGFyZW50SWQpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHJvdywge1xuICAgICAgICAgIGdyb3VwaW5nQ29sdW1uSWQ6IGNvbHVtbklkLFxuICAgICAgICAgIGdyb3VwaW5nVmFsdWUsXG4gICAgICAgICAgc3ViUm93cyxcbiAgICAgICAgICBsZWFmUm93cyxcbiAgICAgICAgICBnZXRWYWx1ZTogY29sdW1uSWQgPT4ge1xuICAgICAgICAgICAgLy8gRG9uJ3QgYWdncmVnYXRlIGNvbHVtbnMgdGhhdCBhcmUgaW4gdGhlIGdyb3VwaW5nXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdHcm91cGluZy5pbmNsdWRlcyhjb2x1bW5JZCkpIHtcbiAgICAgICAgICAgICAgaWYgKHJvdy5fdmFsdWVzQ2FjaGUuaGFzT3duUHJvcGVydHkoY29sdW1uSWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChncm91cGVkUm93c1swXSkge1xuICAgICAgICAgICAgICAgIHZhciBfZ3JvdXBlZFJvd3MkMCRnZXRWYWw7XG4gICAgICAgICAgICAgICAgcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSAoX2dyb3VwZWRSb3dzJDAkZ2V0VmFsID0gZ3JvdXBlZFJvd3NbMF0uZ2V0VmFsdWUoY29sdW1uSWQpKSAhPSBudWxsID8gX2dyb3VwZWRSb3dzJDAkZ2V0VmFsIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGUuaGFzT3duUHJvcGVydHkoY29sdW1uSWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZ2dyZWdhdGUgdGhlIHZhbHVlc1xuICAgICAgICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKTtcbiAgICAgICAgICAgIGNvbnN0IGFnZ3JlZ2F0ZUZuID0gY29sdW1uID09IG51bGwgPyB2b2lkIDAgOiBjb2x1bW4uZ2V0QWdncmVnYXRpb25GbigpO1xuICAgICAgICAgICAgaWYgKGFnZ3JlZ2F0ZUZuKSB7XG4gICAgICAgICAgICAgIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBhZ2dyZWdhdGVGbihjb2x1bW5JZCwgbGVhZlJvd3MsIGdyb3VwZWRSb3dzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc3ViUm93cy5mb3JFYWNoKHN1YlJvdyA9PiB7XG4gICAgICAgICAgZ3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgICAgICBncm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgICAvLyBpZiAoc3ViUm93LmdldElzR3JvdXBlZD8uKCkpIHtcbiAgICAgICAgICAvLyAgIG9ubHlHcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgIC8vICAgb25seUdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgLy8gICBub25Hcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgIC8vICAgbm9uR3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAgICAgLy8gfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFnZ3JlZ2F0ZWRHcm91cGVkUm93cztcbiAgICB9O1xuICAgIGNvbnN0IGdyb3VwZWRSb3dzID0gZ3JvdXBVcFJlY3Vyc2l2ZWx5KHJvd01vZGVsLnJvd3MsIDApO1xuICAgIGdyb3VwZWRSb3dzLmZvckVhY2goc3ViUm93ID0+IHtcbiAgICAgIGdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICBncm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgIC8vIGlmIChzdWJSb3cuZ2V0SXNHcm91cGVkPy4oKSkge1xuICAgICAgLy8gICBvbmx5R3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgIC8vICAgb25seUdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgbm9uR3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgIC8vICAgbm9uR3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAvLyB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvd3M6IGdyb3VwZWRSb3dzLFxuICAgICAgZmxhdFJvd3M6IGdyb3VwZWRGbGF0Um93cyxcbiAgICAgIHJvd3NCeUlkOiBncm91cGVkUm93c0J5SWRcbiAgICB9O1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRHcm91cGVkUm93TW9kZWwnLCAoKSA9PiB7XG4gICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgIHRhYmxlLl9hdXRvUmVzZXRFeHBhbmRlZCgpO1xuICAgICAgdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpO1xuICAgIH0pO1xuICB9KSk7XG59XG5mdW5jdGlvbiBncm91cEJ5KHJvd3MsIGNvbHVtbklkKSB7XG4gIGNvbnN0IGdyb3VwTWFwID0gbmV3IE1hcCgpO1xuICByZXR1cm4gcm93cy5yZWR1Y2UoKG1hcCwgcm93KSA9PiB7XG4gICAgY29uc3QgcmVzS2V5ID0gYCR7cm93LmdldEdyb3VwaW5nVmFsdWUoY29sdW1uSWQpfWA7XG4gICAgY29uc3QgcHJldmlvdXMgPSBtYXAuZ2V0KHJlc0tleSk7XG4gICAgaWYgKCFwcmV2aW91cykge1xuICAgICAgbWFwLnNldChyZXNLZXksIFtyb3ddKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXMucHVzaChyb3cpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9LCBncm91cE1hcCk7XG59XG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkLCB0YWJsZS5nZXRQcmVFeHBhbmRlZFJvd01vZGVsKCksIHRhYmxlLm9wdGlvbnMucGFnaW5hdGVFeHBhbmRlZFJvd3NdLCAoZXhwYW5kZWQsIHJvd01vZGVsLCBwYWdpbmF0ZUV4cGFuZGVkUm93cykgPT4ge1xuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGggfHwgZXhwYW5kZWQgIT09IHRydWUgJiYgIU9iamVjdC5rZXlzKGV4cGFuZGVkICE9IG51bGwgPyBleHBhbmRlZCA6IHt9KS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG4gICAgaWYgKCFwYWdpbmF0ZUV4cGFuZGVkUm93cykge1xuICAgICAgLy8gT25seSBleHBhbmQgcm93cyBhdCB0aGlzIHBvaW50IGlmIHRoZXkgYXJlIGJlaW5nIHBhZ2luYXRlZFxuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cbiAgICByZXR1cm4gZXhwYW5kUm93cyhyb3dNb2RlbCk7XG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEV4cGFuZGVkUm93TW9kZWwnKSk7XG59XG5mdW5jdGlvbiBleHBhbmRSb3dzKHJvd01vZGVsKSB7XG4gIGNvbnN0IGV4cGFuZGVkUm93cyA9IFtdO1xuICBjb25zdCBoYW5kbGVSb3cgPSByb3cgPT4ge1xuICAgIHZhciBfcm93JHN1YlJvd3M7XG4gICAgZXhwYW5kZWRSb3dzLnB1c2gocm93KTtcbiAgICBpZiAoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGggJiYgcm93LmdldElzRXhwYW5kZWQoKSkge1xuICAgICAgcm93LnN1YlJvd3MuZm9yRWFjaChoYW5kbGVSb3cpO1xuICAgIH1cbiAgfTtcbiAgcm93TW9kZWwucm93cy5mb3JFYWNoKGhhbmRsZVJvdyk7XG4gIHJldHVybiB7XG4gICAgcm93czogZXhwYW5kZWRSb3dzLFxuICAgIGZsYXRSb3dzOiByb3dNb2RlbC5mbGF0Um93cyxcbiAgICByb3dzQnlJZDogcm93TW9kZWwucm93c0J5SWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFnaW5hdGlvblJvd01vZGVsKG9wdHMpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkucGFnaW5hdGlvbiwgdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCksIHRhYmxlLm9wdGlvbnMucGFnaW5hdGVFeHBhbmRlZFJvd3MgPyB1bmRlZmluZWQgOiB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkXSwgKHBhZ2luYXRpb24sIHJvd01vZGVsKSA9PiB7XG4gICAgaWYgKCFyb3dNb2RlbC5yb3dzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlU2l6ZSxcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0gPSBwYWdpbmF0aW9uO1xuICAgIGxldCB7XG4gICAgICByb3dzLFxuICAgICAgZmxhdFJvd3MsXG4gICAgICByb3dzQnlJZFxuICAgIH0gPSByb3dNb2RlbDtcbiAgICBjb25zdCBwYWdlU3RhcnQgPSBwYWdlU2l6ZSAqIHBhZ2VJbmRleDtcbiAgICBjb25zdCBwYWdlRW5kID0gcGFnZVN0YXJ0ICsgcGFnZVNpemU7XG4gICAgcm93cyA9IHJvd3Muc2xpY2UocGFnZVN0YXJ0LCBwYWdlRW5kKTtcbiAgICBsZXQgcGFnaW5hdGVkUm93TW9kZWw7XG4gICAgaWYgKCF0YWJsZS5vcHRpb25zLnBhZ2luYXRlRXhwYW5kZWRSb3dzKSB7XG4gICAgICBwYWdpbmF0ZWRSb3dNb2RlbCA9IGV4cGFuZFJvd3Moe1xuICAgICAgICByb3dzLFxuICAgICAgICBmbGF0Um93cyxcbiAgICAgICAgcm93c0J5SWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWdpbmF0ZWRSb3dNb2RlbCA9IHtcbiAgICAgICAgcm93cyxcbiAgICAgICAgZmxhdFJvd3MsXG4gICAgICAgIHJvd3NCeUlkXG4gICAgICB9O1xuICAgIH1cbiAgICBwYWdpbmF0ZWRSb3dNb2RlbC5mbGF0Um93cyA9IFtdO1xuICAgIGNvbnN0IGhhbmRsZVJvdyA9IHJvdyA9PiB7XG4gICAgICBwYWdpbmF0ZWRSb3dNb2RlbC5mbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICBpZiAocm93LnN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgIHJvdy5zdWJSb3dzLmZvckVhY2goaGFuZGxlUm93KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHBhZ2luYXRlZFJvd01vZGVsLnJvd3MuZm9yRWFjaChoYW5kbGVSb3cpO1xuICAgIHJldHVybiBwYWdpbmF0ZWRSb3dNb2RlbDtcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0UGFnaW5hdGlvblJvd01vZGVsJykpO1xufVxuXG5leHBvcnQgeyBDb2x1bW5TaXppbmcsIEV4cGFuZGluZywgRmlsdGVycywgR3JvdXBpbmcsIEhlYWRlcnMsIE9yZGVyaW5nLCBQYWdpbmF0aW9uLCBQaW5uaW5nLCBSb3dTZWxlY3Rpb24sIFNvcnRpbmcsIFZpc2liaWxpdHksIF9nZXRWaXNpYmxlTGVhZkNvbHVtbnMsIGFnZ3JlZ2F0aW9uRm5zLCBidWlsZEhlYWRlckdyb3VwcywgY3JlYXRlQ2VsbCwgY3JlYXRlQ29sdW1uLCBjcmVhdGVDb2x1bW5IZWxwZXIsIGNyZWF0ZVJvdywgY3JlYXRlVGFibGUsIGRlZmF1bHRDb2x1bW5TaXppbmcsIGV4cGFuZFJvd3MsIGZpbHRlckZucywgZmxhdHRlbkJ5LCBmdW5jdGlvbmFsVXBkYXRlLCBnZXRDb3JlUm93TW9kZWwsIGdldEV4cGFuZGVkUm93TW9kZWwsIGdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMsIGdldEZhY2V0ZWRSb3dNb2RlbCwgZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcywgZ2V0RmlsdGVyZWRSb3dNb2RlbCwgZ2V0R3JvdXBlZFJvd01vZGVsLCBnZXRNZW1vT3B0aW9ucywgZ2V0UGFnaW5hdGlvblJvd01vZGVsLCBnZXRTb3J0ZWRSb3dNb2RlbCwgaXNGdW5jdGlvbiwgaXNOdW1iZXJBcnJheSwgaXNSb3dTZWxlY3RlZCwgaXNTdWJSb3dTZWxlY3RlZCwgbWFrZVN0YXRlVXBkYXRlciwgbWVtbywgbm9vcCwgb3JkZXJDb2x1bW5zLCBwYXNzaXZlRXZlbnRTdXBwb3J0ZWQsIHJlU3BsaXRBbHBoYU51bWVyaWMsIHNlbGVjdFJvd3NGbiwgc2hvdWxkQXV0b1JlbW92ZUZpbHRlciwgc29ydGluZ0ZucyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbImZ1bmN0aW9uYWxVcGRhdGUiLCJ1cGRhdGVyIiwiaW5wdXQiLCJub29wIiwibWFrZVN0YXRlVXBkYXRlciIsImtleSIsImluc3RhbmNlIiwic2V0U3RhdGUiLCJvbGQiLCJpc0Z1bmN0aW9uIiwiZCIsIkZ1bmN0aW9uIiwiaXNOdW1iZXJBcnJheSIsIkFycmF5IiwiaXNBcnJheSIsImV2ZXJ5IiwidmFsIiwiZmxhdHRlbkJ5IiwiYXJyIiwiZ2V0Q2hpbGRyZW4iLCJmbGF0IiwicmVjdXJzZSIsInN1YkFyciIsImZvckVhY2giLCJpdGVtIiwicHVzaCIsImNoaWxkcmVuIiwibGVuZ3RoIiwibWVtbyIsImdldERlcHMiLCJmbiIsIm9wdHMiLCJkZXBzIiwicmVzdWx0IiwiZGVwQXJncyIsImRlcFRpbWUiLCJkZWJ1ZyIsIkRhdGUiLCJub3ciLCJuZXdEZXBzIiwiZGVwc0NoYW5nZWQiLCJzb21lIiwiZGVwIiwiaW5kZXgiLCJyZXN1bHRUaW1lIiwib25DaGFuZ2UiLCJkZXBFbmRUaW1lIiwiTWF0aCIsInJvdW5kIiwicmVzdWx0RW5kVGltZSIsInJlc3VsdEZwc1BlcmNlbnRhZ2UiLCJwYWQiLCJzdHIiLCJudW0iLCJTdHJpbmciLCJjb25zb2xlIiwiaW5mbyIsIm1heCIsIm1pbiIsImdldE1lbW9PcHRpb25zIiwidGFibGVPcHRpb25zIiwiZGVidWdMZXZlbCIsIl90YWJsZU9wdGlvbnMkZGVidWdBbCIsImRlYnVnQWxsIiwicHJvY2VzcyIsImNyZWF0ZUNvbHVtbiIsInRhYmxlIiwiY29sdW1uRGVmIiwiZGVwdGgiLCJwYXJlbnQiLCJfcmVmIiwiX3Jlc29sdmVkQ29sdW1uRGVmJGlkIiwiZGVmYXVsdENvbHVtbiIsIl9nZXREZWZhdWx0Q29sdW1uRGVmIiwicmVzb2x2ZWRDb2x1bW5EZWYiLCJhY2Nlc3NvcktleSIsImlkIiwicmVwbGFjZSIsInVuZGVmaW5lZCIsImhlYWRlciIsImFjY2Vzc29yRm4iLCJpbmNsdWRlcyIsIm9yaWdpbmFsUm93Iiwic3BsaXQiLCJfcmVzdWx0Iiwid2FybiIsIkVycm9yIiwiY29sdW1uIiwiY29sdW1ucyIsImdldEZsYXRDb2x1bW5zIiwiX2NvbHVtbiRjb2x1bW5zIiwiZmxhdE1hcCIsIm9wdGlvbnMiLCJnZXRMZWFmQ29sdW1ucyIsIl9nZXRPcmRlckNvbHVtbnNGbiIsIm9yZGVyQ29sdW1ucyIsIl9jb2x1bW4kY29sdW1uczIiLCJsZWFmQ29sdW1ucyIsImZlYXR1cmUiLCJfZmVhdHVyZXMiLCJjcmVhdGVIZWFkZXIiLCJfb3B0aW9ucyRpZCIsImlzUGxhY2Vob2xkZXIiLCJwbGFjZWhvbGRlcklkIiwic3ViSGVhZGVycyIsImNvbFNwYW4iLCJyb3dTcGFuIiwiaGVhZGVyR3JvdXAiLCJnZXRMZWFmSGVhZGVycyIsImxlYWZIZWFkZXJzIiwicmVjdXJzZUhlYWRlciIsImgiLCJtYXAiLCJnZXRDb250ZXh0IiwiSGVhZGVycyIsImNyZWF0ZVRhYmxlIiwiZ2V0SGVhZGVyR3JvdXBzIiwiZ2V0QWxsQ29sdW1ucyIsImdldFZpc2libGVMZWFmQ29sdW1ucyIsImdldFN0YXRlIiwiY29sdW1uUGlubmluZyIsImxlZnQiLCJyaWdodCIsImFsbENvbHVtbnMiLCJfbGVmdCRtYXAkZmlsdGVyIiwiX3JpZ2h0JG1hcCRmaWx0ZXIiLCJsZWZ0Q29sdW1ucyIsImNvbHVtbklkIiwiZmluZCIsImZpbHRlciIsIkJvb2xlYW4iLCJyaWdodENvbHVtbnMiLCJjZW50ZXJDb2x1bW5zIiwiaGVhZGVyR3JvdXBzIiwiYnVpbGRIZWFkZXJHcm91cHMiLCJnZXRDZW50ZXJIZWFkZXJHcm91cHMiLCJnZXRMZWZ0SGVhZGVyR3JvdXBzIiwiX2xlZnQkbWFwJGZpbHRlcjIiLCJvcmRlcmVkTGVhZkNvbHVtbnMiLCJnZXRSaWdodEhlYWRlckdyb3VwcyIsIl9yaWdodCRtYXAkZmlsdGVyMiIsImdldEZvb3Rlckdyb3VwcyIsInJldmVyc2UiLCJnZXRMZWZ0Rm9vdGVyR3JvdXBzIiwiZ2V0Q2VudGVyRm9vdGVyR3JvdXBzIiwiZ2V0UmlnaHRGb290ZXJHcm91cHMiLCJnZXRGbGF0SGVhZGVycyIsImhlYWRlcnMiLCJnZXRMZWZ0RmxhdEhlYWRlcnMiLCJnZXRDZW50ZXJGbGF0SGVhZGVycyIsImdldFJpZ2h0RmxhdEhlYWRlcnMiLCJnZXRDZW50ZXJMZWFmSGVhZGVycyIsImZsYXRIZWFkZXJzIiwiX2hlYWRlciRzdWJIZWFkZXJzIiwiZ2V0TGVmdExlYWZIZWFkZXJzIiwiX2hlYWRlciRzdWJIZWFkZXJzMiIsImdldFJpZ2h0TGVhZkhlYWRlcnMiLCJfaGVhZGVyJHN1YkhlYWRlcnMzIiwiY2VudGVyIiwiX2xlZnQkMCRoZWFkZXJzIiwiX2xlZnQkIiwiX2NlbnRlciQwJGhlYWRlcnMiLCJfY2VudGVyJCIsIl9yaWdodCQwJGhlYWRlcnMiLCJfcmlnaHQkIiwiY29sdW1uc1RvR3JvdXAiLCJoZWFkZXJGYW1pbHkiLCJfaGVhZGVyR3JvdXBzJDAkaGVhZGUiLCJfaGVhZGVyR3JvdXBzJCIsIm1heERlcHRoIiwiZmluZE1heERlcHRoIiwiZ2V0SXNWaXNpYmxlIiwiY3JlYXRlSGVhZGVyR3JvdXAiLCJoZWFkZXJzVG9Hcm91cCIsImpvaW4iLCJwZW5kaW5nUGFyZW50SGVhZGVycyIsImhlYWRlclRvR3JvdXAiLCJsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyIiwiaXNMZWFmSGVhZGVyIiwiYm90dG9tSGVhZGVycyIsInJlY3Vyc2VIZWFkZXJzRm9yU3BhbnMiLCJmaWx0ZXJlZEhlYWRlcnMiLCJjaGlsZFJvd1NwYW5zIiwiY2hpbGRDb2xTcGFuIiwiY2hpbGRSb3dTcGFuIiwibWluQ2hpbGRSb3dTcGFuIiwiZGVmYXVsdENvbHVtblNpemluZyIsInNpemUiLCJtaW5TaXplIiwibWF4U2l6ZSIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlIiwic3RhcnRPZmZzZXQiLCJzdGFydFNpemUiLCJkZWx0YU9mZnNldCIsImRlbHRhUGVyY2VudGFnZSIsImlzUmVzaXppbmdDb2x1bW4iLCJjb2x1bW5TaXppbmdTdGFydCIsIkNvbHVtblNpemluZyIsImdldERlZmF1bHRDb2x1bW5EZWYiLCJnZXRJbml0aWFsU3RhdGUiLCJzdGF0ZSIsImNvbHVtblNpemluZyIsImNvbHVtblNpemluZ0luZm8iLCJnZXREZWZhdWx0T3B0aW9ucyIsImNvbHVtblJlc2l6ZU1vZGUiLCJjb2x1bW5SZXNpemVEaXJlY3Rpb24iLCJvbkNvbHVtblNpemluZ0NoYW5nZSIsIm9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZSIsImdldFNpemUiLCJfY29sdW1uJGNvbHVtbkRlZiRtaW4iLCJfY29sdW1uJGNvbHVtbkRlZiRtYXgiLCJjb2x1bW5TaXplIiwiZ2V0U3RhcnQiLCJwb3NpdGlvbiIsIl9nZXRWaXNpYmxlTGVhZkNvbHVtbnMiLCJzbGljZSIsImdldEluZGV4IiwicmVkdWNlIiwic3VtIiwiZ2V0QWZ0ZXIiLCJyZXNldFNpemUiLCJzZXRDb2x1bW5TaXppbmciLCJfcmVmMiIsIl8iLCJyZXN0IiwiZ2V0Q2FuUmVzaXplIiwiX2NvbHVtbiRjb2x1bW5EZWYkZW5hIiwiX3RhYmxlJG9wdGlvbnMkZW5hYmxlIiwiZW5hYmxlUmVzaXppbmciLCJlbmFibGVDb2x1bW5SZXNpemluZyIsImdldElzUmVzaXppbmciLCJfaGVhZGVyJGNvbHVtbiRnZXRTaXoiLCJwcmV2U2libGluZ0hlYWRlciIsImdldFJlc2l6ZUhhbmRsZXIiLCJfY29udGV4dERvY3VtZW50IiwiZ2V0Q29sdW1uIiwiY2FuUmVzaXplIiwiZSIsInBlcnNpc3QiLCJpc1RvdWNoU3RhcnRFdmVudCIsInRvdWNoZXMiLCJjbGllbnRYIiwibmV3Q29sdW1uU2l6aW5nIiwidXBkYXRlT2Zmc2V0IiwiZXZlbnRUeXBlIiwiY2xpZW50WFBvcyIsInNldENvbHVtblNpemluZ0luZm8iLCJfb2xkJHN0YXJ0T2Zmc2V0IiwiX29sZCRzdGFydFNpemUiLCJkZWx0YURpcmVjdGlvbiIsIl9yZWYzIiwiaGVhZGVyU2l6ZSIsIm9uTW92ZSIsIm9uRW5kIiwiY29udGV4dERvY3VtZW50IiwiZG9jdW1lbnQiLCJtb3VzZUV2ZW50cyIsIm1vdmVIYW5kbGVyIiwidXBIYW5kbGVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInRvdWNoRXZlbnRzIiwiY2FuY2VsYWJsZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiX2UkdG91Y2hlcyQiLCJwYXNzaXZlSWZTdXBwb3J0ZWQiLCJwYXNzaXZlRXZlbnRTdXBwb3J0ZWQiLCJwYXNzaXZlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlc2V0Q29sdW1uU2l6aW5nIiwiZGVmYXVsdFN0YXRlIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRjIiwiaW5pdGlhbFN0YXRlIiwicmVzZXRIZWFkZXJTaXplSW5mbyIsIl90YWJsZSRpbml0aWFsU3RhdGUkYzIiLCJnZXRUb3RhbFNpemUiLCJfdGFibGUkZ2V0SGVhZGVyR3JvdXAiLCJfdGFibGUkZ2V0SGVhZGVyR3JvdXAyIiwiZ2V0TGVmdFRvdGFsU2l6ZSIsIl90YWJsZSRnZXRMZWZ0SGVhZGVyRyIsIl90YWJsZSRnZXRMZWZ0SGVhZGVyRzIiLCJnZXRDZW50ZXJUb3RhbFNpemUiLCJfdGFibGUkZ2V0Q2VudGVySGVhZGUiLCJfdGFibGUkZ2V0Q2VudGVySGVhZGUyIiwiZ2V0UmlnaHRUb3RhbFNpemUiLCJfdGFibGUkZ2V0UmlnaHRIZWFkZXIiLCJfdGFibGUkZ2V0UmlnaHRIZWFkZXIyIiwicGFzc2l2ZVN1cHBvcnRlZCIsInN1cHBvcnRlZCIsIndpbmRvdyIsImVyciIsInR5cGUiLCJFeHBhbmRpbmciLCJleHBhbmRlZCIsIm9uRXhwYW5kZWRDaGFuZ2UiLCJwYWdpbmF0ZUV4cGFuZGVkUm93cyIsInJlZ2lzdGVyZWQiLCJxdWV1ZWQiLCJfYXV0b1Jlc2V0RXhwYW5kZWQiLCJfdGFibGUkb3B0aW9ucyRhdXRvUmUiLCJfcXVldWUiLCJhdXRvUmVzZXRBbGwiLCJhdXRvUmVzZXRFeHBhbmRlZCIsIm1hbnVhbEV4cGFuZGluZyIsInJlc2V0RXhwYW5kZWQiLCJzZXRFeHBhbmRlZCIsInRvZ2dsZUFsbFJvd3NFeHBhbmRlZCIsImdldElzQWxsUm93c0V4cGFuZGVkIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRlIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSIsImdldENhblNvbWVSb3dzRXhwYW5kIiwiZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsIiwiZmxhdFJvd3MiLCJyb3ciLCJnZXRDYW5FeHBhbmQiLCJnZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRIYW5kbGVyIiwiZ2V0SXNTb21lUm93c0V4cGFuZGVkIiwiT2JqZWN0IiwidmFsdWVzIiwia2V5cyIsImdldFJvd01vZGVsIiwiZ2V0SXNFeHBhbmRlZCIsImdldEV4cGFuZGVkRGVwdGgiLCJyb3dJZHMiLCJyb3dzQnlJZCIsInNwbGl0SWQiLCJnZXRQcmVFeHBhbmRlZFJvd01vZGVsIiwiZ2V0U29ydGVkUm93TW9kZWwiLCJnZXRFeHBhbmRlZFJvd01vZGVsIiwiX2dldEV4cGFuZGVkUm93TW9kZWwiLCJjcmVhdGVSb3ciLCJ0b2dnbGVFeHBhbmRlZCIsIl9leHBhbmRlZCIsImV4aXN0cyIsIm9sZEV4cGFuZGVkIiwicm93SWQiLCJfdGFibGUkb3B0aW9ucyRnZXRJc1IiLCJnZXRJc1Jvd0V4cGFuZGVkIiwiX3RhYmxlJG9wdGlvbnMkZ2V0Um93IiwiX3JvdyRzdWJSb3dzIiwiZ2V0Um93Q2FuRXhwYW5kIiwiZW5hYmxlRXhwYW5kaW5nIiwic3ViUm93cyIsImdldElzQWxsUGFyZW50c0V4cGFuZGVkIiwiaXNGdWxseUV4cGFuZGVkIiwiY3VycmVudFJvdyIsInBhcmVudElkIiwiZ2V0Um93IiwiZ2V0VG9nZ2xlRXhwYW5kZWRIYW5kbGVyIiwiY2FuRXhwYW5kIiwiaW5jbHVkZXNTdHJpbmciLCJmaWx0ZXJWYWx1ZSIsIl9yb3ckZ2V0VmFsdWUiLCJzZWFyY2giLCJ0b0xvd2VyQ2FzZSIsImdldFZhbHVlIiwidG9TdHJpbmciLCJhdXRvUmVtb3ZlIiwidGVzdEZhbHNleSIsImluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlIiwiX3JvdyRnZXRWYWx1ZTIiLCJlcXVhbHNTdHJpbmciLCJfcm93JGdldFZhbHVlMyIsImFyckluY2x1ZGVzIiwiX3JvdyRnZXRWYWx1ZTQiLCJhcnJJbmNsdWRlc0FsbCIsIl9yb3ckZ2V0VmFsdWU1IiwiYXJySW5jbHVkZXNTb21lIiwiX3JvdyRnZXRWYWx1ZTYiLCJlcXVhbHMiLCJ3ZWFrRXF1YWxzIiwiaW5OdW1iZXJSYW5nZSIsInJvd1ZhbHVlIiwicmVzb2x2ZUZpbHRlclZhbHVlIiwidW5zYWZlTWluIiwidW5zYWZlTWF4IiwicGFyc2VkTWluIiwicGFyc2VGbG9hdCIsInBhcnNlZE1heCIsImlzTmFOIiwiSW5maW5pdHkiLCJ0ZW1wIiwiZmlsdGVyRm5zIiwiRmlsdGVycyIsImZpbHRlckZuIiwiY29sdW1uRmlsdGVycyIsImdsb2JhbEZpbHRlciIsIm9uQ29sdW1uRmlsdGVyc0NoYW5nZSIsIm9uR2xvYmFsRmlsdGVyQ2hhbmdlIiwiZmlsdGVyRnJvbUxlYWZSb3dzIiwibWF4TGVhZlJvd0ZpbHRlckRlcHRoIiwiZ2xvYmFsRmlsdGVyRm4iLCJnZXRDb2x1bW5DYW5HbG9iYWxGaWx0ZXIiLCJfdGFibGUkZ2V0Q29yZVJvd01vZGUiLCJ2YWx1ZSIsImdldENvcmVSb3dNb2RlbCIsIl9nZXRBbGxDZWxsc0J5Q29sdW1uSWQiLCJnZXRBdXRvRmlsdGVyRm4iLCJmaXJzdFJvdyIsImdldEZpbHRlckZuIiwiX3RhYmxlJG9wdGlvbnMkZmlsdGVyIiwiX3RhYmxlJG9wdGlvbnMkZmlsdGVyMiIsImdldENhbkZpbHRlciIsIl90YWJsZSRvcHRpb25zJGVuYWJsZTIiLCJlbmFibGVDb2x1bW5GaWx0ZXIiLCJlbmFibGVDb2x1bW5GaWx0ZXJzIiwiZW5hYmxlRmlsdGVycyIsImdldENhbkdsb2JhbEZpbHRlciIsIl9jb2x1bW4kY29sdW1uRGVmJGVuYTIiLCJfdGFibGUkb3B0aW9ucyRlbmFibGUzIiwiX3RhYmxlJG9wdGlvbnMkZW5hYmxlNCIsIl90YWJsZSRvcHRpb25zJGdldENvbCIsImVuYWJsZUdsb2JhbEZpbHRlciIsImdldElzRmlsdGVyZWQiLCJnZXRGaWx0ZXJJbmRleCIsImdldEZpbHRlclZhbHVlIiwiX3RhYmxlJGdldFN0YXRlJGNvbHVtIiwiX3RhYmxlJGdldFN0YXRlJGNvbHVtMiIsIl90YWJsZSRnZXRTdGF0ZSRjb2x1bTMiLCJmaW5kSW5kZXgiLCJzZXRGaWx0ZXJWYWx1ZSIsInNldENvbHVtbkZpbHRlcnMiLCJwcmV2aW91c2ZpbHRlciIsIm5ld0ZpbHRlciIsInNob3VsZEF1dG9SZW1vdmVGaWx0ZXIiLCJfb2xkJGZpbHRlciIsIm5ld0ZpbHRlck9iaiIsIl9vbGQkbWFwIiwiX2dldEZhY2V0ZWRSb3dNb2RlbCIsImdldEZhY2V0ZWRSb3dNb2RlbCIsImdldFByZUZpbHRlcmVkUm93TW9kZWwiLCJfZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyIsImdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJNYXAiLCJfZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyIsImdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJjb2x1bW5GaWx0ZXJzTWV0YSIsImdldEdsb2JhbEF1dG9GaWx0ZXJGbiIsImdldEdsb2JhbEZpbHRlckZuIiwiX3RhYmxlJG9wdGlvbnMkZmlsdGVyMyIsIl90YWJsZSRvcHRpb25zJGZpbHRlcjQiLCJnZXRBbGxMZWFmQ29sdW1ucyIsInVwZGF0ZUZuIiwiX2Z1bmN0aW9uYWxVcGRhdGUiLCJzZXRHbG9iYWxGaWx0ZXIiLCJyZXNldEdsb2JhbEZpbHRlciIsInJlc2V0Q29sdW1uRmlsdGVycyIsImdldEZpbHRlcmVkUm93TW9kZWwiLCJfZ2V0RmlsdGVyZWRSb3dNb2RlbCIsIm1hbnVhbEZpbHRlcmluZyIsIl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwiLCJnZXRHbG9iYWxGYWNldGVkUm93TW9kZWwiLCJfZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyIsImdldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJfZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcyIsImdldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJfbGVhZlJvd3MiLCJjaGlsZFJvd3MiLCJuZXh0IiwibmV4dFZhbHVlIiwiZXh0ZW50IiwibWVhbiIsImxlYWZSb3dzIiwiY291bnQiLCJtZWRpYW4iLCJtaWQiLCJmbG9vciIsIm51bXMiLCJzb3J0IiwiYSIsImIiLCJ1bmlxdWUiLCJmcm9tIiwiU2V0IiwidW5pcXVlQ291bnQiLCJfY29sdW1uSWQiLCJhZ2dyZWdhdGlvbkZucyIsIkdyb3VwaW5nIiwiYWdncmVnYXRlZENlbGwiLCJwcm9wcyIsIl90b1N0cmluZyIsIl9wcm9wcyRnZXRWYWx1ZSIsImFnZ3JlZ2F0aW9uRm4iLCJncm91cGluZyIsIm9uR3JvdXBpbmdDaGFuZ2UiLCJncm91cGVkQ29sdW1uTW9kZSIsInRvZ2dsZUdyb3VwaW5nIiwic2V0R3JvdXBpbmciLCJnZXRDYW5Hcm91cCIsImVuYWJsZUdyb3VwaW5nIiwiZ2V0SXNHcm91cGVkIiwiX3RhYmxlJGdldFN0YXRlJGdyb3VwIiwiZ2V0R3JvdXBlZEluZGV4IiwiX3RhYmxlJGdldFN0YXRlJGdyb3VwMiIsImluZGV4T2YiLCJnZXRUb2dnbGVHcm91cGluZ0hhbmRsZXIiLCJjYW5Hcm91cCIsImdldEF1dG9BZ2dyZWdhdGlvbkZuIiwicHJvdG90eXBlIiwiY2FsbCIsImdldEFnZ3JlZ2F0aW9uRm4iLCJfdGFibGUkb3B0aW9ucyRhZ2dyZWciLCJfdGFibGUkb3B0aW9ucyRhZ2dyZWcyIiwicmVzZXRHcm91cGluZyIsIl90YWJsZSRpbml0aWFsU3RhdGUkZyIsImdldFByZUdyb3VwZWRSb3dNb2RlbCIsImdldEdyb3VwZWRSb3dNb2RlbCIsIl9nZXRHcm91cGVkUm93TW9kZWwiLCJtYW51YWxHcm91cGluZyIsImdyb3VwaW5nQ29sdW1uSWQiLCJnZXRHcm91cGluZ1ZhbHVlIiwiX2dyb3VwaW5nVmFsdWVzQ2FjaGUiLCJoYXNPd25Qcm9wZXJ0eSIsIm9yaWdpbmFsIiwiY3JlYXRlQ2VsbCIsImNlbGwiLCJnZXRJc1BsYWNlaG9sZGVyIiwiZ2V0SXNBZ2dyZWdhdGVkIiwibm9uR3JvdXBpbmdDb2x1bW5zIiwiY29sIiwiZ3JvdXBpbmdDb2x1bW5zIiwiZyIsIk9yZGVyaW5nIiwiY29sdW1uT3JkZXIiLCJvbkNvbHVtbk9yZGVyQ2hhbmdlIiwiZ2V0SXNGaXJzdENvbHVtbiIsIl9jb2x1bW5zJCIsImdldElzTGFzdENvbHVtbiIsIl9jb2x1bW5zIiwic2V0Q29sdW1uT3JkZXIiLCJyZXNldENvbHVtbk9yZGVyIiwib3JkZXJlZENvbHVtbnMiLCJjb2x1bW5PcmRlckNvcHkiLCJjb2x1bW5zQ29weSIsInRhcmdldENvbHVtbklkIiwic2hpZnQiLCJmb3VuZEluZGV4Iiwic3BsaWNlIiwiZGVmYXVsdFBhZ2VJbmRleCIsImRlZmF1bHRQYWdlU2l6ZSIsImdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUiLCJwYWdlSW5kZXgiLCJwYWdlU2l6ZSIsIlBhZ2luYXRpb24iLCJwYWdpbmF0aW9uIiwib25QYWdpbmF0aW9uQ2hhbmdlIiwiX2F1dG9SZXNldFBhZ2VJbmRleCIsImF1dG9SZXNldFBhZ2VJbmRleCIsIm1hbnVhbFBhZ2luYXRpb24iLCJyZXNldFBhZ2VJbmRleCIsInNldFBhZ2luYXRpb24iLCJzYWZlVXBkYXRlciIsIm5ld1N0YXRlIiwicmVzZXRQYWdpbmF0aW9uIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRwIiwic2V0UGFnZUluZGV4IiwibWF4UGFnZUluZGV4IiwicGFnZUNvdW50IiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRwMiIsInJlc2V0UGFnZVNpemUiLCJfdGFibGUkaW5pdGlhbFN0YXRlJHAzIiwiX3RhYmxlJGluaXRpYWxTdGF0ZTIiLCJzZXRQYWdlU2l6ZSIsInRvcFJvd0luZGV4Iiwic2V0UGFnZUNvdW50IiwiX3RhYmxlJG9wdGlvbnMkcGFnZUNvIiwibmV3UGFnZUNvdW50IiwiZ2V0UGFnZU9wdGlvbnMiLCJnZXRQYWdlQ291bnQiLCJwYWdlT3B0aW9ucyIsImZpbGwiLCJpIiwiZ2V0Q2FuUHJldmlvdXNQYWdlIiwiZ2V0Q2FuTmV4dFBhZ2UiLCJwcmV2aW91c1BhZ2UiLCJuZXh0UGFnZSIsImZpcnN0UGFnZSIsImxhc3RQYWdlIiwiZ2V0UGFnaW5hdGlvblJvd01vZGVsIiwiX2dldFBhZ2luYXRpb25Sb3dNb2RlbCIsIl90YWJsZSRvcHRpb25zJHBhZ2VDbzIiLCJjZWlsIiwiZ2V0Um93Q291bnQiLCJfdGFibGUkb3B0aW9ucyRyb3dDb3UiLCJyb3dDb3VudCIsInJvd3MiLCJnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlIiwiZ2V0RGVmYXVsdFJvd1Bpbm5pbmdTdGF0ZSIsInRvcCIsImJvdHRvbSIsIlBpbm5pbmciLCJyb3dQaW5uaW5nIiwib25Db2x1bW5QaW5uaW5nQ2hhbmdlIiwib25Sb3dQaW5uaW5nQ2hhbmdlIiwicGluIiwiY29sdW1uSWRzIiwic2V0Q29sdW1uUGlubmluZyIsIl9vbGQkbGVmdDMiLCJfb2xkJHJpZ2h0MyIsIl9vbGQkbGVmdCIsIl9vbGQkcmlnaHQiLCJfb2xkJGxlZnQyIiwiX29sZCRyaWdodDIiLCJnZXRDYW5QaW4iLCJfZCRjb2x1bW5EZWYkZW5hYmxlUGkiLCJlbmFibGVQaW5uaW5nIiwiZW5hYmxlQ29sdW1uUGlubmluZyIsImdldElzUGlubmVkIiwibGVhZkNvbHVtbklkcyIsImlzTGVmdCIsImlzUmlnaHQiLCJnZXRQaW5uZWRJbmRleCIsImluY2x1ZGVMZWFmUm93cyIsImluY2x1ZGVQYXJlbnRSb3dzIiwibGVhZlJvd0lkcyIsImdldExlYWZSb3dzIiwicGFyZW50Um93SWRzIiwiZ2V0UGFyZW50Um93cyIsInNldFJvd1Bpbm5pbmciLCJfb2xkJHRvcDMiLCJfb2xkJGJvdHRvbTMiLCJfb2xkJHRvcCIsIl9vbGQkYm90dG9tIiwiaGFzIiwiX29sZCR0b3AyIiwiX29sZCRib3R0b20yIiwiX3JlZjQiLCJlbmFibGVSb3dQaW5uaW5nIiwiaXNUb3AiLCJpc0JvdHRvbSIsIl90YWJsZSRfZ2V0UGlubmVkUm93cyIsIl92aXNpYmxlUGlubmVkUm93SWRzJCIsInZpc2libGVQaW5uZWRSb3dJZHMiLCJfZ2V0UGlubmVkUm93cyIsIl9yZWY1IiwiZ2V0Q2VudGVyVmlzaWJsZUNlbGxzIiwiX2dldEFsbFZpc2libGVDZWxscyIsImFsbENlbGxzIiwibGVmdEFuZFJpZ2h0IiwiZ2V0TGVmdFZpc2libGVDZWxscyIsImNlbGxzIiwiZ2V0UmlnaHRWaXNpYmxlQ2VsbHMiLCJyZXNldENvbHVtblBpbm5pbmciLCJnZXRJc1NvbWVDb2x1bW5zUGlubmVkIiwiX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvIiwicGlubmluZ1N0YXRlIiwiX3Bpbm5pbmdTdGF0ZSRsZWZ0IiwiX3Bpbm5pbmdTdGF0ZSRyaWdodCIsImdldExlZnRMZWFmQ29sdW1ucyIsImdldFJpZ2h0TGVhZkNvbHVtbnMiLCJnZXRDZW50ZXJMZWFmQ29sdW1ucyIsInJlc2V0Um93UGlubmluZyIsIl90YWJsZSRpbml0aWFsU3RhdGUkciIsImdldElzU29tZVJvd3NQaW5uZWQiLCJfcGlubmluZ1N0YXRlJHBvc2l0aW8yIiwiX3Bpbm5pbmdTdGF0ZSR0b3AiLCJfcGlubmluZ1N0YXRlJGJvdHRvbSIsInZpc2libGVSb3dzIiwicGlubmVkUm93SWRzIiwiX3RhYmxlJG9wdGlvbnMka2VlcFBpIiwia2VlcFBpbm5lZFJvd3MiLCJnZXRUb3BSb3dzIiwiZ2V0Qm90dG9tUm93cyIsImdldENlbnRlclJvd3MiLCJhbGxSb3dzIiwidG9wQW5kQm90dG9tIiwiUm93U2VsZWN0aW9uIiwicm93U2VsZWN0aW9uIiwib25Sb3dTZWxlY3Rpb25DaGFuZ2UiLCJlbmFibGVSb3dTZWxlY3Rpb24iLCJlbmFibGVNdWx0aVJvd1NlbGVjdGlvbiIsImVuYWJsZVN1YlJvd1NlbGVjdGlvbiIsInNldFJvd1NlbGVjdGlvbiIsInJlc2V0Um93U2VsZWN0aW9uIiwidG9nZ2xlQWxsUm93c1NlbGVjdGVkIiwiZ2V0SXNBbGxSb3dzU2VsZWN0ZWQiLCJwcmVHcm91cGVkRmxhdFJvd3MiLCJnZXRDYW5TZWxlY3QiLCJ0b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkIiwicmVzb2x2ZWRWYWx1ZSIsImdldElzQWxsUGFnZVJvd3NTZWxlY3RlZCIsIm11dGF0ZVJvd0lzU2VsZWN0ZWQiLCJnZXRQcmVTZWxlY3RlZFJvd01vZGVsIiwiZ2V0U2VsZWN0ZWRSb3dNb2RlbCIsInJvd01vZGVsIiwic2VsZWN0Um93c0ZuIiwiZ2V0RmlsdGVyZWRTZWxlY3RlZFJvd01vZGVsIiwiZ2V0R3JvdXBlZFNlbGVjdGVkUm93TW9kZWwiLCJpc0FsbFJvd3NTZWxlY3RlZCIsInBhZ2luYXRpb25GbGF0Um93cyIsImlzQWxsUGFnZVJvd3NTZWxlY3RlZCIsImdldElzU29tZVJvd3NTZWxlY3RlZCIsIl90YWJsZSRnZXRTdGF0ZSRyb3dTZSIsInRvdGFsU2VsZWN0ZWQiLCJnZXRJc1NvbWVQYWdlUm93c1NlbGVjdGVkIiwiZ2V0SXNTZWxlY3RlZCIsImdldElzU29tZVNlbGVjdGVkIiwiZ2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkSGFuZGxlciIsInRhcmdldCIsImNoZWNrZWQiLCJnZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkSGFuZGxlciIsInRvZ2dsZVNlbGVjdGVkIiwiaXNTZWxlY3RlZCIsIl9vcHRzJHNlbGVjdENoaWxkcmVuIiwic2VsZWN0ZWRSb3dJZHMiLCJzZWxlY3RDaGlsZHJlbiIsImlzUm93U2VsZWN0ZWQiLCJpc1N1YlJvd1NlbGVjdGVkIiwiZ2V0SXNBbGxTdWJSb3dzU2VsZWN0ZWQiLCJnZXRDYW5TZWxlY3RTdWJSb3dzIiwiZ2V0Q2FuTXVsdGlTZWxlY3QiLCJnZXRUb2dnbGVTZWxlY3RlZEhhbmRsZXIiLCJjYW5TZWxlY3QiLCJfdGFyZ2V0IiwiaW5jbHVkZUNoaWxkcmVuIiwibmV3U2VsZWN0ZWRGbGF0Um93cyIsIm5ld1NlbGVjdGVkUm93c0J5SWQiLCJyZWN1cnNlUm93cyIsIl9yb3ckc3ViUm93czIiLCJzZWxlY3Rpb24iLCJfc2VsZWN0aW9uJHJvdyRpZCIsIl9yb3ckc3ViUm93czMiLCJhbGxDaGlsZHJlblNlbGVjdGVkIiwic29tZVNlbGVjdGVkIiwic3ViUm93Iiwic3ViUm93Q2hpbGRyZW5TZWxlY3RlZCIsInJlU3BsaXRBbHBoYU51bWVyaWMiLCJhbHBoYW51bWVyaWMiLCJyb3dBIiwicm93QiIsImNvbXBhcmVBbHBoYW51bWVyaWMiLCJhbHBoYW51bWVyaWNDYXNlU2Vuc2l0aXZlIiwidGV4dCIsImNvbXBhcmVCYXNpYyIsInRleHRDYXNlU2Vuc2l0aXZlIiwiZGF0ZXRpbWUiLCJiYXNpYyIsImFTdHIiLCJiU3RyIiwiYWEiLCJiYiIsImFuIiwicGFyc2VJbnQiLCJibiIsImNvbWJvIiwic29ydGluZ0ZucyIsIlNvcnRpbmciLCJzb3J0aW5nIiwic29ydGluZ0ZuIiwic29ydFVuZGVmaW5lZCIsIm9uU29ydGluZ0NoYW5nZSIsImlzTXVsdGlTb3J0RXZlbnQiLCJzaGlmdEtleSIsImdldEF1dG9Tb3J0aW5nRm4iLCJmaXJzdFJvd3MiLCJpc1N0cmluZyIsImdldEF1dG9Tb3J0RGlyIiwiZ2V0U29ydGluZ0ZuIiwiX3RhYmxlJG9wdGlvbnMkc29ydGluIiwiX3RhYmxlJG9wdGlvbnMkc29ydGluMiIsInRvZ2dsZVNvcnRpbmciLCJkZXNjIiwibXVsdGkiLCJuZXh0U29ydGluZ09yZGVyIiwiZ2V0TmV4dFNvcnRpbmdPcmRlciIsImhhc01hbnVhbFZhbHVlIiwic2V0U29ydGluZyIsImV4aXN0aW5nU29ydGluZyIsImV4aXN0aW5nSW5kZXgiLCJuZXdTb3J0aW5nIiwic29ydEFjdGlvbiIsIm5leHREZXNjIiwiZ2V0Q2FuTXVsdGlTb3J0IiwiX3RhYmxlJG9wdGlvbnMkbWF4TXVsIiwibWF4TXVsdGlTb3J0Q29sQ291bnQiLCJnZXRGaXJzdFNvcnREaXIiLCJfY29sdW1uJGNvbHVtbkRlZiRzb3IiLCJzb3J0RGVzY0ZpcnN0IiwiZmlyc3RTb3J0RGlyZWN0aW9uIiwiaXNTb3J0ZWQiLCJnZXRJc1NvcnRlZCIsImVuYWJsZVNvcnRpbmdSZW1vdmFsIiwiZW5hYmxlTXVsdGlSZW1vdmUiLCJnZXRDYW5Tb3J0IiwiZW5hYmxlU29ydGluZyIsImVuYWJsZU11bHRpU29ydCIsIl90YWJsZSRnZXRTdGF0ZSRzb3J0aSIsImNvbHVtblNvcnQiLCJnZXRTb3J0SW5kZXgiLCJfdGFibGUkZ2V0U3RhdGUkc29ydGkyIiwiX3RhYmxlJGdldFN0YXRlJHNvcnRpMyIsImNsZWFyU29ydGluZyIsImdldFRvZ2dsZVNvcnRpbmdIYW5kbGVyIiwiY2FuU29ydCIsInJlc2V0U29ydGluZyIsIl90YWJsZSRpbml0aWFsU3RhdGUkcyIsImdldFByZVNvcnRlZFJvd01vZGVsIiwiX2dldFNvcnRlZFJvd01vZGVsIiwibWFudWFsU29ydGluZyIsIlZpc2liaWxpdHkiLCJjb2x1bW5WaXNpYmlsaXR5Iiwib25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlIiwidG9nZ2xlVmlzaWJpbGl0eSIsImdldENhbkhpZGUiLCJzZXRDb2x1bW5WaXNpYmlsaXR5IiwiY2hpbGRDb2x1bW5zIiwiYyIsImVuYWJsZUhpZGluZyIsImdldFRvZ2dsZVZpc2liaWxpdHlIYW5kbGVyIiwiZ2V0QWxsQ2VsbHMiLCJnZXRWaXNpYmxlQ2VsbHMiLCJtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QiLCJnZXRDb2x1bW5zIiwiZ2V0VmlzaWJsZUZsYXRDb2x1bW5zIiwiZ2V0QWxsRmxhdENvbHVtbnMiLCJnZXRMZWZ0VmlzaWJsZUxlYWZDb2x1bW5zIiwiZ2V0UmlnaHRWaXNpYmxlTGVhZkNvbHVtbnMiLCJnZXRDZW50ZXJWaXNpYmxlTGVhZkNvbHVtbnMiLCJyZXNldENvbHVtblZpc2liaWxpdHkiLCJ0b2dnbGVBbGxDb2x1bW5zVmlzaWJsZSIsIl92YWx1ZSIsImdldElzQWxsQ29sdW1uc1Zpc2libGUiLCJvYmoiLCJnZXRJc1NvbWVDb2x1bW5zVmlzaWJsZSIsImdldFRvZ2dsZUFsbENvbHVtbnNWaXNpYmlsaXR5SGFuZGxlciIsImZlYXR1cmVzIiwiX29wdGlvbnMkaW5pdGlhbFN0YXRlIiwiZGVidWdUYWJsZSIsImRlZmF1bHRPcHRpb25zIiwiYXNzaWduIiwibWVyZ2VPcHRpb25zIiwiY29yZUluaXRpYWxTdGF0ZSIsIl9mZWF0dXJlJGdldEluaXRpYWxTdCIsInF1ZXVlZFRpbWVvdXQiLCJjb3JlSW5zdGFuY2UiLCJjYiIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImNhdGNoIiwiZXJyb3IiLCJzZXRUaW1lb3V0IiwicmVzZXQiLCJzZXRPcHRpb25zIiwibmV3T3B0aW9ucyIsIm9uU3RhdGVDaGFuZ2UiLCJfZ2V0Um93SWQiLCJnZXRSb3dJZCIsIl9nZXRDb3JlUm93TW9kZWwiLCJzZWFyY2hBbGwiLCJfZGVmYXVsdENvbHVtbiIsIl9wcm9wcyRyZW5kZXJWYWx1ZSR0byIsIl9wcm9wcyRyZW5kZXJWYWx1ZSIsInJlbmRlclZhbHVlIiwiX2dldENvbHVtbkRlZnMiLCJjb2x1bW5EZWZzIiwicmVjdXJzZUNvbHVtbnMiLCJncm91cGluZ0NvbHVtbkRlZiIsIl9nZXRBbGxGbGF0Q29sdW1uc0J5SWQiLCJmbGF0Q29sdW1ucyIsImFjYyIsImdldFJlbmRlclZhbHVlIiwiX2NlbGwkZ2V0VmFsdWUiLCJyZW5kZXJGYWxsYmFja1ZhbHVlIiwicm93SW5kZXgiLCJfdmFsdWVzQ2FjaGUiLCJfdW5pcXVlVmFsdWVzQ2FjaGUiLCJnZXRVbmlxdWVWYWx1ZXMiLCJnZXRQYXJlbnRSb3ciLCJwYXJlbnRSb3dzIiwicGFyZW50Um93IiwiY3JlYXRlQ29sdW1uSGVscGVyIiwiYWNjZXNzb3IiLCJkaXNwbGF5IiwiZ3JvdXAiLCJkYXRhIiwiYWNjZXNzUm93cyIsIm9yaWdpbmFsUm93cyIsImdldFN1YlJvd3MiLCJfcm93JG9yaWdpbmFsU3ViUm93cyIsIm9yaWdpbmFsU3ViUm93cyIsImZpbHRlclJvd3MiLCJmaWx0ZXJSb3dJbXBsIiwiZmlsdGVyUm93TW9kZWxGcm9tTGVhZnMiLCJmaWx0ZXJSb3dNb2RlbEZyb21Sb290Iiwicm93c1RvRmlsdGVyIiwiZmlsdGVyUm93IiwiX3RhYmxlJG9wdGlvbnMkbWF4TGVhIiwibmV3RmlsdGVyZWRGbGF0Um93cyIsIm5ld0ZpbHRlcmVkUm93c0J5SWQiLCJyZWN1cnNlRmlsdGVyUm93cyIsIm5ld1JvdyIsIl90YWJsZSRvcHRpb25zJG1heExlYTIiLCJwYXNzIiwicmVzb2x2ZWRDb2x1bW5GaWx0ZXJzIiwicmVzb2x2ZWRHbG9iYWxGaWx0ZXJzIiwiX2ZpbHRlckZuJHJlc29sdmVGaWx0IiwiZmlsdGVyYWJsZUlkcyIsImdsb2JhbGx5RmlsdGVyYWJsZUNvbHVtbnMiLCJfZ2xvYmFsRmlsdGVyRm4kcmVzb2wiLCJjdXJyZW50Q29sdW1uRmlsdGVyIiwiY3VycmVudEdsb2JhbEZpbHRlciIsImoiLCJmaWx0ZXJNZXRhIiwiX19nbG9iYWxfXyIsImZpbHRlclJvd3NJbXBsIiwicHJlUm93TW9kZWwiLCJfdGFibGUkZ2V0Q29sdW1uIiwiZmFjZXRlZFJvd01vZGVsIiwiZmFjZXRlZFVuaXF1ZVZhbHVlcyIsIl9mYWNldGVkVW5pcXVlVmFsdWVzJCIsInNldCIsImdldCIsIl9mYWNldGVkUm93TW9kZWwkZmxhdCIsImZpcnN0VmFsdWUiLCJmYWNldGVkTWluTWF4VmFsdWVzIiwic29ydGluZ1N0YXRlIiwic29ydGVkRmxhdFJvd3MiLCJhdmFpbGFibGVTb3J0aW5nIiwiY29sdW1uSW5mb0J5SWQiLCJzb3J0RW50cnkiLCJpbnZlcnRTb3J0aW5nIiwic29ydERhdGEiLCJzb3J0ZWREYXRhIiwiX3NvcnRFbnRyeSRkZXNjIiwiY29sdW1uSW5mbyIsImlzRGVzYyIsInNvcnRJbnQiLCJhVmFsdWUiLCJiVmFsdWUiLCJhVW5kZWZpbmVkIiwiYlVuZGVmaW5lZCIsImV4aXN0aW5nR3JvdXBpbmciLCJncm91cGVkRmxhdFJvd3MiLCJncm91cGVkUm93c0J5SWQiLCJncm91cFVwUmVjdXJzaXZlbHkiLCJyb3dHcm91cHNNYXAiLCJncm91cEJ5IiwiYWdncmVnYXRlZEdyb3VwZWRSb3dzIiwiZW50cmllcyIsImdyb3VwaW5nVmFsdWUiLCJncm91cGVkUm93cyIsIl9ncm91cGVkUm93cyQwJGdldFZhbCIsImFnZ3JlZ2F0ZUZuIiwiZ3JvdXBNYXAiLCJyZXNLZXkiLCJwcmV2aW91cyIsImV4cGFuZFJvd3MiLCJleHBhbmRlZFJvd3MiLCJoYW5kbGVSb3ciLCJwYWdlU3RhcnQiLCJwYWdlRW5kIiwicGFnaW5hdGVkUm93TW9kZWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\n");

/***/ })

};
;